/******************************************************************************/
如何下載google code 上的原始碼
/******************************************************************************/
1.首先到http://tortoisesvn.net/downloads.html 下載TortoiseSVN
2.接著在想要下載的地方新建資料夾
3.資料夾上按右鍵選擇SVN Checkout
4.在URL of repository填上http://xxxxxx.googlecode.com/svn/trunk/ 
    xxxxxx是project 名稱，按下OK就開始下載了


開源中國社區
http://www.java2s.com/Code/Android/Date-Type/byteArrayToHexString.htm
http://www.oschina.net/android/202/actionbar
http://ysl-paradise.blogspot.tw/


/******************************************************************************/
Eclipse hotkey (熱鍵、快捷鍵)
/******************************************************************************/
ctrl + z 回復上一次步驟
ctrl + y 重做下一次步驟
ctrl + / 註解 (取消註解)
ctrl + k 快速搜尋關鍵字 (如果先用ctrl + f 然後再找下一筆)
ctrl + f 搜尋關鍵字
ctrl + shift + o 自動匯入所欠缺的類別
ctrl + l 移至指定行數
ctrl + 滑鼠左鍵 跳至定義位置
alt + ← 跳到上一次游標所在位置
alt + → 跳到下一次游標所在位置
(這個功能常配合ctrl + 滑鼠左鍵，當查完定義後，要再回到原程式位置)
ctrl + shift + s 全部儲存
ctrl + shift + p 跳至匹配的括號
ctrl + q 跳至上一次編輯的位置

-----------------------------------------------------------------------------------------------------
ctrl + shift + L 顯示按鍵輔助
alt + / 程式碼輔助
alt + ↑ 上移 (快速的移動一行或一個段落)
alt + ↓ 下移 (快速的移動一行或一個段落)
ctrl + shift + k 快速搜尋關鍵字 (如果先用ctrl + f 然後再找上一筆)
ctrl + o 搜尋所有位於function名的關鍵字
ctrl + s 儲存
ctrl + D 單行刪除
ctrl + j 向下增量搜尋 (每打1個字母就開始向下搜尋)
ctrl + shift +j 向上增量搜尋 (每打1個字母就開始向上搜尋)
ctrl + shift + f 格式化程式碼


/******************************************************************************/
Android模擬器adb命令介紹
/******************************************************************************/
在SDK的Tools文件夾下包含著Android模擬器操作的重要命令adb，adb的全稱為(Android Debug Bridge就是調試橋的作用。通過adb我們可以在Eclipse中方面通過DDMS來調試
Android程式，說白了就是debug工具。
adb的工作方式比較特殊採用監聽Socket TCP 5554等連接埠的方式讓IDE和Qemu通訊，默認情況下adb會daemon相關的網路連接埠，所以當我們運行Eclipse時adb進程就會自動
運行。

1.通過adb可以輕鬆的執行Linux Shell命令，進入設備或模擬器的shell：adb shell就可以進入模擬器的shell環境中。也可以執行各種Linux的命令，
其命令格式為：adb shell command
範例:
adb shell dir 就是列舉目錄，在Linux中根目錄為/而不是Windows上的C磁碟、D磁碟
adb shell dmesg 會列印出Linux的debug訊息。
2.安裝apk程式到模擬器則執行adb install android123.apk，這樣名為android123的安裝包就會安裝到Android模擬器中，前提是android123.apk文件需要放到SDK\Tools目錄
下。
3.向emulator傳送文件，使用adb push android123.txt /tmp/android123.txt命令可以把SDK\Tools下的android123.txt文件傳輸到模擬器的/tmp/文件夾中，需要注意的是
/tmp/文件夾中內容會在Android模擬器重新啟動時清空。除了說明了使用ADT插件中DDMS外，如圖
4.從Android模擬器中回傳文件到電腦
通過adb pull /tmp/android123.txt android123.txt命令就會把模擬器的tmp文件夾下android123.txt文件回傳到電腦SDK\Tools目錄下。

繼續android adb命令相關介紹，除了可以方便的安裝apk文件、pc和Android模擬器互傳資料外還有Android Debug Bridge一些輔助的功能。
1.如果在Eclipse中發現有* daemon not running. starting it now *的提示可以結束adb
adb kill-server
2.顯示android模擬器狀態
adb devices 連接埠號等資訊，執行後會顯示TCP連接埠號
adb get-product 獲取設備型號
adb get-serialno 獲取序列號
3.等待正在運行的設備
adb wait-for-device
4.連接埠轉發
adb forward adb forward tcp:5555 tcp:1234 實現將默認的TCP 5555連接埠轉發到1234連接埠上
5.查看bug報告
adb bugreport

Android - How to mount the SDCard image file to Android Emulator
(1)首先必須產生SDCard的image file
mksdcard: create a blank FAT32 image to be used with the Android emulator
usage: mksdcard [-l label] 
if is a simple integer, it specifies a size in bytes
if is an integer followed by 'K', it specifies a size in KiB
if is an integer followed by 'M', it specifies a size in MiB
ex:mksdcard 1024M sdcard.iso

(2)讓SDCard連到Android Emulator
a:./emulator -sdcard ~/.android/SDK-1.0/sdcard.iso
b:用Eclipse中設定程式的Open Run Dialog,Target頁籤的Aditional Emulator Command Line Option中加入啟動參數 -sdcard scard.iso

(3)透過adb傳收檔案到emulator
adb push 
adb pull 
ex:
adb push ~/mp3/audio.mp3 /sdcard/audio.mp3

linux底下也可以使用,來管理
mount -o loop sdcard.img android_sdcard 

(4)進入emulator的shell
adb shell


資料來源:
http://www.android123.com.cn/moniqi/54.html
http://www.android123.com.cn/moniqi/55.html
http://blackdidi.wordpress.com/2008/10/10/android-how-to-mount-the-sdcard-image-file-to-android-emulator/
http://www.android123.com.cn/moniqi/48.html

官方ADB文件:
http://code.google.com/android/reference/adb.html


/******************************************************************************/
adb command 一般常用
/******************************************************************************/
adb shell
adb devices 裝置連結確認
adb reboot bootloader 重啟至bootloader介面
adb reboot recovery 重啟至recovery介面
adb shell getprop ro.cid 查詢cid
adb shell getprop 查看裝置全部訊息參數
adb shell getprop ro.serialno 查看裝置的SN
adb shell getprop ro.carrier 查看裝置的CID
adb shell getprop ro.hardware 查看裝置機板代號
adb shell getprop ro.bootloader 查看SPL（HBOOT）版本號

adb shell
mount |grep ext 查看ext


/******************************************************************************/
Android adb tool 功能整理       from : http://huenlil.pixnet.net/blog/post/23271843-android-adb-tool-%E5%8A%9F%E8%83%BD%E6%95%B4%E7%90%86
/******************************************************************************/
Adb 全名是 Android Debug Bridge，是開發或使用 Android 時很常用到的工具。使用者可以從Android 官方站下載 SDK，在其中的 platform-tools (原本在 \Tools) 中找到。
當機器上有打開 USB debug mode 時，使用者即可通過adb 進行各種 debug 、底層(linux user space)的 Android 功能。比較常用的功能：
- tools\ddms.bat: Android AP/Framework 層最主要的 debug tool
 - 安裝 Android 應用程式
- 連接機器，使用 linux userspace 的功能。 ex: ping, ssh, ftp ... blah blah.
adb的工作方式比較特殊採用監聽Socket TCP 5554等連接埠的方式讓IDE和Qemu通訊，預設情況下adb會daemon相關的port。

這篇文章主要是整理了一些adb 的基本功能，後面補上一些開發時常用的功能。
文件參考:
- 官方的說明文件: http://developer.android.com/intl/zh-TW/guide/developing/tools/adb.html
- Android模擬器adb命令介紹
- Source code: system/core/adb/ ，除了 adb client 跟 adbd (Android 系統內負責處理 adb 功能的 daemon)的實作外，裡面包含了 service 跟 overview 的文件。

功能介紹
1. 通過adb 進入機器或模擬器的shell模式
adb shell
也可以執行各種Linux的命令，其命令格式為：adb shell command
PS: 當 adb shell 之後提示字元為"#"時，表示使用者為 root (最大權限)，若是 "$" 則是以shell 權限工作
adb shell ls 就是列出目錄
adb shell dmesg 會列印出Linux kernel log
adb shell cat /proc/kmsg 持續印出 kernel log (需要 root)
adb shell keyevent 1 輸入 keyevent，可輸入的內容參考 adb shell keyevent

2. 安裝Android 應用程式(*.apk)
可執行adb install android123.apk，這樣名為android123的安裝包就會安裝到Android模擬器中，前提是android123.apk文件需要放到SDK\Tools目錄下。
比較特殊的安裝方法還有
"-r": 當已經安裝過舊版本的程式時，可以使用 -r 去覆蓋。
"-f": 強制安裝，通常在安裝程式時會遇到相容問題，可使用此參數解決。

3. PC 端與Android 機器的檔案傳輸
除了使用記憶卡模式外，還可使用下面命令可以進行檔案傳輸:
把android123.txt 傳到機器上的/tmp/ 資料夾中：
adb push android123.txt /tmp/android123.txt
從機器上把 android123.txt 抓到PC端：
adb pull /tmp/android123.txt android123.txt

4. 顯示系統資訊 - dumpsys
除了直接輸入 adb shell dumpsys 外，也可以另外指定要顯示的 service，簡列一些參數，用法如：
adb shell dumpsys SurfaceFlinger
battery: 列出基本的電池資訊
batteryinfo: 各種功能使用 power 的狀況，同About Phone 裡面的電池使用狀況。
SurfaceFlinger: 系統的 Surface 使用情況
power: 列出 Power Manager 的參數，如 wakelock 時間等
alarm: 列出目前有註冊 alarm 者

5. 其他
- Android 預設可編譯成三種模式： eng, userdebug, user。一般使用者拿到的機器多是 user 版，當然如果是開發人員，可能會使用 eng 或 userdebug 版 進行debug。或是使用者自行 root 機器後，可使用下列指令取得 root 權限
adb root
- 一般為了防止系統出問題，所以 /system 通常在掛載時會設定為唯讀(read only)，當使用者有root權限時，可使用下面指令將系統重新掛載成 R/W 模式，可對 /system 內的檔案做修改
adb remount
- 如果在使用 adb 時發現有* daemon not running. starting it now *的提示可以結束adb
adb kill-server
- 顯示 android 機器連接狀況
adb devices 
結果如下
List of devices attached
1234567890ABCDEF        device
- 等待正在運行的設備
adb wait-for-device
- Port forwarding，在某些應用如模擬器的網路連接使用、VNC時，會用到這項功能。主要是用來將機器上的的TCP port 5555 轉發到 port 1234
adb forward tcp:5555 tcp:1234 
- 擷取系統內的各種資訊，產生 bug report 
adb bugreport


/******************************************************************************/
排除匯入時的Unable to resolve target錯誤
/******************************************************************************/
Android有兩個版本的AVD已經從新版的SDK中排除，但是有部份已經完成的程式卻是用這兩個版號開發，在匯入專案（Project）時Eclipse會顯示「Unable to resolve target android-X（X為建立時版本）」。
目前Android 2.0（android-5）與2.0.1（android-6）這兩個短命的版本已經從新的SDK排除，至少我從R6開始就沒見過他們了。
修正的方法很簡單，修改專案資料夾內的「default.properties」文件，將「target」修改為手邊有的AVD版本。例如2.1是「android-7」，其他以此類推。


/******************************************************************************/
Draw design.
/******************************************************************************/
http://www.droiddraw.org/


/******************************************************************************/
71道Android開發面試題目。       from: http://blog.csdn.net/heirenheiren/article/details/7341185
/******************************************************************************/
Android面試題
(b )    1. 下列哪些語句關於記憶體回收的說明是正確的? 
           A、 程式員必須創建一個線程來釋放記憶體       B、 記憶體回收程式負責釋放無用記憶體
           C、 記憶體回收程式允許程式員直接釋放記憶體   D、 記憶體回收程式可以在指定的時間釋放記憶體對像
(abcd） 2. 下面異常是屬於Runtime Exception 的是 (多選)      
           A、ArithmeticException       B、IllegalArgumentException 
           C、NullPointerException      D、BufferUnderflowException 
(c)     3. Math.round(11.5)等於多少(). Math.round(-11.5)等於多少
           A、11 ,-11   B、11 ,-12   C、12 ,-11   D、12 ,-12
(b)     4. 下列程式段的輸出結果是：
           void complicatedexpression_r(){
               int x=20, y=30;
               boolean b;
               b=x>50&&y>60||x>50&&y<-60||x<-50&&y>60||x<-50&&y<-60;
               System.out.println(b);
           }
     A、true  B、false  C、1  D、011.activity
(d)     5. 對一些資源以及狀態的操作保存，最好是保存在生命週期的哪個函數中進行
           A、onPause()  B、onCreate()   C、 onResume()   D、onStart()
6.        Intent傳遞數據時，下列的數據類型哪些可以被傳遞（abcd）(多選)       A、Serializable  B、charsequence  C、Parcelable  D、Bundle
7.        android 中下列屬於Intent的作用的是(c)  A、實現應用程式間的數據共享
  B、是一段長的生命週期，沒有用戶界面的程式，可以保持應用在後台運行，而不會因為切換頁面而消失
  C、可以實現界面間的切換，可以包含動作和動作數據，連接四大元件的紐帶
  D、處理一個應用程式整體性的工作
8.        下列屬於SAX解析xml文件的優點的是(b)      A、將整個文檔樹在記憶體中，便於操作，支援刪除，修改，重新排列等多種功能
      B、不用事先調入整個文檔，佔用資源少
      C、整個文檔調入記憶體，浪費時間和空間
      D、不是長久駐留在記憶體，數據不是持久的，事件過後，若沒有保存數據，數據就會
  消失
9.         下面的對自定style的方式正確的是（a）    
  A、 <resources>
        <style name="myStyle">
             <itemname="android:layout_width">fill_parent</item>
        </style>
      </resources>
  B、 <style name="myStyle">
        <itemname="android:layout_width">fill_parent</item>
      </style>
  C、 <resources>
          <itemname="android:layout_width">fill_parent</item>
      </resources>
  D、 <resources>
          <stylename="android:layout_width">fill_parent</style>
      </resources>
10.       在android中使用Menu時可能需要重寫的方法有（ac）。(多選)      A、onCreateOptionsMenu() 
  B、onCreateMenu()
  C、onOptionsItemSelected()
  D、onItemSelected()
11.      在SQL Server Management Studio 中運行下列T-SQL語句，其輸出值（c）。 SELECT @@IDENTITY  
     A、      可能為0.1
     B、       可能為3
     C、      不可能為-100
     D、      肯定為0
12.     在SQL Server 2005中運行如下T-SQL語句，假定SALES表中有多行數據，執行查詢之     後的結果是（d）。BEGIN TRANSACTION A
       Update SALES Set qty=30 WHERE qty<30
        BEGIN TRANSACTION B
              Update SALES Set qty=40 WHEREqty<40
              Update SALES Set qty=50 WHEREqty<50
              Update SALES Set qty=60 WHEREqty<60
        COMMIT　TRANSACTION B
        COMMIT TRANSACTION A
A、SALES表中qty列最小值大於等於30
B、SALES表中qty列最小值大於等於40
C、SALES表中qty列的數據全部為50
D、SALES表中qty列最小值大於等於60
13.      在android中使用SQLiteOpenHelper這個輔助類時，可以生成一個數據庫，並可以對數據庫版本進行管理的方法可以是(ab)    A、getWriteableDatabase()
B、getReadableDatabase()
C、getDatabase()
D、getAbleDatabase()
14.     android 關於service生命週期的onCreate()和onStart()說法正確的是(ad)(多選題)    A、當第一次啟動的時候先後調用onCreate()和onStart()方法
    B、當第一次啟動的時候只會調用onCreate()方法
    C、如果service已經啟動，將先後調用onCreate()和onStart()方法
D、如果service已經啟動，只會執行onStart()方法，不在執行onCreate()方法
15.     下面是屬於GLSurFaceView特性的是(abc)(多選) A、管理一個surface，這個surface就是一塊特殊的記憶體，能直接排版到android的視圖
    view上。
B、管理一個EGL display，它能讓opengl把內容渲染到上述的surface上。
C、讓渲染器在獨立的線程裡運作，和UI線程分離。
D、可以直接從記憶體或者DMA等硬體介面取得圖像數據
16.     下面在AndroidManifest.xml文件中註冊BroadcastReceiver方式正確的(a)
     A、<receiver android:name="NewBroad">
                <intent-filter>
                        <action  
                                android:name="android.provider.action.NewBroad"/>
                        <action>
                </intent-filter>
        </receiver>
     B、<receiver android:name="NewBroad">
                <intent-filter>
                   android:name="android.provider.action.NewBroad"/>
                </intent-filter>
        </receiver>
     C、<receiver android:name="NewBroad">
                     <action  
                  android:name="android.provider.action.NewBroad"/>
             <action>
              </receiver>
     D、<intent-filter>
         <receiver android:name="NewBroad">
                           <action>
                   android:name="android.provider.action.NewBroad"/>
                  <action>
                     </receiver>
</intent-filter>
17.     關於ContenValues類說法正確的是(a)     
     A、他和Hashtable比較類似，也是負責存儲一些名值對，但是他存儲的名值對當中的
        名是String類型，而值都是基本類型
     B、他和Hashtable比較類似，也是負責存儲一些名值對，但是他存儲的名值對當中的
        名是任意類型，而值都是基本類型
     C、他和Hashtable比較類似，也是負責存儲一些名值對，但是他存儲的名值對當中的
        名，可以為空，而值都是String類型     
     D、他和Hashtable比較類似，也是負責存儲一些名值對，但是他存儲的名值對當中
        的名是String類型，而值也是String類型

18.     我們都知道Hanlder是線程與Activity通信的橋樑,如果線程處理不當，你的機器就會變得越慢，那麼線程銷毀的方法是(a)
      A、onDestroy() 
      B、onClear()
      C、onFinish() 
      D、onStop()

19.     下面退出Activity錯誤的方法是（c）     
A、finish()
B、拋異常強制退出
C、System.exit()
D、onStop()
20.     下面屬於android的動畫分類的有(ab)(多項)       A、Tween  B、Frame C、Draw D、Animation 
21.     下面關於Android dvm的進程和Linux的進程,應用程式的進程說法正確的是(d)        
A、DVM指dalivk的虛擬機.每一個Android應用程式都在它自己的進程中運行,不一定擁有一個獨立 的Dalvik虛擬機實例.而每一個DVM都是在Linux中的一個進程,所以說可以認為是同一個概念.
B、DVM指dalivk的虛擬機.每一個Android應用程式都在它自己的進程中運行,不一定擁有一個獨立的Dalvik虛擬機實例.而每一個DVM不一定都是在Linux 中的一個進程,所以說不是一個概念.
C、DVM指dalivk的虛擬機.每一個Android應用程式都在它自己的進程中運行,都擁有一個獨立的Dalvik虛擬機實例.而每一個DVM不一定都是在Linux 中的一個進程,所以說不是一個概念.
D、DVM指dalivk的虛擬機.每一個Android應用程式都在它自己的進程中運行,都擁有一個獨立的 Dalvik虛擬機實例.而每一個DVM都是在Linux 中的一個進程,所以說可以認為是同一個概念.
22.       Android項目工程下面的assets目錄的作用是什麼b
A、放置應用到的圖片資源。
B、主要放置多媒體等數據文件
C、放置字串，顏色，數組等常量數據
D、放置一些與UI相應的佈局文件，都是xml文件

23.       關於res/raw目錄說法正確的是(a)
A、 這裡的文件是原封不動的存儲到設備上不會轉換為二進位的格式
B、這裡的文件是原封不動的存儲到設備上會轉換為二進位的格式
C、 這裡的文件最終以二進位的格式存儲到指定的包中
D、這裡的文件最終不會以二進位的格式存儲到指定的包中

24.      下列對android NDK的理解正確的是(abcd )
A、 NDK是一系列工具的集合
B、 NDK 提供了一份穩定、功能有限的 API 頭文件聲明。
C、 使 「Java+C」 的開發方式終於轉正，成為官方支援的開發方式
D、 NDK 將是 Android 平台支援 C 開發的開端

二．填空題
25.      android中常用的四個佈局是framlayout，linenarlayout，relativelayout和tablelayout。
26.      android 的四大元件是activiey，service，broadcast和contentprovide。
27.      java.io包中的objectinputstream和objectoutputstream類主要用於對對像(Object)的讀寫。
28.      android 中service的實現方法是：startservice和bindservice。
29.      activity一般會重載7個方法用來維護其生命週期，除了onCreate(),onStart(),onDestory()   外還有onrestart,onresume,onpause,onstop。
30.      android的數據存儲的方式sharedpreference,文件,SQlite,contentprovider,網路。
31.     當啟動一個Activity並且新的Activity執行完後需要返回到啟動它的Activity來執行 的回調函數是startActivityResult()。
32.     請使用命令行的方式創建一個名字為myAvd,sdk版本為2.2,sd卡是在d盤的根目錄下,名字為scard.img， 並指定螢幕大小HVGA.____________________________________。
33.       程式運行的結果是：_____good and gbc__________。    
public classExample{ 
　　String str=new String("good"); 
　　char[]ch={'a','b','c'}; 
　　public static void main(String args[]){ 
　　　　Example ex=new Example(); 
　　　　ex.change(ex.str,ex.ch); 
　　　　System.out.print(ex.str+" and "); 
　　　　Sytem.out.print(ex.ch); 
　　} 
　　public void change(String str,char ch[]){ 
　　　　str="test ok"; 
　　　　ch[0]='g'; 
　　} 
} 

34.      在android中，請簡述jni的調用過程。(8分)
1)安裝和下載Cygwin，下載 Android NDK
2)在ndk項目中JNI介面的設計
3)使用C/C++實現本地方法
4)JNI生成動態鏈接庫.so文件
5)將動態鏈接庫複製到java工程，在java工程中調用，運行java工程即可

35.     簡述Android應用程式結構是哪些?（7分）Android應用程式結構是：
  Linux Kernel(Linux內核)、Libraries(系統運行庫或者是c/c++核心庫)、Application  
  Framework(開發框架包)、Applications  (核心應用程式)

36.     請繼承SQLiteOpenHelper實現：(10分)   1）.創建一個版本為1的「diaryOpenHelper.db」的數據庫，
   2）.同時創建一個 「diary」 表（包含一個_id主鍵並自增長，topic字元型100
       長度， content字元型1000長度）
    3）.在數據庫版本變化時請刪除diary表，並重新創建出diary表。

publicclass DBHelper  extends SQLiteOpenHelper{

       public final static String DATABASENAME ="diaryOpenHelper.db";
       public final static int DATABASEVERSION =1;

       //創建數據庫
       public DBHelper(Context context,Stringname,CursorFactory factory,int version)
       {
              super(context, name, factory,version);
       }
       //創建表等機構性文件
       public void onCreate(SQLiteDatabase db)
       {
              String sql ="create tablediary"+
                                   "("+
                                   "_idinteger primary key autoincrement,"+
                                   "topicvarchar(100),"+
                                   "contentvarchar(1000)"+
                                   ")";
              db.execSQL(sql);
       }
       //若數據庫版本有更新，則調用此方法
       public void onUpgrade(SQLiteDatabasedb,int oldVersion,int newVersion)
       {
              
              String sql = "drop table ifexists diary";
              db.execSQL(sql);
              this.onCreate(db);
       }
}

37.     頁面上現有ProgressBar控件progressBar，請用書寫線程以10秒的的時間完成其進度顯示工作。（10分）答案
publicclass ProgressBarStu extends Activity {

       private ProgressBar progressBar = null;
       protected void onCreate(BundlesavedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.progressbar);
              //從這到下是關鍵
              progressBar = (ProgressBar)findViewById(R.id.progressBar);
              
              Thread thread = new Thread(newRunnable() {
                     
                     @Override
                     public void run() {
                            int progressBarMax =progressBar.getMax();
                            try {
                                   while(progressBarMax!=progressBar.getProgress())
                                   {
                                          
                                          intstepProgress = progressBarMax/10;
                                          intcurrentprogress = progressBar.getProgress();
                                          progressBar.setProgress(currentprogress+stepProgress);
                                          Thread.sleep(1000);
                                   }
                                   
                            } catch(InterruptedException e) {
                                   // TODO Auto-generatedcatch block
                                   e.printStackTrace();
                            }
                            
                     }
              });
              
              thread.start();

              //關鍵結束
       }
       
}
38.        請描述下Activity的生命週期。      必調用的三個方法：onCreate() --> onStart() --> onResume()，用AAA表示
（1）父Activity啟動子Activity，子Actvity退出，父Activity調用順序如下
AAA --> onFreeze() --> onPause() --> onStop() --> onRestart()--> onStart(),onResume() …
（2）用戶點擊Home，Actvity調用順序如下
AAA --> onFreeze() --> onPause() --> onStop() -- Maybe -->onDestroy() – Maybe
（3）調用finish()， Activity調用順序如下
AAA --> onPause() --> onStop() --> onDestroy()
（4）在Activity上顯示dialog，Activity調用順序如下
AAA
（5）在父Activity上顯示透明的或非全屏的activity，Activity調用順序如下
AAA --> onFreeze() --> onPause()
（6）設備進入睡眠狀態，Activity調用順序如下
AAA --> onFreeze() --> onPause()
39.      如果後台的Activity由於某原因被系統回收了，如何在被系統回收之前保存當前狀態？      onSaveInstanceState()
      當你的程式中某一個Activity A在運行時，主動或被動地運行另一個新的Activity B，這個時候A會執行onSaveInstanceState()。B完成以後又會來找A，這個時候就有兩種情況：一是A被回收，二是A沒有被回收，被回收的A就要重新調用onCreate()方法，不同於直接啟動的是這回onCreate()裡是帶上了參數savedInstanceState；而沒被收回的就直接執行onResume()，跳過onCreate()了。 
40.       如何將一個Activity設置成窗口的樣式。      在AndroidManifest.xml 中定義Activity的地方一句話android:theme="@android:style/Theme.Dialog"或android:theme="@android:style/Theme.Translucent"就變成半透明的
41.     如何退出Activity？如何安全退出已調用多個Activity的Application？對於單一Activity的應用來說，退出很簡單，直接finish()即可。
當然，也可以用killProcess()和System.exit()這樣的方法。

但是，對於多Activity的應用來說，在打開多個Activity後，如果想在最後打開的Activity直接退出，上邊的方法都是沒有用的，因為上邊的方法都是結束一個Activity而已。
當然，網上也有人說可以。
就好像有人問，在應用裡如何捕獲Home鍵，有人就會說用keyCode比較KEYCODE_HOME即可，而事實上如果不修改framework，根本不可能做到這一點一樣。
所以，最好還是自己親自試一下。

那麼，有沒有辦法直接退出整個應用呢？
在2.1之前，可以使用ActivityManager的restartPackage方法。
它可以直接結束整個應用。在使用時需要權限android.permission.RESTART_PACKAGES。
注意不要被它的名字迷惑。

可是，在2.2，這個方法失效了。
在2.2添加了一個新的方法，killBackgroundProcesses()，需要權限android.permission.KILL_BACKGROUND_PROCESSES。
可惜的是，它和2.2的restartPackage一樣，根本起不到應有的效果。

另外還有一個方法，就是系統自帶的應用程式管理裡，強制結束程式的方法，forceStopPackage()。
它需要權限android.permission.FORCE_STOP_PACKAGES。
並且需要添加android:sharedUserId="android.uid.system"屬性
同樣可惜的是，該方法是非公開的，他只能運行在系統進程，第三方程式無法調用。
因為需要在Android.mk中添加LOCAL_CERTIFICATE := platform。
而Android.mk是用於在Android源碼下編譯程式用的。

從以上可以看出，在2.2，沒有辦法直接結束一個應用，而只能用自己的辦法間接辦到。

現提供幾個方法，供參考：

1、拋異常強制退出：
該方法通過拋異常，使程式ForceClose。
驗證可以，但是，需要解決的問題是，如何使程式結束掉，而不彈出Force Close的窗口。

2、記錄打開的Activity：
每打開一個Activity，就記錄下來。在需要退出時，關閉每一個Activity即可。

3、發送特定廣播：
在需要結束應用時，發送一個特定的廣播，每個Activity收到廣播後，關閉即可。

4、遞歸退出
在打開新的Activity時使用startActivityForResult，然後自己加標誌，在onActivityResult中處理，遞歸關閉。

除了第一個，都是想辦法把每一個Activity都結束掉，間接達到目的。
但是這樣做同樣不完美。
你會發現，如果自己的應用程式對每一個Activity都設置了nosensor，在兩個Activity結束的間隙，sensor可能有效了。
但至少，我們的目的達到了，而且沒有影響用戶使用。
為了編程方便，最好定義一個Activity基類，處理這些共通問題。 

42.    請介紹下Android中常用的五種佈局。FrameLayout（框架佈局），LinearLayout （線性佈局），AbsoluteLayout（絕對佈局），RelativeLayout（相對佈局），TableLayout（表格佈局）
43.    請介紹下Android的數據存儲方式。
一.SharedPreferences方式
二.文件存儲方式
三.SQLite數據庫方式
四.內容提供器（Content provider）方式
五. 網路存儲方式
44.     請介紹下ContentProvider是如何實現數據共享的。創建一個屬於你自己的Content provider或者將你的數據添加到一個已經存在的Contentprovider中，前提是有相同數據類型並且有寫入Content provider的權限。
45.    如何啟用Service，如何停用Service。Android中的service類似於windows中的service，service一般沒有用戶操作界面，它運行於系統中不容易被用戶發覺，
可以使用它開發如監控之類的程式。
一。步驟
第一步：繼承Service類
public class SMSService extends Service { }
第二步：在AndroidManifest.xml文件中的<application>節點裡對服務進行配置:
<service android:name=".DemoService" />
二。Context.startService()和Context.bindService
服務不能自己運行，需要通過調用Context.startService()或Context.bindService()方法啟動服務。這兩個方法都可
以啟動Service，但是它們的使用場合有所不同。
1.使用startService()方法啟用服務，調用者與服務之間沒有關連，即使調用者退出了，服務仍然運行。
使用bindService()方法啟用服務，調用者與服務綁定在了一起，調用者一旦退出，服務也就終止。
2.採用Context.startService()方法啟動服務，在服務未被創建時，系統會先調用服務的onCreate()方法，
接著調用onStart()方法。如果調用startService()方法前服務已經被創建，多次調用startService()方法並
不會導致多次創建服務，但會導致多次調用onStart()方法。
採用startService()方法啟動的服務，只能調用Context.stopService()方法結束服務，服務結束時會調用
onDestroy()方法。 

3.採用Context.bindService()方法啟動服務，在服務未被創建時，系統會先調用服務的onCreate()方法，
接著調用onBind()方法。這個時候調用者和服務綁定在一起，調用者退出了，系統就會先調用服務的onUnbind()方法，
。接著調用onDestroy()方法。如果調用bindService()方法前服務已經被綁定，多次調用bindService()方法並不會
導致多次創建服務及綁定(也就是說onCreate()和onBind()方法並不會被多次調用)。如果調用者希望與正在綁定的服務
解除綁定，可以調用unbindService()方法，調用該方法也會導致系統調用服務的onUnbind()-->onDestroy()方法。
三。Service的生命週期
1.Service常用生命週期回調方法如下：

onCreate() 該方法在服務被創建時調用，該方法只會被調用一次，無論調用多少次startService()或bindService()方法，
服務也只被創建一次。 onDestroy()該方法在服務被終止時調用。 

2. Context.startService()啟動Service有關的生命週期方法
onStart() 只有採用Context.startService()方法啟動服務時才會回調該方法。該方法在服務開始運行時被調用。
多次調用startService()方法儘管不會多次創建服務，但onStart() 方法會被多次調用。

3. Context.bindService()啟動Service有關的生命週期方法
onBind()只有採用Context.bindService()方法啟動服務時才會回調該方法。該方法在調用者與服務綁定時被調用，
當調用者與服務已經綁定，多次調用Context.bindService()方法並不會導致該方法被多次調用。
onUnbind()只有採用Context.bindService()方法啟動服務時才會回調該方法。該方法在調用者與服務解除綁定時被調用。
備註：
1. 採用startService()啟動服務
     Intent intent =new Intent(DemoActivity.this, DemoService.class);
    startService(intent);
2.Context.bindService()啟動
    Intent intent =new Intent(DemoActivity.this, DemoService.class);
   bindService(intent, conn, Context.BIND_AUTO_CREATE);
   //unbindService(conn);//解除綁定

46.    註冊廣播有幾種方式，這些方式有何優缺點？請談談Android引入廣播機制的用意。  Android廣播機制（兩種註冊方法） 
在android下，要想接受廣播資訊，那麼這個廣播接收器就得我們自己來實現了，我們可以繼承BroadcastReceiver，就可以有一個廣播接受器了。有個接受器還不夠，我們還得重寫BroadcastReceiver裡面的onReceiver方法，當來廣播的時候我們要幹什麼，這就要我們自己來實現，不過我們可以搞一個資訊防火牆。具體的代碼：

public class SmsBroadCastReceiverextends BroadcastReceiver    
{  

   @Override  
   public void onReceive(Context context, Intent intent)   
   {   
       Bundle bundle = intent.getExtras();  
       Object[] object = (Object[])bundle.get("pdus");   
       SmsMessage sms[]=new SmsMessage[object.length];   
       for(int i=0;i<object.length;i++)  
       {   
            sms[0] =SmsMessage.createFromPdu((byte[])object);  
            Toast.makeText(context, "來自"+sms.getDisplayOriginatingAddress()+"的消息是："+sms.getDisplayMessageBody(),Toast.LENGTH_SHORT).show();   
       }   
       //終止廣播，在這裡我們可以稍微處理，根據用戶輸入的號碼可以實現短信防火牆。   
       abortBroadcast();   
   }   
      
} 

當實現了廣播接收器，還要設置廣播接收器接收廣播資訊的類型，這裡是資訊：android.provider.Telephony.SMS_RECEIVED

我們就可以把廣播接收器註冊到系統裡面，可以讓系統知道我們有個廣播接收器。這裡有兩種，一種是代碼動態註冊：

//生成廣播處理  
smsBroadCastReceiver = newSmsBroadCastReceiver();   
//實例化過濾器並設置要過濾的廣播  

IntentFilter intentFilter = newIntentFilter("android.provider.Telephony.SMS_RECEIVED"); 

//註冊廣播   
BroadCastReceiverActivity.this.registerReceiver(smsBroadCastReceiver,intentFilter);  
一種是在AndroidManifest.xml中配置廣播

<?xml version="1.0"encoding="utf-8"?>  
<manifestxmlns:android="http://schemas.android.com/apk/res/android"  
     package="spl.broadCastReceiver"  
     android:versionCode="1" 
     android:versionName="1.0"> 
   <application android:icon="@drawable/icon"android:label="@string/app_name"> 
       <activity android:name=".BroadCastReceiverActivity"  
                  android:label="@string/app_name">  
            <intent-filter>  
                <actionandroid:name="android.intent.action.MAIN" />  
                <categoryandroid:name="android.intent.category.LAUNCHER" />  
            </intent-filter>  
       </activity>  
           
       <!--廣播註冊-->  
       <receiver android:name=".SmsBroadCastReceiver">  
            <intent-filterandroid:priority="20">  
                <actionandroid:name="android.provider.Telephony.SMS_RECEIVED"/>  
            </intent-filter>  
       </receiver>  
           
   </application>  
      
   <uses-sdk android:minSdkVersion="7" />  
      
   <!-- 權限申請 -->  
   <uses-permissionandroid:name="android.permission.RECEIVE_SMS"></uses-permission>  
      
</manifest>   

兩種註冊類型的區別是：
    1)第一種不是常駐型廣播，也就是說廣播跟隨程式的生命週期。
    2)第二種是常駐型，也就是說當應用程式關閉後，如果有資訊廣播來，程式也會被系統調用自動運行。

47. 請解釋下在單線程模型中Message、Handler、MessageQueue、Looper之間的關係。
Handler簡介：
一個Handler允許你發送和處理Message和Runable對像，這些對像和一個線程的MessageQueue相關聯。每一個線程實例和一個單獨的線程以及該線程的MessageQueue相關聯。
當你創建一個新的Handler時，它就和創建它的線程綁定在一起了。這裡，線程我們也可以理解為線程的MessageQueue。
從這一點上來看，Handler把Message和Runable對像傳遞給MessageQueue，而且在這些對像離開MessageQueue時，Handler負責執行他們。
Handler有兩個主要的用途：
（1）確定在將來的某個時間點執行一個或者一些Message和Runnable對象。
（2）在其他線程（不是Handler綁定線程）中排入一些要執行的動作。
Scheduling Message，即（1），可以通過以下方法完成：
post(Runnable):Runnable在handler綁定的線程上執行，也就是說不創建新線程。
postAtTime(Runnable,long):
postDelayed(Runnable,long):
sendEmptyMessage(int):
sendMessage(Message):
sendMessageAtTime(Message,long):
sendMessageDelayed(Message,long):
post這個動作讓你把Runnable對像排入MessageQueue,MessageQueue受到這些消息的時候執行他們，當然以一定的排序。
sendMessage這個動作允許你把Message對像排成隊列，這些Message對像包含一些資訊，Handler的hanlerMessage(Message)會處理這些Message.
當然，handlerMessage(Message)必須由Handler的子類來重寫。這是編程人員需要作的事。
當posting或者sending到一個Hanler時，你可以有三種行為：
當MessageQueue準備好就處理，定義一個延遲時間，定義一個精確的時間去處理。後兩者允許你實現timeout,tick,和基於時間的行為。
當你的應用創建一個新的進程時，主線程（也就是UI線程）自帶一個MessageQueue，這個MessageQueue管理頂層的應用對像（像activities,broadcast receivers等）和主線
程創建的窗體。你可以創建自己的線程，並通過一個Handler和主線程進行通信。這和之前一樣，通過post和sendmessage來完成，差別在於在哪一個線程中執行這麼方法。
在恰當的時候，給定的Runnable和Message將在Handler的MessageQueue中被Scheduled。

Message簡介：
Message類就是定義了一個資訊，這個資訊中包含一個描述符和任意的數據對像，這個資訊被用來傳遞給Handler.Message對像提供額外的兩個int域和一個Object域，這可以讓
你在大多數情況下不用作分配的動作。
儘管Message的構造函數是public的，但是獲取Message實例的最好方法是調用Message.obtain(),或者Handler.obtainMessage()方法，這些方法會從回收對像池中獲取一個。
MessageQueue簡介：
這是一個包含message列表的底層類。Looper負責分發這些message。Messages並不是直接加到一個MessageQueue中，而是通過MessageQueue.IdleHandler關聯到Looper。
你可以通過Looper.myQueue()從當前線程中獲取MessageQueue。
Looper簡介：
Looper類被用來執行一個線程中的message循環。默認情況，沒有一個消息循環關聯到線程。在線程中調用prepare()創建一個Looper，然後用loop()來處理messages，直到循環終止。

大多數和message loop的交互是通過Handler。
下面是一個典型的帶有Looper的線程實現。
  class LooperThread extends Thread {
      public Handler mHandler;
      
      public void run() {
          Looper.prepare();
          
          mHandler = new Handler() {
              public voidhandleMessage(Message msg) {
                  // process incomingmessages here
              }
          };
          
          Looper.loop();
      }
  }

48. AIDL的全稱是什麼？如何工作？能處理哪些類型的數據？AIDL的英文全稱是Android Interface Define Language
當A進程要去調用B進程中的service時，並實現通信，我們通常都是通過AIDL來操作的
A工程：
首先我們在net.blogjava.mobile.aidlservice包中創建一個RemoteService.aidl文件，在裡面我們自定義一個介面，含有方法get。ADT插件會在gen目錄下自動生成一個RemoteService.java文件，該類中含有一個名為RemoteService.stub的內部類，該內部類中含有aidl文件介面的get方法。
說明一：aidl文件的位置不固定，可以任意
然後定義自己的MyService類，在MyService類中自定義一個內部類去繼承RemoteService.stub這個內部類，實現get方法。在onBind方法中返回這個內部類的對象，系統會自動將這個對象封裝成IBinder對像，傳遞給他的調用者。
其次需要在AndroidManifest.xml文件中配置MyService類，代碼如下：
<!-- 註冊服務 -->  
<service android:name=".MyService"> 
  <intent-filter> 
   <!--  指定調用AIDL服務的ID  --> 
       <actionandroid:name="net.blogjava.mobile.aidlservice.RemoteService" /> 
   </intent-filter> 
</service>
為什麼要指定調用AIDL服務的ID,就是要告訴外界MyService這個類能夠被別的進程訪問，只要別的進程知道這個ID，正是有了這個ID,B工程才能找到A工程實現通信。
說明：AIDL並不需要權限
B工程：
      首先我們要將A工程中生成的RemoteService.java文件拷貝到B工程中，在bindService方法中綁定aidl服務
      綁定AIDL服務就是將RemoteService的ID作為intent的action參數。
      說明：如果我們單獨將RemoteService.aidl文件放在一個包裡，那個在我們將gen目錄下的該包拷貝到B工程中。如果我們將RemoteService.aidl文件和我們的其他類存放在一起，那麼我們在B工程中就要建立相應的包，以保證RmoteService.java文件的報名正確，我們不能修改RemoteService.java文件
          bindService(newInten("net.blogjava.mobile.aidlservice.RemoteService"),serviceConnection, Context.BIND_AUTO_CREATE); 
      ServiceConnection的onServiceConnected(ComponentName name, IBinderservice)方法中的service參數就是A工程中MyService類中繼承了RemoteService.stub類的內部類的對象。

49.    請解釋下Android程式運行時權限與文件系統權限的區別。運行時權限Dalvik( android授權) 
文件系統 linux 內核授權

50.     系統上安裝了多種瀏覽器，能否指定某瀏覽器訪問指定頁面？請說明原由。通過直接發送Uri把參數帶過去，或者通過manifest裡的intentfilter裡的data屬性

51.    你如何評價Android系統？優缺點。答：Android平台手機 5大優勢： 
一、開放性 
在優勢方面，Android平台首先就是其開發性，開發的平台允許任何移動終端廠商加入到Android聯盟中來。顯著的開放性可以使其擁有更多的開發者，隨著用戶和應用的日益豐富，一個嶄新的平台也將很快走向成熟。開放性對於Android的發展而言，有利於積累人氣，這裡的人氣包括消費者和廠商，而對於消費者來講，隨大的受益正是豐富的軟體資源。開放的平台也會帶來更大競爭，如此一來，消費者將可以用更低的價位購得心儀的手機。
二、掙脫運營商的束縛 
在過去很長的一段時間，特別是在歐美地區，手機應用往往受到運營商制約，使用什麼功能接入什麼網路，幾乎都受到運營商的控制。從去年iPhone 上市 ，用戶可以更加方便地連接網路，運營商的制約減少。隨著EDGE、HSDPA這些2G至3G移動網路的逐步過渡和提升，手機隨意接入網路已不是運營商口中的笑談，當你可以通過手機IM軟體方便地進行即時聊天時，再回想不久前天價的彩信和圖鈴下載業務，是不是像噩夢一樣？互聯網巨頭Google推動的Android終端天生就有網路特色，將讓用戶離互聯網更近。
三、豐富的硬體選擇 
這一點還是與Android平台的開放性相關，由於Android的開放性，眾多的廠商會推出千奇百怪，功能特色各具的多種產品。功能上的差異和特色，卻不會影響到數據同步、甚至軟體的相容，好比你從諾基亞 Symbian風格手機 一下改用蘋果 iPhone ，同時還可將Symbian中優秀的軟體帶到iPhone上使用、聯繫人等資料更是可以方便地轉移，是不是非常方便呢？
四、不受任何限制的開發商 
Android平台提供給第三方開發商一個十分寬泛、自由的環境，不會受到各種條條框框的阻擾，可想而知，會有多少新穎別緻的軟體會誕生。但也有其兩面性，血腥、暴力、情色方面的程式和遊戲如可控制正是留給Android難題之一。
五、無縫結合的Google應用 
如今叱詫互聯網的Google已經走過10年度歷史，從搜索巨人到全面的互聯網滲透，Google服務如地圖、郵件、搜索等已經成為連接用戶和互聯網的重要紐帶，而Android平台手機將無縫結合這些優秀的Google服務。
再說Android的5大不足：
一、安全和隱私 
由於手機與互聯網的緊密聯繫，個人隱私很難得到保守。除了上網過程中經意或不經意留下的個人足跡，Google這個巨人也時時站在你的身後，洞穿一切，因此，互聯網的深入將會帶來新一輪的隱私危機。
二、首先開賣Android手機的不是最大運營商 
眾所周知，T-Mobile在23日，於美國紐約發佈 了Android首款手機G1。但是在北美市場，最大的兩家運營商乃AT&T和Verizon，而目前所知取得Android手機銷售權的僅有 T-Mobile和Sprint，其中T-Mobile的3G網路相對於其他三家也要遜色不少，因此，用戶可以買賬購買G1，能否體驗到最佳的3G網路服務則要另當別論了！
三、運營商仍然能夠影響到Android手機 
在國內市場，不少用戶對購得移動定制機不滿，感覺所購的手機被人塗畫了廣告一般。這樣的情況在國外市場同樣出現。Android手機的另一發售運營商Sprint就將在其機型中內置其手機商店程式。
四、同類機型用戶減少 
在不少手機論壇都會有針對某一型號的子論壇，對一款手機的使用心得交流，並分享軟體資源。而對於Android平台手機，由於廠商豐富，產品類型多樣，這樣使用同一款機型的用戶越來越少，缺少統一機型的程式強化。舉個稍顯不當的例子，現在山寨機氾濫，品種各異，就很少有專門針對某個型號山寨機的討論和群組，除了哪些功能異常搶眼、頗受追捧的機型以外。
五、過分依賴開發商缺少標準配置 
在使用PC端的Windows Xp系統的時候，都會內置微軟Windows Media Player這樣一個瀏覽器程式，用戶可以選擇更多樣的播放器，如Realplay或暴風影音等。但入手開始使用默認的程式同樣可以應付多樣的需要。在Android平台中，由於其開放性，軟體更多依賴第三方廠商，比如Android系統的SDK中就沒有內置音樂 播放器，全部依賴第三方開發，缺少了產品的統一性。

52. 什麼是ANR 如何避免它? 
答：ANR：Application NotResponding，五秒 
在Android中，活動管理器和窗口管理器這兩個系統服務負責監視應用程式的響應。當出現下列情況時，Android就會顯示ANR對話方塊了： 
對輸入事件(如按鍵、觸摸屏事件)的響應超過5秒 
意向接受器(intentReceiver)超過10秒鐘仍未執行完畢 
Android應用程式完全運行在一個獨立的線程中(例如main)。這就意味著，任何在主線程中運行的，需要消耗大量時間的操作都會引發ANR。因為此時，你的應用程式已經沒
有機會去響應輸入事件和意向廣播(Intentbroadcast)。 
因此，任何運行在主線程中的方法，都要盡可能的只做少量的工作。特別是活動生命週期中的重要方法如onCreate()和 onResume()等更應如此。潛在的比較耗時的操作，如訪
問網路和數據庫;或者是開銷很大的計算，比如改變點陣圖的大小，需要在一個單獨的子線程中完成(或者是使用異步請求，如數據庫操作)。但這並不意味著你的主線程需要進
入阻塞狀態已等待子線程結束 -- 也不需要調用Therad.wait()或者Thread.sleep()方法。取而代之的是，主線程為子線程提供一個控制碼(Handler)，讓子線程在即將結束的
時候調用它(xing:可以參看Snake的例子，這種方法與以前我們所接觸的有所不同)。使用這種方法涉及你的應用程式，能夠保證你的程式對輸入保持良好的響應，從而避免因
為輸入事件超過5秒鐘不被處理而產生的ANR。這種實踐需要應用到所有顯示用戶界面的線程，因為他們都面臨著同樣的超時問題。 

53.     什麼情況會導致Force Close ?如何避免?能否捕獲導致其的異常? 
　　答：一般像空指針啊，可以看起logcat，然後對應到程式中 來解決錯誤 

54.     Android本身的api並未聲明會拋出異常，則其在運行時有無可能拋出runtime異常，你遇到過嗎?諾有的話會導致什麼問題?如何解決? 

55.     簡要解釋一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver 
　　答：一個activity呈現了一個用戶可以操作的可視化用戶界面 
　　一個service不包含可見的用戶界面，而是在後台無限地運行 
　　可以連接到一個正在運行的服務中，連接後，可以通過服務中暴露出來的借口與其進行通信 
　　一個broadcast receiver是一個接收廣播消息並作出回應的component，broadcastreceiver沒有界面 
　　intent:content provider在接收到ContentResolver的請求時被激活。 
　　activity, service和broadcast receiver是被稱為intents的異步消息激活的。 
一個intent是一個Intent對像，它保存了消息的內容。對於activity和service來說，它指定了請求的操作名稱和待操作數據的URI 
　　Intent對象可以顯式的指定一個目標component。如果這樣的話，android會找到這個component(基於manifest文件中的聲明)並激活它。但如果一個目標不是顯式指定的，android必須找到響應intent的最佳component。 
　　它是通過將Intent對像和目標的intent filter相比較來完成這一工作的。一個component的intent filter告訴android該component能處理的intent。intent filter也是在manifest文件中聲明的。 

56.     　IntentService有何優點? 
　　答：IntentService 的好處 
　　* Acitivity的進程，當處理Intent的時候，會產生一個對應的Service 
　　* Android的進程處理器現在會盡可能的不kill掉你 
　　* 非常容易使用 

57.     橫豎屏切換時候activity的生命週期? 
　　1、不設置Activity的android:configChanges時，切屏會重新調用各個生命週期，切橫屏時會執行一次，切豎屏時會執行兩次 
　　2、設置Activity的android:configChanges="orientation"時，切屏還是會重新調用各個生命週期，切橫、豎屏時只會執行一次 
　　3、設置Activity的android:configChanges="orientation|keyboardHidden"時，切屏不會重新調用各個生命週期，只會執行onConfigurationChanged方法 
如何將SQLite數據庫(dictionary.db文件)與apk文件一起發佈? 
　　解答：可以將dictionary.db文件複製到Eclipse Android工程中的res aw目錄中。所有在res aw目錄中的文件不會被壓縮，這樣可以直接提取該目錄中的文件。可以將dictionary.db文件複製到res aw目錄中 

58.     如何將打開res aw目錄中的數據庫文件? 
　　解答：在Android中不能直接打開res aw目錄中的數據庫文件，而需要在程式第一次啟動時將該文件複製到手機記憶體或SD卡的某個目錄中，然後再打開該數據庫文件。複製的基本方法是使用getResources().openRawResource方法獲得res aw目錄中資源的 InputStream對像，然後將該InputStream對像中的數據寫入其他的目錄中相應文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法來打開任意目錄中的SQLite數據庫文件。 

59.     Android引入廣播機制的用意? 
　　答：a:從MVC的角度考慮(應用程式內) 
　其實回答這個問題的時候還可以這樣問，android為什麼要有那4大元件，現在的移動開發模型基本上也是照搬的web那一套MVC架構，只不過是改了點嫁妝而已。
android的四大元件本質上就是為了實現移動或者說嵌入式設備上的MVC架構，它們之間有時候是一種相互依存的關係，有時候又是一種補充關係，引入廣播機制可以方便幾大
元件的資訊和數據交互。 
　　b：程式間互通消息(例如在自己的應用程式內監聽系統來電) 
  　c：效率上(參考UDP的廣播協定在局域網的方便性) 
　　d：設計模式上(反轉控制的一種應用，類似監聽者模式)

60.     Android dvm的進程和Linux的進程, 應用程式的進程是否為同一個概念 
　　DVM指dalivk的虛擬機。每一個Android應用程式都在它自己的進程中運行，都擁有一個獨立的Dalvik虛擬機實例。而每一個DVM都是在Linux 中的一個進程，所以說可以認為是同一個概念。 

61.     sim卡的EF 文件有何作用 
　　sim卡的文件系統有自己規範，主要是為了和手機通訊，sim本 身可以有自己的作業系統，EF就是作存儲並和手機通訊用的 

62.     嵌入式作業系統記憶體管理有哪幾種， 各有何特性 
　　頁式，段式，段頁，用到了MMU,虛擬空間等技術 

63.      什麼是嵌入式實時作業系統, Android 作業系統屬於實時作業系統嗎? 
　　嵌入式實時作業系統是指當外界事件或數據產生時，能夠接受並以足夠快的速度予以處理，其處理的結果又能在規定的時間之內來控制生產過程或對處理系統作出快速響應，並控制所有實時任務協調一致運行的嵌入式作業系統。主要用於工業控制、 軍事設備、 航空航太等領域對系統的響應時間有苛刻的要求，這就需要使用實時系統。又可分為軟實時和硬實時兩種，而android是基於linux內核的，因此屬於軟實時。 

64.     一條最長的短資訊約佔多少byte? 
　　中文70(包括標點)，英文160，160個位元組。 

65.     android中的動畫有哪幾類，它們的特點和區別是什麼? 
　　兩種，一種是Tween動畫、還有一種是Frame動畫。Tween動畫，這種實現方式可以使視圖元件移動、放大、縮小以及產生透明度的變化;另一種Frame動畫，傳統的動畫方法，通過順序的播放排列好的圖片來實現，類似電影。 

66. handler機制的原理 
andriod提供了Handler 和 Looper 來滿足線程間的通信。Handler先進先出原則。Looper類用來管理特定線程內對像之間的消息交換(MessageExchange)。 
1)Looper: 一個線程可以產生一個Looper對像，由它來管理此線程裡的MessageQueue(消息隊列)。 
2)Handler: 你可以構造Handler對像來與Looper溝通，以便push新消息到MessageQueue裡;或者接收Looper從Message Queue取出)所送來的消息。 
3) Message Queue(消息隊列):用來存放線程放入的消息。 
4)線程：UIthread 通常就是main thread，而Android啟動程式時會替它建立一個MessageQueue。 

67.     說說mvc模式的原理，它在android中的運用 
　MVC(Model_view_contraller)」模型_視圖_控制器」。 MVC應用程式總是由這三個部分組成。Event(事件)導致Controller改變Model或View，或者同時改變兩者。只要Controller改變了Models的數據或者屬性，所有依賴的View都會自動更新。類似的，只要Contro

68.    DDMS和TraceView的區別? DDMS是一個程式執行查看器，在裡面可以看見線程和堆棧等資訊，TraceView是程式性能分析器 。

69.    java中如何引用本地語言 可以用JNI（java nativeinterface  java 本地介面）介面。

70.    談談Android的IPC（進程間通信）機制 IPC是內部進程通信的簡稱， 是共享"命名管道"的資源。Android中的IPC機制是為了讓Activity和Service之間可以隨時的進行交互，故在Android中該機制，只適用於Activity和Service之間的通信，類似於遠端方法調用，類似於C/S模式的訪問。通過定義AIDL介面文件來定義IPC介面。Servier端實現IPC介面，Client端調用IPC介面本地代理。

71.    NDK是什麼NDK是一些列工具的集合，NDK提供了一系列的工具，幫助開發者迅速的開發C/C++的動態庫，並能自動將so和java 應用打成apk包。
NDK集成了交叉編譯器，並提供了相應的mk文件和隔離cpu、平台等的差異，開發人員只需簡單的修改mk文件就可以創建出so


/******************************************************************************/
Android dpi / px / dp / 研究    from: http://jason1peng.blogspot.tw/2011/08/android-dpi-px-dp.html
/******************************************************************************/
最近工作上剛好遇到Android dpi 相關的問題, 紀錄一下研究筆記.
基本觀念:
Resolution(px): 就是我們熟知的解析度, 如1024x600.
Size(dp/dip): 在Android上實際看到的大小, 若定義100dp, 實際在各種尺寸, dpi定義正確的裝置上, 看起來的實際大小應該要差不多.
Density(dpi): Dot Per Inch, 每一英吋有幾個點.
px = dp * (dpi / 160) Android官方公式
問題: DPI設定錯誤會發生什麼事情
在開發Android Platform時必須要決定dpi的數值, 錯誤的dpi會讓程式UI比例呈現異常, 如Galaxy Tab 7". (該device設定dpi為240, 表示螢幕每一英吋應該要能夠顯示240個點, 但根據DPI Calculator, 7" 1024x600每一英吋只能顯示169個點, 所以當ui resource是用dp定義width/ length的話, 經過公式換算後, 實際看到都會被放大約1.5倍)
研究 : 今天如果我們有個裝置是7" 1280x800解析度, 那我們的dpi到底該定義多少?
若根據DPI Calculator, 該裝置每一英吋能看到215個點, 反推螢幕上能顯示的大小
寬1280 = dp * (215/160), dp約為 952dp
高  800 = dp * (215/160), dp約為 595dp
Android Developer - Configuration Example, 直接定義了各尺寸螢幕該容納的dp大小
320dp: a typical phone screen (240x320 ldpi, 320x480 mdpi, 480x800 hdpi, etc).
480dp: a tweener tablet like the Streak (480x800 mdpi).
600dp: a 7」 tablet (600x1024 mdpi).
720dp: a 10」 tablet (720x1280 mdpi, 800x1280 mdpi, etc).
若為7"裝置, 所以就用600 dp來反推dpi
高 800 = 600 * (dpi/160), dpi約為 213dp
之所以是用寬度width反推, 而不是高度height反推是因為, 在操作畫面的時候, 垂直空間不足時, 上下滑動是很直覺的操作, 但左右移動卻比較罕見, 寬度width定義大小必須要比較注意.
所以Android Developer新增了Declaring Tablet Layouts for Android 3.2, 優先考慮smallest width dp(layout-swXXXdp)
因此得知7" 1280x800的顯示空間為961dp * 600dp, 須設定為213dpi
個人結論
UI到底要用怎麼設計? 
目標裝置解析度是1280x800就畫1280x800 px的圖. 
在定義layout resource時, 要用dip/dp指定長寬, 而非px. (利用px = dp * (213/160)可推出dp)
使用Relative Layout, 而非Absolute Layout
想要支援dp較小的裝置要怎麼辦?
定義不同的layout吧, 如layout-normal.
Ref:
1. http://developer.android.com/guide/practices/screens_support.html
2. http://developer.android.com/guide/topics/resources/providing-resources.html
3. http://android-developers.blogspot.com/2011/07/new-tools-for-managing-screen-sizes.html
4. DPI Caclulator(http://members.ping.de/~sven/dpi.html)


/******************************************************************************/
Android Debug Bridge（ADB）
/******************************************************************************/
adb工具用於向模擬器或設備安裝應用程式的.apk文件和從命令行訪問模擬器或設備。
也可以用於將標準的調試器連接到運行在Android模擬器或設備上的應用程式代碼上。 他是通用的debug工具，使你管理設備或者模擬器的狀態。
ADB在運行上是一種Client-Server的模式，主要包含三個部分:
A client:  which runs on your development machine. You can invoke a client from a shell by issuing an adb command. 
           Other Android tools such as the ADT plugin and DDMS also create adb clients.
A server: which runs as a background process on your development machine. 
          The server manages communication between the client and the adb daemon running on an emulator or device.
A daemon: which runs as a background process on each emulator or device instance

當要開始一個adb client (例如一個adb command 或是 DDMS tool),  client會先去確認是否有adb server程式已經在執行,  若沒有則生成一個adb server process, 
當adb server process開始跑起來之後, 他使用TCP port 5037 並且開始監聽從adb client所發出的訊息以及命令—其中所有的adb clients都用port 5037 與adb server溝通.
server 接著開始設定與所有emulator/devices端instances之連結(也就是Server與Instance之間建立關係, client再透過Server進而操作Emulator/Device之Instance). 
Server找出Instances的方法是去掃瞄所有port範圍在5555到5585之間的單數號, 因為instances與Server溝通所使用的port就是介於這個區域. 

值得注意的是每個instance一次要求一組成對的pors:
單數號 port for console connections.
雙數號 port for adb connections. For Example

Emulator 1, console: 5554
Emulator 1, adb: 5555
Emulator 2, console: 5556
Emulator 2, adb: 5557 ... 
As shown, the emulator instance connected to adb on port 5555 is the same as the instance whose console listens on port 5554.

Once the server has set up connections to all emulator instances, you can use adb commands to control and access those instances. Because the server manages connections to emulator/device instances and handles commands from multiple adb clients, you can control any emulator/device instance from any client



/******************************************************************************/
[Android 教學] 什麼是 Android 智慧型手機 ？     
/******************************************************************************/
from : http://blog.chinatimes.com/tomsun/archive/2010/08/30/533364.html

/******************************************************************************/
[Android 教學] Android 的系統架構說明課程講義 
/******************************************************************************/
from : http://blog.chinatimes.com/tomsun/archive/2010/08/31/533666.html

什麼是 Android 應用程式框架 (Application framework)？
Android 為了節省開發者撰寫應用程式的時間、加速應用程式開發的速度。所以在應用程式與內部系統環境之間設置了一個讓程式更簡易溝通的界面，它稱之為應用程式框架
(Application framework)。
對於應用程式的開發者來說，他得以透過Java程式呼叫應用程式框架所提供的應用程式界面(Application Programming Interface, API)，來實作更底層的函式庫(Libraries)
功能。
在這個應用程式框架之中，包含了
活動管理者(Activity Manager)、
視窗管理者(Window Manager)、
內容提供者(Content Providers)、
外觀元件系統(View System)、
程式管理者(Package Manager)、
電話功能管理者(Telephony Manager)、
資源管理者(Resource Manager)、
地理位置管理者(Location Manager)以及
訊息管理者(Notification Manager)等服務或者系統。
總體來說，開發者通常只需要理解應用程式與應用程式框架之間的運作關係、以及如何透過Java程式語言實作的方法即可，並不太需要探究更內部的系統環境。

什麼是 Dalvik 虛擬機器 (Dalvik virtual machine)？
早期應用程式的原始程式碼，多半被組譯器或編譯器轉換成執行檔之後，便可以立即在作業系統當中執行。
不過，這種方式常常會受限於作業系統環境的不同，而無法相容執行。
比如副檔名為.exe或.com的應用程式執行檔就只能在Microsoft Windows或者DOS作業系統當中執行。倘若，它要在Mac OS當中執行者，還需要將程式碼重新改寫並變成Mac OS
可執行的檔案夾格式 .app，才得以在Mac OS作業系統當中執行。
隨後，Java的誕生為此帶來了觀念上的革新。當應用程式開發者在編寫Java原始程式碼後，會先透過Java程式語言的編譯器(Compiler)編譯成二進位碼形式(bytecode)的
.class類別檔。這個類別檔並非是在作業系統當中"直接"執行，而是會在具有Java虛擬機器(Java virtual machine, JVM)的作業系統環境當中被"轉換"執行。
所以，無論是那種款式的作業系統，只要安裝含有Java虛擬機器(Java virtual machine, JVM)的Java平台(Java Platform)，就可以執行以Java程式語言所開發的應用程式。
因為，Android也是採行Java程式語言進行應用程式的開發，所以，它在觀念與架構上皆與Java平台相去不遠。
然而，Android並非使用Java虛擬機器(Java virtual machine, JVM)，而是自行發展的Dalvik虛擬機器(Dalvik virtual machine, Dalvik VM)，所以它的檔案產生過程仍與
Java應用程式檔案有所不同。為讓大家更暸解這方面的內容，本講義做以下之說明：
Andorid應用程式開發者在運用Java程式語言編寫完原始程式碼後，其儲存的檔案副檔名為 .java，.java檔案接著會被Java程式語言編譯器(Compiler)編譯成副檔名為 .class
的檔案(其為二進位碼形式(bytecode))。
如果是一般的Java應用程式，大概到這一步就可以直接透過Java虛擬機器(Java virtual machine, JVM)在作業系統之中執行。只不過，因為在Android系統之中並不是使用JVM
，而是Dalvik虛擬機器(Dalvik virtual machine, Dalvik VM)。所以，副檔名.class的檔案還要再被Android SDK(軟體開發工具包)當中的dx工具再轉換成為Dalvik VM可以執
行的檔案(副檔名為 .dex, Dalvik Executable，同為二進位碼形式)。

                        編譯                    轉換                    壓縮封裝
        *.java          -->     *.class         -->     *.dex           -->     *.apk
        Java程式碼檔案          Java類別檔              Dalvik可執行檔          Android應用程式封裝檔


什麼是 Webkit 網頁引擎 (Web browser engine)？
在Andorid當中，如同於個人電腦般也內建網頁瀏覽器(Web Browser)。此瀏覽器的名稱叫做Google Chrome Lite。它與iOS當中內建的Safari網頁瀏覽器一樣是採用Webkit網頁
引擎(Web browser engine)。如果您有在個人電腦中使用過它的孿生兄弟Google 瀏覽器(Google Chrome)的話，就可體驗Webkit網頁引擎在載入網頁的良好效能。
看到這裡，您一定會有個疑問：『網頁瀏覽器跟網頁引擎究竟是什麼關係呢？』
簡單地說，如同汽車需要引擎來產生動力一般，網頁瀏覽器裡頭有一個肩負網頁載入、HTML相關程式碼解釋、畫面排版與呈現的重要軟體元件，那個軟體元件就是網頁引擎。
早期的瀏覽器並不太強調它是使用什麼樣的網頁引擎，不過，隨著使用者對於網頁載入效能與呈現美感要求日增，越來越多的瀏覽器業者便開始強調它們所使用的網頁引擎是
那一款式。
其中，Webkit是目前最多知名智慧型手機作業系統採用的網頁引擎。這些作業系統包括了Symbian OS、iOS、Android與Palm webOS等…。
對於大多只有3吋左右螢幕的智慧型手機來說，Webkit網頁引擎有一個相當大的優勢，那就是它可以讓正常網頁(非手機版本)如同在個人電腦般，自動調整成頁寬
(auto fit page)的方式完整縮小呈現在手機的小螢幕中，如此可以方便使用者立即在手機上看到正常網頁的全觀(如下圖所示)，如果要近看某區塊之內容時，只要將該區塊放
大即可。這是其它舊式網頁引擎不容易做到的事，但應用Webkit網頁引擎卻可輕易達成。
由於，Android API 已內含Webkit相關的函式庫。因此，開發者得以透過呼叫API的方式將Webkit相關功能整合至應用程式之中。你可能會問：『什麼狀況之下，應用程式需要
用到Webkit的相關功能呢？』比如，應用程式需要內嵌顯示網頁內容或者需要執行Java Script用戶端網頁程式碼等狀況時，皆可運用Webkit函式庫來進行整合的動作。

什麼是 OpenGL ES？
Android的圖形處理分成兩個部份，一為2D圖形處理，這部份是採Android自行規範定義的2D圖形處理函式庫(2D graphics library)。
二為3D圖形處理，此部份則採行OpenGL ES 3D圖形處理函式庫。
關於2D圖形處理方面，Android應用程式開發者得以透過呼叫API的方式進行2D圖形處理函式庫相關的圖形繪製以及動畫處理。
更簡單地說，比如你想在手機上開發一個類似大頭貼機器的應用程式，亦即當使用者透過手機上的相機拍下照片後，得以在照片上加上一些相框圖案。此時該應用程式就可以
使用2D圖形繪製的功能。又比如這個大頭貼機器的應用程式想為照片加點淡出淡入的動畫效果時，則會使用到動畫處理的功能。
至於3D圖形處理方面，Android並非使用自行發展的函式庫，而是採用OpenGL ES 3D圖形處理函式庫。因為，這個函式庫在3D圖形處理上有相當優異的表現，因此，像是
SONY PlayStation 3(PS3)電視遊戲主機也是採用OpenGL ES做為它們在3D遊戲的圖形處理函式庫。
另外，由於OpenGL ES是由OpenGL輕量化而來，所以，特別適合硬體規格不如個人電腦高的智慧型手機應用。目前，除了Android之外，還有Symbian OS、BlackBerry OS、
Palm webOS、iOS亦採用OpenGL ES做為3D圖形處理的函式庫。
對於Android應用程式開發者來說，能夠運用OpenGL ES 3D圖形處理函式庫來處理相關3D立體圖形相關的應用程式或遊戲開發工作。若有興趣暸解OpenGL ES在Android上的3D表
現實況，您可以進一步觀賞Android 3D Live Wallpaper: Particle Storm短片。
 
什麼是 SQLite 資料庫？
開發者在開發應用程式的過程之中，難免會有資料儲存的需求，比如需要儲存應用程式的設定資料或者上一次遊戲關卡的資料等…。因此，Android內建了一個名為SQLite的關
聯式資料庫引擎(Relational database engine)。
因為，應用程式當中使用了SQLite，所以，手機用戶得以將相關資料儲存在手機的儲存設備當中，而無需再以網路連線的方式存取遠端的資料庫。
如果你有過大型關聯式資料庫的開發經驗(如Microsoft SQL Server或者Oracel Database等…)，應該可以很快地適應SQLite的程式編寫。因為它仍延襲SQL-92標準，亦即你可
以使用SQL(Structured Query Language，結構化查詢語言)來存取SQLite資料庫當中的資料。
另外，過去大型關聯式資料庫多數採取主從架構(Client–server model)的模式，所以，應用程式與資料庫之間具有主從的結構關係。當應用程式用戶端需要存取資料庫時，
必需連線至此資料庫的伺服器當中進行資料的新增、刪除或修改之動作。
然而不同的是，Android應用程式的開發者則採呼叫API的方式來與SQLite作溝通。同時，SQLite當中的資料庫是以單一檔案的方式儲存在手機硬體當中。
由於，SQLite具有檔案小、速度快的優點，所以目前也廣泛用於其它智慧型手機的作業系統，比如iOS、Symbian OS或者BlackBerry OS等…。

Android 支援那些媒體格式檔案？
Android支援相當多元的媒體檔案格式，本講義整理節錄自Android Developers官網詳細列表如下：
聲音檔：3GPP (.3gp) 、MPEG-4 (.mp4, .m4a)、MP3 (.mp3)、Type 0 and 1 (.mid, .xmf, .mxmf)、RTTTL/RTX (.rtttl, .rtx)、OTA (.ota)、iMelody (.imy)、
        Ogg (.ogg)、WAVE (.wav)。
圖像檔：JPEG (.jpg)、GIF (.gif)、PNG (.png)、BMP (.bmp)。
影音檔：3GPP (.3gp)、MPEG-4 (.mp4)。
對於應用程式開發者而言，他可以在應用程式之中整合聲音、圖像或影音的播放與錄製功能，提高應用程式的聲光效果，並且強化其在多媒體視聽娛樂之上的趣味性。

什麼是 GSM 手機電話功能 (GSM Telephony)？
在2G的行動通訊系統之中，多半區分為GSM與CDMA。
過去，美國的行動通訊系統大多是採CDMA規格，但像在歐洲或者台灣則以GSM規格為主。
因為，GSM在功能上有些異於CDMA之處(例如傳送手機簡訊的PDU格式)，所以，Android為了能廣為各種行動通訊系統所使用，特別在系統上也同時支援GSM手機電話的特殊規格
。(註：Android手機不只能支援目前常使用的3G行動通訊系統，也能被2G、2.5G、3.5G或者4G行動通訊系統所使用。這些規格取決於手機製造業者與電信門號業者)
就總體的手機電話功能(Telephony)來說，Android的應用程式開發者可以發揮創意與巧思，發展與通話、來電顯示、來電鈴聲、來電圖示以及手機簡訊等相關的應用程式。

Android 支援那些感應器(Sensor)？
Andorid應用程式開發者所能發揮的空間，除了取決於作業系統的版本之外，也指涉了手機硬體上的週邊設備。亦即，開發者能夠應用智慧型手機上的數位相機鏡頭(手機照相
機)、衛星定位裝置、電子羅盤(方向感應器)與重力感應器等週邊設備，去創造更多深具創新價值的應用程式。
比如永慶房屋的手機宅速配 For Android應用程式，它即應用了Android手機當中的衛星定位裝置與電子羅盤(方向感應器)進行房屋仲介方面的相關功能開發。
關於手機感應器的部份，除了重力感應器、電子羅盤(方向感應器)之外，Android還支援磁場感應器、溫度感應器、光線感應器、壓力感應器、陀螺儀與距離感應器等…。雖然
，Andorid支援那麼多種感應器，但並非每台手機都具有這些設備。因此開發者在開發應用程式時，仍應考量感應器的普及程度。就目前來說，市面上的Andorid手機具備重力
感應器、電子羅盤(方向感應器)為大宗。 

什麼是 Android SDK？
Google為了讓更多開發者參與Android應用程式的開發行列，因此，它開放給大眾免費下載安裝Android 軟體開發工具包(software development kit, SDK)。而且，這個工具
包可以安裝在Windows、Linux以及Mac等不同的作業系統環境當中。 
Android SDK除了提供了完整的Android API之外，更包括了Android應用程式除錯工具(Android Debug Bridge, ADB)以及Android 手機模擬器(Android Emulator，此為在個人
電腦上模擬Android手機的環境)。如此免費與開放是Android之所以在近來深受手機應用程式開發者喜愛的主因之一。
除了Android SDK之外，其它配合它的軟體也是免費性質。這些軟體包括了Eclipse整合開發環境(Integrated Development Environment, IDE)以及Eclipse專用之Android開發
工具外掛(ADT Plugin for Eclipse)。再加上原本就免費開放下載的Java開發工具包(Java Development Kit, JDK)。
開發者幾乎不用花費到一毛錢，便可以自己建構一個很完整且便利的Android應用程式開發環境，並專心構思與發展屬於自己的應用程式。不過，如果開發者要上傳應用程式到
Android Market網站供大家免費下載或收費販售時，則需要再付25美元的帳號註冊費。
至於，Google在近日所推出的 App Inventor 線上開發工具，則為Android應用程式開發者創造出了更方便、更直覺與無程式碼的圖形化開發環境。
我們在試用過App Inventor 後，發現它相當適合Android應用程式的雛型發想階段，開發者可以先運用它來構思一些應用程式的功能。但是，由於它在操作上力求簡單化，由
此也可能產生缺乏開發彈性的問題，加上目前它並不支援中文字元，所以開發者若要發展Android應用程式，本講義仍建議大家以上述的開發環境為主，App Inventor 則可做
為Android應用程式開發之前的雛型(prototyping)系統設計工具。
最後，Android官方建構了一個專門提供給Android應用程式開發者閱讀的網站－Android Developers，它提供了相當詳盡且時常更新的Android應用程式開發之英文資料。想要
自修Android應用程式開發的朋友，本講義非常建議大家常去閱讀這個網站。 


/******************************************************************************/
android 程式執行流程
/******************************************************************************/
程式正常啟動：onCreate()->onStart()->onResume(); 
正常退出：onPause()->onStop()->onDestory() 
一個Activity啟動另一個Activity: onPause()->onStop(), 再返回：onRestart()->onStart()->onResume() 
程式按back 退出： onPause()->onStop()->onDestory(),再進入：onCreate()->onStart()->onResume(); 
程式按home 退出： onPause()->onStop(),再進入：onRestart()->onStart()->onResume();


/******************************************************************************/
[Android 教學] Android 的商業模式解說課程講義 (含 Android Market 與 Admob 行動廣告介紹)
/******************************************************************************/
from : http://blog.chinatimes.com/tomsun/archive/2010/09/02/534485.html
以下為本篇 Android 教學講義的開始。

此篇課程講義目的，是想讓Android程式開發者暸解Android商業模式為何？本課程講義會從硬體開發角度，看 Android 在嵌入式系統的商業機會。以及從軟體開發角度，看
Android手機應用程式開發者如何應用收費下載或者手機應用程式廣告機制來獲取商業利潤。以下四點為此篇講義的主軸：
什麼是 嵌入式系統 ？ 
什麼是 Android NDK ？
什麼是 Android Market ？ 
什麼是 Android 手機應用程式廣告？
如果您是初次閱讀本講義教材者，為求學習之完整性，因此煩請您先從本講義之第一講與第二講開始閱讀，謝謝！

什麼是嵌入式系統？
【孫傳雄研究室 編著】由於，台灣與中國大陸的資訊產業結構仍以硬體製造業為主。因此，Android在此區域的商業應用當然還是以嵌入式系統硬體之移植為大宗。 
不過，不少人聽到嵌入式系統，一定是一頭霧水，不知其為何物。因此，本講義先就嵌入式系統進行以下之說明：
何謂嵌入式系統呢？引述維基百科說明如下：
嵌入式系統(Embedded system)，是一種「完全嵌入受控器件內部，為特定應用而設計的專用電腦系統」，根據英國電器工程師協會
（ U.K. Institution of Electrical Engineer）的定義，嵌入式系統為控制、監視或輔助設備、機器或用於工廠運作的裝置。
與個人電腦這樣的通用電腦系統不同，嵌入式系統通常執行的是帶有特定要求的預先定義的任務。由於嵌入式系統只針對一項特殊的任務，設計人員能夠對它進行最佳化，減
小尺寸降低成本。由於嵌入式系統通常進行大量生產。所以單個的成本節約，能夠隨著產量進行成百上千的放大。(資料來源：維基百科)
更簡單地說，舉凡您隨身攜帶的智慧型手機、小孩在家中玩的電玩遊戲機、去銀行領錢使用的自動櫃員機、到捷運或高鐵買車票的自動售票機與閘門感應器、甚至到便利超商
影印文件的影印機設定裝置。它們都是嵌入式系統的產品應用。
而這些嵌入式系統大多數和個人電腦一樣，裡頭安裝有作業系統軟體。只不過，它們需要的是精簡化、客製化且效能最佳化的作業系統。所以個人電腦所安裝的作業系統並不
適用於嵌入式系統當中。
亦因如此，不少的作業系統業者皆有推出以嵌入式系統需求為主的嵌入式作業系統(Embedded operating system)。這裡頭還區分成個人數位處理器專用、智慧型手機專用、數
位媒體播放器專用、工業機器人專用、路由器專用以及通用型的嵌入式作業系統。(資料來源：維基百科)
其中，免費、開放原始碼且適用範圍廣泛的Android，是近來最熱門的嵌入式作業系統之一。

什麼是 Android NDK ？
不過，真正觸發這股將Android大量移植(Porting)至嵌入式系統的主因，並非完全是Android的開放原始碼與免費策略，而是2009年6月25日Android官方釋出了Android原生開
發工具包(Android Native Development Kit, NDK) 。 
在還沒有Android NDK之前，嵌入式系統開發者僅能在自家的硬體上，安裝Android官方所提供的作業系統版本。或是透過Android SDK軟體開發工具包的那些API來發展嵌入式
系統相關的應用程式。如果，想要再往系統底層創造屬於自己的原生函式庫(Native libraries)的話，除了不容易之外，也不合乎Android先前的規定。
此點對於嵌入式系統業者來說，是一件極為困擾之事。
畢竟，嵌入式系統的形態多元，既便Android可以被安裝在不同的硬體規格之上。但是，倘若開發者無法針對特定的嵌入式系統需求進行Android的客製化動作時，Android在嵌
入式系統之中所能發揮的效益絕對會受到影響。
但，有了Android NDK所提供的一系列開發工具之後，一切皆變得有希望了。
因為，使用Android NDK的嵌入式系統開發者能夠順利地穿越應用程式框架以及Dalvik VM所立下的藩籬，自行以C/C++程式語言來發展更底層的原生函式庫。
並且，開發者可以在應用程式當中，透過Java原生介面(Java Native Interface, JNI)合法地呼叫使用這些自行發展的原生函式庫。更重要的是，開發者可以將開發好的原生
函數庫及應用程式，一併封裝包埵.apk應用程式封裝檔案，並佈署於嵌入式系統硬體設備當中。(資料來源：Android Developers 官網)
因此，您最近在市面上應該會看到不少客製化過的Android相關嵌入式系統產品。例如智慧型手機、電子書閱讀器、汽車衛星導航器、數位媒體播放器、以及輕省筆電等…。甚
至，包括近日Google所推出的Google TV網路電視平台，也是以客製化過後的Android作業系統做為基礎。

什麼是 Android Market ？
當然，就個人或中小企業來說，並非有那麼大的資金與人力自行發展Android相關嵌入式系統產品。但，仍有可能透過Android手機應用程式的開發，獲取相對的商業收益。 
關於此部份，應該從Apple iPhone結合旗下的線上應用程式商店服務App Store後，它所開創的手機應用程式之新商業模式談起。
因為，iPhone讓用戶得以透過手機上網的方式，便能直接免費或者小額付費地下載安裝App Store當中超過20萬種的iPhone應用程式。此種簡易的方式，有效地提昇了手機用戶
安裝應用程式的使用門檻，也刺激了手機用戶付費安裝應用程式的意願。
另一方面，對於iPhone應用程式的開發者來說，他們只需支付年費99元美金的iPhone SDK 軟體開發工具包費用(此為標準版方案)給Apple公司，便可運用iPhone SDK軟體開發
工具包開發iPhone應用程式並在App Store上架發行。而且，每當使用者付費購買應用程式時，Apple會與該應用程式的軟體開發者三七拆帳，即應用程式開發者可得70%的銷售
收入。
此種方式大幅地降低了應用程式開發者銷售應用程式的門檻，因此，國內外有越來越多的個人或者SOHO族加入了iPhoe應用程式的開發行列。(註：若要不公開在App Store上架
銷售，採獨立發行應用程式者，則需加入年費299元美金的企業版方案(Enterprise Program))
iPhone的App Store商業模式之成功，似乎讓Google倍感壓力。因此，Google就在2008年10月22日正式推出Android應用程式商店服務Android Market。與iPhone應用程式不同
的是，Android的開發工具是完全免費的，因此，若你只是想嘗試開發Android應用程式，也可以直接免費下載安裝Android SDK軟體開發工具包使用。
然而，如果你是要上架至Android Market發行，則需支付帳號註冊費25元美金給Google公司，這個費用不是年費，只需支付一次便可以永久使用該帳號。另外，在銷售付費應
用程式的拆帳模式上，Android Market與App Store一樣為三七拆帳，即應用程式開發者可得70%的銷售收入。
不過，目前令人遺憾的是，Google Android Market並尚未開放台灣以及中國大陸地區的手機用戶線上購買Android付費應用程式，亦即此區域的手機用戶在
Google Android Market之中只能下載安裝Android免費應用程式(相關付費與免費之區域，請詳見此連結)。
這也是目前Android華文應用程式不多的主因之一，然而，據Taiwan News於2010年7月28日指出：『Google Android Market 最快2010年底前在台灣、香港能夠同步上線。』我
們相信開放上線之後，會帶動更多個人、SOHO族以及企業投入Android華文應用程式開發的行列。
另一方面來說，由於Android支援多國語系的應用程式設計，因此，在商業銷售的前提假設之下，開發者所鎖定的目標顧客群與市場應可更加地國際化，而不要僅限定於華文地
區的手機用戶。然而，在此特別要提醒讀者的是，應用程式的國際化，除了界面文字的多國語系設計外，更要考量不同國別使用者的需求與使用者行為。 

什麼是 Android 手機應用程式廣告？
此外，開發者除了透過應用程式付費下載的模式賺取收入之外，亦能在應用程式當中放置廣告做為收入的來源之一。 
由於，Google在2010年5月27日併購了重量級行動廣告業者Admob。因此，它目前已成為行動廣告產業的龍頭。據聯合新聞網於2010年5月26日表示：『行動廣告市場的規模預計
到2014年時，會飆升到目前的八倍，總額達17.8億美元。Google把AdMob納入旗下後，可望吸引更多廣告商與軟體開發公司擁抱Google與Android作業系統，以便在這個飛躍成
長的市場上分一杯羹。』
目前，包括Google既有的AdSense for Mobile Apps或者剛併購的Admob，它們皆支援放置廣告於Android或iPhone應用程式當中。
然而，由於AdSense for Mobile Apps在亞太地區尚未開放。因此，台灣或中國大陸地區的開發者多半是使用Admob所提供的行動廣告服務。
關於廣告收入的部份，Admob採行每次點擊成本 (CPC)與每千次展示成本 (CPM)兩種模式，詳細的計費方式可詳見此連結。
至於，Apple在2010年併購Quattro Wireless行動廣告業者後(Quattro Wireless被購併後將關閉)，所推出的iAd行動廣告服務。因為，目前iAd只支援放置廣告於iPhone應用程
式之中，因此，並不適用於Android手機應用程式的開發者。


/******************************************************************************/
[Android 教學] Android SDK 下載安裝中文教學課程講義
/******************************************************************************/
from : http://blog.chinatimes.com/tomsun/archive/2010/09/07/536320.html
以下為本篇 Android 教學講義的開始。

我們的 Android 教學課程講義前三講，主要是讓大家能夠暸解Android的定義、架構、原理以及軟硬體業者的商業機會。

而此篇Android課程講義，我們將帶領各位從零開始，一步一步地學習如何安裝Android手機應用程式的相關開發套件。此篇講義之內容主軸有以下六點：

什麼是 Android 系統程式開發？
什麼是 Android 手機應用程式開發？
如何下載安裝 JDK ？
如何下載執行 Eclipse IDE ？
如何下載安裝 ADT Plugin for Eclipse ？
如何下載安裝 Android SDK ？
本講義為求讀者學習的完整性。倘若您尚未閱讀過Android 手機程式開發教學課程免費講義的第一講、第二講與第三講，煩請您先連結閱讀前三講後，再來閱讀第四講。
【孫傳雄 研究室編著】在正式進入Android手機應用程式相關開發套件的安裝教學課程前，本講義為了讓大家更清楚地暸解Android在程式開發上的兩條重要路徑之差異，因此
，我們以下先就這個部份進行深入說明。本講義企盼藉此能讓Android手機應用程式開發者在開發前有一清晰的開發認知與暸解。
其實，假若我們回顧在第二講當中的Android系統架構圖，便可以很清晰地看見Android在程式開發上的分野：其主要分成系統程式開發與應用程式開發兩類 (如下圖所示)。

什麼是 Android 系統程式開發？
Android的系統程式指的是Android作業系統本身，它猶如您在個人電腦當中使用的Windows XP或者Windows 7一樣，掌管了整個Android內部的系統運作。
然而，Android作業系統與Windows XP或者Windows 7不同處在於：它已將原始碼完全免費開放給大眾下載。
所以，所有的嵌入式系統硬體業者（包括智慧型手機業者在內），不只可以免費地將Android作業系統安裝在自家的硬體之上，還可以應用本講義第三講所談到的Android NDK
原生開發工具包，穿越Android應用程式框架與Dalvik VM所設下的藩籬，直入Android系統的底層去開發一些符合自家硬體需求的原生函式庫並搭載於這些嵌入式系統硬體之中
，此即為Android系統程式開發。
關於Android系統程式開發，大致上可以包括Android作業系統效能的最佳化、3D或2D圖形處理效能的改善、系統功能與界面的客製化或者硬體設備驅動程式的撰寫等…。
不過，由於Android的系統程式開發者不只要暸解Java程式語言、還必需暸解更底層的 C/C++程式語言、Linux核心程式碼、以及開放式原始碼的相關版權規定事宜。因此，在
技術層次上較為繁複與困難，有較高的學習門檻。
是然，倘若您過去已有Embedded Linux (Linux作業系統的嵌入式版本)之相關係統程式開發經驗的話，在Android系統程式開發的學習上應可較快上手。

什麼是 Android 手機應用程式開發？
另一方面，Android應用程式則指的是建構在Android應用程式框架之上，協助使用者特定需求的軟體程式。它猶如您在個人電腦上所使用的Word文書處理軟體、Excel試算表軟
體或者Photoshop影像處理軟體一樣，肩負了各自不同的使用者需求。
由於，Android作業系統多半用於智慧型手機為主的嵌入式系統硬體之中，因此，Android應用程式開發也以手機使用者為首要的目標族群。
也因為這樣子，所以多數人會將Android應用程式開發直接稱之為Android手機應用程式開發。但，Android應用程式開發能應用的範圍，其實廣納於所有搭載著Android作業系
統的嵌入式系統硬體之中。
當然，本講義為凝聚學習之焦點，因此，在此不談及其它嵌入式系統的Android應用程式開發，而是以Android手機應用程式開發為講義內容之主軸。
有別於Android系統程式開發者在程式能力上的高度要求，Android手機應用程式開發者在技術層次的要求相對較低，僅需對於Android API以及Java程式語言能夠熟稔即可。
不過，相對於開發者個人來說，Android手機應用程式的開發團隊則必需要廣納創意發想、人機介面設計與程式語言三方面的人才，而非只有技術層級的開發者而已。
尤以，我們在第三講中也暸解到，Android手機應用程式的獲益模式，除了在Android Market網路市集中收費販售外，仰賴的就是行動廣告。
所以，身為一個Android手機應用程式開發團隊，除了盡責任地把應用程式開發好之外，更需要扮演如同媒體經營者的角色，在開發前仔細分析使用者的需求，期許開發出手機
用戶能在日常生活之中必備且常用的應用程式，如此才能提高應用程式的曝光度以及行動廣告的點擊次數，進而增加Android手機應用程式的開發收益。
另外，因為目前市面上的Android智慧型手機產品當中，普遍具備有觸控螢幕、數位相機鏡頭、衛星定位裝置、重力感應器以及電子羅盤(方向感應器)等週邊硬體設備。因此，
Android手機應用程式開發團隊可以思維如何將這些週邊硬體設備，有創意地整合至Android手機應用程式當中。藉以吸引更多的手機用戶下載使用。
在此還要強調的是，Android系統程式開發與Android手機應用程式開發兩者有時也會有交會之時刻，而非完全是二分法的形態。比如，手機遊戲程式開發者為了加速圖形處理
的效能，常常需要藉由系統程式開發者的協助才能達成。

Android SDK相關開發套件的安裝需求與流程
以上，我們不厭其煩地將Android系統程式開發與Android手機應用程式開發之分野，為大家做更深入之說明。本講義接下來便要開始針對於如何下載安裝 Android SDK、
Eclipse IDE、ADT Plugin for Eclipse以及Sun JDK ？進行說明。

首先，我們先引述Android Developers官網上所述，Android SDK相關開發套件支援的作業系統如下：
Windows XP (32位元) 或 Vista (32或64位元)
Mac OS X 10.5.8 或更新的版本 (只能在 x86 硬體上執行)
Linux (已在Linux Ubuntu Hardy Heron測試過) 
在此要注意的是，雖然Android SDK相關開發套件也能在64位元的作業系統上執行，不過，前提是該作業系統必需可以執行32位元的應用程式。 
此外，本講義已先針對Windows 7作業系統做過測試，Android SDK相關開發套件亦能在Windows 7作業系統之中正常運作。 

關於您需要安裝的相關開發套件，需包括以下四項： 
Java開發工具包(Java Development Kit, JDK)
Android 軟體開發工具包(software development kit, SDK)
Eclipse整合開發環境(Integrated Development Environment, IDE)
Eclipse專用之Android開發工具外掛(ADT Plugin for Eclipse)
至於，安裝上述開發套件的流程順序，本講義之建議如下圖所示：
        Download & Install JDK                          -->     
        Download & Run Eclipse IDE                      -->     
        Download & Install ADT  Plugin in Eclipse       -->
        Download & Install Android SDK
接下來，本講義便開始按此流程圖之順序，以逐步詳解的方式教大家如何安裝Android SDK相關開發套件。另外，在此要強調的是，因為本講義是以大家常用之Windows作業系
統為操作講解的環境，因此，有些部份可能會與在Linux或Mac OS X作業系統當中有所差異。
如何下載安裝 JDK ？
Java開發工具包(Java Development Kit, JDK) 主要包括了JRE（Java Runtime Environment，Java執行環境）javac 編譯器、jar封裝工具、javadoc文件生成器以及jdb除錯
程式等工具(資料來源：維基百科)。它是開發Java相關應用程式之必備軟體。
由於，Android手機應用程式的開發也是採用Java程式語言，因此，如果您的作業系統之中沒有JDK的話，則必需趕緊安裝JDK。
至於，如何確定您的作業系統之中，是否有安裝JDK呢？
本講義建議您一個小技巧：因為，JDK會預設安裝於電腦C:\Program Files\Java之中，只要您當初沒有自訂安裝至別處，無論新舊版本的JDK都會儲存在此處。所以，您可以至
此路徑之中查看是否有個檔案夾名稱為jdk1.6或jdk1.5開頭(如下圖紅框處所示)。

另外，由於執行Android SDK 必需先安裝JDK 5或JDK 6版本，因此，假若目前此檔案夾不是jdk1.6或jdk1.5開頭，則代表您的版本比較舊了，仍需重新安裝最新版本JDK 6。
當然，如果尚未安裝JDK 5或者JDK 6的朋友，一樣需照下列步驟進行最新版本JDK 6的安裝。

如何下載執行 Eclipse IDE ？
如果，您過去曾有過Java SE(舊稱J2SE)或者Java EE(舊稱J2EE)相關應用程式開發經驗的話，應該對Eclipse IDE並不陌生。
因為，早期它就支援Java程式語言的應用程式開發工作，後來更支援PHP、C++或者Python等程式語言的應用程式開發工作。(資料來源：維基百科)
雖然，Eclipse被稱為整合開發環境(Integrated Development Environment, IDE)，不過，其實用更簡單的用語來說，它就是一個具有圖形化界面的程式碼編輯開發平台。
您可以在Eclipse編寫程式碼、也可以用它來進行專案的儲存、測試、除錯、甚至封裝成執行檔的工作。
Eclipse的功能有點類似Microsoft Visual Studio，然而，差異之處在於Eclipse僅僅是開發平台，想要藉由它開發某種程式語言時，還必需要安裝該程式語言旳相關外掛程式。
由於，Android手機應用程式是以Java為開發程式語言，因此，在Android Developers官方網頁中，也是建議安裝Eclipse IDE做為Android手機應用程式的開發平台。
(註：當然，您也可以使用其它支援Android手機應用程式開發的開發平台)
因為，Eclipse可以免安裝直接執行，所以，您只需要按下列步驟下載Eclipse壓縮檔案並解壓縮執行即可。
首先，您需要下載Eclipse壓縮檔案，請您上網至 http://www.eclipse.org/。
若要執行Eclipse的話，您並不需用安裝任何的程式檔案，只要直接點擊該資料夾當中的」eclipse應用程式」並按下」執行」按鈕，即可開啟Eclipse IDE

如何下載安裝 ADT Plugin for Eclipse ？
ADT Plugin for Eclipse的主要目的是做為Andorid SDK整合至Eclipse當中的一個重要外掛套件。我們先前有講過，Eclipse只是一個開發平台，要在此平台中編寫任何一種程
式語言，必需仰賴於各式的外掛套件。所以ADT Plugin for Eclipse便是做為Android SDK在Eclipse之中的那個橋樑角色。
當然，Android的所有核心開發元件仍舊包括於Android SDK當中。相對地，ADT Plugin for Eclipse則是提供開發者在Eclipse之中專屬的界面工具，讓他們能夠很輕易地在
Eclipse建立Andorid手機應用程式專案，並且在Eclipse與Android SDK基礎上進行專案的編輯、儲存、測試、除錯、甚至封裝成執行檔的工作。

至於，如何下載安裝ADT Plugin for Eclipse呢？    ref: http://blog.chinatimes.com/tomsun/archive/2010/09/07/536320.html
直接點擊該資料夾當中的」eclipse應用程式」並按下」執行」按鈕，以便開啟Eclipse IDE
當您剛開啟Eclise時，它需要您指定一個新專案的工作目錄資料夾。
由於，我們只是要下載安裝ADT Plugin for Eclipse，所以，請您使用預設之資料夾路徑並按下」OK」按鈕即可
當出現Eclipse主畫面後，請您直接點選」Help」下拉式選單當中的」Install New Software」選項
當出現」Install」對話視窗時，請在」Work with」文字框中，鍵入 https://dl-ssl.google.com/android/eclipse/ 網址(如下圖紅框1處所示)，並按下」Add…」按鈕
當出現」Add Repository」對話視窗時，請您在」Name:」對話視窗中，輸入一個英文代號名稱。因為，這個名稱只是說明這個網址為何？所以，您可以自由輸入一個英文代號名稱(如下圖紅框1處所示)。
輸入後，請您按下」OK」按鈕
之後，在」Install」對話視窗之中，您會看到」ADT Plugin for Eclipse相關工具列表」，請您按下」Select All」 按鈕，以便選取所有ADT Plugin for Eclipse的相關工具

如何下載安裝 Android SDK ？
關於安裝步驟的部份，首先，您需要下載Android SDK 壓縮檔案，請您上網至 http://developer.android.com/sdk/index.html。
在這個Android SDK下載網頁當中，提供了Windows、Mac OS X (Intel)以及Linux(i386)等三種不同的作業系統版本，請您直接在此點選屬於您的作業系統版本之」Android SDK壓縮檔案連結」
Android SDK壓縮檔案解壓縮後，會產生一個名為」android-sdk-r06-windows」的資料夾。(註：r06為版本代號，日後若有新版的Android SDK提供下載時，則此代號會有更動。另外，windows則為作業系統版本名稱。)
當您點擊打開」android-sdk-windwos」資料夾後，您會看到Android SDK當中的安裝程式檔案與資料夾。但，這並非是全部Android SDK的檔案，為確保Android SDK相關套件為最完整且最新的版本，我們還需要進行下載安裝Android SDK相關套件的動作。

請您點擊該資料夾之中的」SDK Setup應用程式」，以便開始下載安裝Android SDK相關套件


/******************************************************************************/
android The project target (Android 2.3.3) was not properly loaded
/******************************************************************************/
標籤：android GraphicalLayout properly loaded target 看不見
在開發android的UI 界面時總是遇到
android The project target (Android 2.3.3) was not properly loaded
這是你在更新sdk時沒有刪除老的版本 ，
兩種方法：第一種是再SDK目錄刪除temp目錄這個文件夾，
          第二種是，如果SDK目錄下沒有temp文件夾，就到eclipse\plugins 目錄下把所有文件名裡有0.8的jar包刪掉，刪掉之後就可以在xml界面的graphical layout中看到佈局的預覽
 

還有問題是 看不到界面，這時就需要你更新sdk的Tools包Android SDK Platform-tools


/******************************************************************************/
[Android] 手機頁面的轉換(setContentView)
/******************************************************************************/
手機的世界哩，實現手機頁面的轉換最簡單作法為改變Activity的layout，只要善加利用這個，是可以做到很多頁面轉換的效果，也可以讓使用者選擇自己喜歡的系統樣式、
背景圖案及文字顏色等等，直接按套用來改變版型。另外使用setContentView來換置頁面還有一個很棒的優點，就是所有程式裡的變數皆存在相同的狀態，無論是類別成員變
數、類別函式等等，都可以在一個Activity下取得，沒有參數傳的的問題。比如說：訂票系統的程式，首先layout01先讓使用者輸入資料（姓名、電話、信用卡卡號等等），
下一畫面layout02為確認畫面讓使用者進行確認，最後一畫面layout03進行刷卡交易的動作。

本篇在討論一個Activity下，如何做到手機頁面轉換，而不是切換Activity! 切換Activity請看另一篇文章 http://style77125tech.pixnet.net/blog/post/13440183
小試身手小範例：
佈局的兩個layout分別為layout01(main.xml)以及layout02(mylayout.xml)，預設載入的layout為main.xml，此layout內有一個按鈕(Button)當按下此Button可以跳到layout02
去，同時在layout02佈局內也有一個按鈕(Button)當按下此Button可以跳到layout01去。

main.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:padding="10dip"
    >
    <TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/TextView01"
    android:text="This is Layout01!"
    android:layout_marginTop="10sp"
    android:textSize="20sp"
    />
    <Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="40sp"
    android:text=" Go to Layout02"
    android:id="@+id/Button01"
    />
</LinearLayout>

mylayout.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:padding="10dip"
    >
    <TextView
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/TextView02"
    android:text="This is Layout02"
    android:layout_marginTop="10sp"
    android:textSize="20sp"
    />
    <Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="40sp"
    android:text=" Go to Layout01"
    android:id="@+id/Button02"
    />
</LinearLayout>

Java檔
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
publicclass TestExam001 extends Activity {
    /** Called when the activity is first created. */
    @Override
    publicvoid onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);     
        Button button01 = (Button)findViewById(R.id.Button01);
        button01.setOnClickListener(new Button.OnClickListener(){
            publicvoid onClick(View v) {
                // TODO Auto-generated method stub
                jumpToLayout02();
            }
        });
    }
    publicvoid jumpToLayout02(){
        setContentView(R.layout.mylayout);
        Button button02= (Button)findViewById(R.id.Button02);
        button02.setOnClickListener(new Button.OnClickListener(){
            publicvoid onClick(View v) {
                // TODO Auto-generated method stub
                jumpToLayout01();
            }           
        });
    }
    publicvoid jumpToLayout01(){
        setContentView(R.layout.main);
        Button button01 = (Button)findViewById(R.id.Button01);
        button01.setOnClickListener(new Button.OnClickListener(){
            publicvoid onClick(View v) {
                // TODO Auto-generated method stub
                jumpToLayout02();
            }           
        });
    }
}


/******************************************************************************/
[Android] color.xml
/******************************************************************************/
在程式中很常需要替文字或是背景選擇顏色，所以必須透過android的layout機制。
step1.新增color.xml於res/values/color.xml下，並定義顏色。

color.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
<color name="blue">#FF0000FF</color>
<color name="white">#FFFFFF</color>
<color name="black">#000000</color>
</resources>

step2.在layout中引用顏色
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:background="@color/white"
>

/******************************************************************************/
開發適用於多種解析度的應用程式
/******************************************************************************/
從 1.6 版開始，Android 即支援多種螢幕解析度和密度，整體而言可分為以下三類：
小型：螢幕小於 T-Mobile G1 或 Samsung I7500 的裝置，例如 HTC Tattoo
正常：螢幕大小與 G1 或 I7500 大致相同的裝置。
大型：螢幕大於 G1 或 I7500 的裝置 (例如平板電腦風格的裝置)。
開發人員可以使用 Android API 和 SDK 架構所提供的工具，控制應用程式能否在每一類裝置上顯示，並針對可顯示的應用程式控制其顯示方式。您可以在《Android 開發人
員指南》中的支援多款螢幕一文中找到實作方式的詳細資料。
使用 Android 1.6 SDK 或更新版本升級應用程式之後，您必須確定您的應用程式僅開放給擁有相容手機的人使用。在您下一次將新版應用程式上傳至 Android Market 之前，
我們會假設您的應用程式適用於正常螢幕大小。這表示具有正常或大型螢幕的使用者擁有這些應用程式的使用權。具有「大型」螢幕的裝置在相容模式下即可執行這些應用程
式，這種模式可以在更大型的螢幕上模擬 HVGA 環境。
然而，具有「小型」螢幕的裝置只會顯示開發人員特別宣稱 (透過 AndroidManifest) 可在小型螢幕正常執行的應用程式。
或
請參考以下android官方文件的說明： http://developer.android.com/guide/practices/screens_support.html


/******************************************************************************/
[Android] - 檢查Internet是否正常運作
/******************************************************************************/
目前越來越多的app都會需要透過internet來進行server資料存取來進行服務的提供
那該如何來判斷目前使用者的android手機是否已經連接上了internet了呢？
不論是wifi, 3g還是LTE呢？
點選標題連結到stakeoverflow的問答可以瞭解到，要得知目前是否有Internet存在要注意下列幾點
於AndroidManifest.xml加入一user permision：android.permission.ACCESS_NETWORK_STATE。用意為
Allows applications to access information about networks 
原文翻釋大致意思為：允許應用程式取得網路資訊
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
   <!-- 略 -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <!-- 略 -->
</manifest>

於程式碼中撰寫判斷Internet的程式碼：
/**
 * check internet
 * 
 * @param context {@link Context}
 * @return if network error return true, if net work normal, return false;
 */
private boolean checkInternet(Context context) {
    boolean isNetError = false;
    try {
        // get the ConnectivityManager for handling management of network connections.
        ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        // 取得正在運行中的網路資訊，如果沒有網路存在會取得null
        NetworkInfo mNetworkInfo = mConnectivityManager.getActiveNetworkInfo();
 
        // 判斷是否有Internet
        if (mNetworkInfo != null && mNetworkInfo.isConnectedOrConnecting()) {
            isNetError = false;
        } else {
            isNetError = true;
        }/* end of if */
 
    } catch (Exception e) {
        isNetError = true;
    } /* end of try-catch */
 
    return isNetError;
}


/******************************************************************************/
Android 開發教學筆記 - 模仿 iOS UITabBarController 效果
/******************************************************************************/
ref: http://changyy.pixnet.net/blog/post/30895430-android-%E9%96%8B%E7%99%BC%E6%95%99%E5%AD%B8%E7%AD%86%E8%A8%98---%E6%A8%A1%E4%BB%BF-ios-uitabbarcontroller-


/******************************************************************************/
Android學習筆記 - 背景執行服務(Service)         ref: http://cooking-java.blogspot.tw/2010/04/android-service.html
/******************************************************************************/
1. 大部分使用者在手機上看到的畫面都是前端的程式(Activity)，但是還是要有很多的服務需在背景執行。
如果是要在背景執行的程式，則需要寫成Service並繼承android.app.Service，由於是在背景執行所以是
要寫成Service而不是Activity，因此需在AndroidManifest新增一個Service。以下範例是按下Start Service之後會
在背景每隔一秒Log目前的時間，按下Stop Service後會停止Log的動作。

2. MainActivity.java
package org.me.android_service;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

public class MainActivity extends Activity {
    private Button startButton;
    private Button stopButton;

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        setContentView(R.layout.main);
        startButton = (Button) findViewById(R.id.startButton);
        stopButton = (Button) findViewById(R.id.stopButton);
        startButton.setOnClickListener(startClickListener);
        stopButton.setOnClickListener(stopClickListener);
    }

    private Button.OnClickListener startClickListener = new Button.OnClickListener() {
        public void onClick(View arg0) {
            //啟動服務
            Intent intent = new Intent(MainActivity.this, NickyService.class);
            startService(intent);
        }
    };

    private Button.OnClickListener stopClickListener = new Button.OnClickListener() {
        public void onClick(View arg0) {
            //停止服務
            Intent intent = new Intent(MainActivity.this, NickyService.class);
            stopService(intent);
        }
    };
}


3. NickyService.java
package org.me.android_service;
import android.app.Service;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;
import java.util.Date;

//繼承android.app.Service
public class NickyService extends Service {
    private Handler handler = new Handler();

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onStart(Intent intent, int startId) {
        handler.postDelayed(showTime, 1000);
        super.onStart(intent, startId);
    }

    @Override
    public void onDestroy() {
        handler.removeCallbacks(showTime);
        super.onDestroy();
    }

    private Runnable showTime = new Runnable() {
        public void run() {
            //log目前時間
            Log.i("time:", new Date().toString());
            handler.postDelayed(this, 1000);
        }
    };
}


4. main.xml(Layout)
<?xml version="1.0" encoding="utf-8"?>
<AbsoluteLayout
    android:id="@+id/widget0"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    xmlns:android="http://schemas.android.com/apk/res/android" >
    <Button
        android:id="@+id/startButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Start Service"
        android:layout_x="40px"
        android:layout_y="67px" >
    </Button>
    <Button
        android:id="@+id/stopButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Stop Service"
        android:layout_x="140px"
        android:layout_y="67px" >
    </Button>
</AbsoluteLayout>


5. AndroidManifest.xml
<?xml version="1.0" encoding="UTF-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="org.me.android_spinner">
    <application>
         <activity android:name=".MainActivity" android:label="MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <service android:name=".NickyService"/>
    </application>
</manifest>


/******************************************************************************/
Android 開發教學筆記 - 模仿 iOS UINavigationController 效果     ref: http://changyy.pixnet.net/blog/post/30895436
/******************************************************************************/
為了給使用者有一致性的體驗，在 Android 環境上，實作 iOS UINavigationController 效果。
實作的方式很...直觀，就是每個 Activity 最上頭都擺在一個區域(header)來達成啦 XD

例如 header.xml：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="fill_parent"
        android:layout_height="50dp"
        android:background="@drawable/background">
        <FrameLayout
                android:layout_width="fill_parent"
                android:layout_height="fill_parent" 
                android:gravity="center"
                android:background="@null">

               <TextView
                       android:layout_width="fill_parent"
                       android:layout_height="fill_parent"
                       android:text="@string/title"
                       android:gravity="center"
                       android:textAppearance="?android:attr/textAppearanceMedium" />

               <ImageButton
                       android:id="@+id/btn_right"
                       android:layout_width="wrap_content"
                       android:layout_height="wrap_content"
                       android:src="@drawable/btn_right" 
                       android:background="@null"
                       android:contentDescription="@null"
                       android:layout_gravity="center_vertical|right"/>

        </FrameLayout> 
</LinearLayout>

而其他的 Activity layout 可以在開頭就用類似方式 include 進來：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:gravity="center_horizontal"
       android:orientation="vertical">

       <include android:id="@+id/header"
              layout="@layout/header"
              android:layout_height="wrap_content"
              android:layout_width="fill_parent"/>
       …
</LinearLayout>


/******************************************************************************/
從你的APK發佈Facebook訊息
/******************************************************************************/
from: http://lp43.blogspot.tw/2011/07/apkfacebook.html


/******************************************************************************/
關於Android的nodpi,xhdpi,hdpi,mdpi,ldpi         from : http://618119.com/archives/2011/01/12/205.html
/******************************************************************************/
首先是幾個基本概念：
1.螢幕尺寸Screen size
即顯示螢幕的實際大小，按照螢幕的對角線進行測量。
為簡單起見，Android把所有的螢幕大小分為四種尺寸：小，普通，大，超大(分別對應：small, normal, large, and extra large).
應用程式可以為這四種尺寸分別提供不同的自定義螢幕佈局-平台將根據螢幕實際尺寸選擇對應佈局進行渲染，這種選擇對於程式側是透明的。

2.螢幕長寬比Aspect ratio
長寬比是螢幕的物理寬度與物理高度的比例關係。應用程式可以通過使用限定的資源來為指定的長寬比提供螢幕佈局資源。

3.螢幕解析度Resolution
在螢幕上顯示的物理像素總和。需要注意的是：儘管解析度通常用寬x高表示，但解析度並不意味著具體的螢幕長寬比。
在Andorid系統中，應用程式不直接使用解析度。

4.密度Density
根據像素解析度，在螢幕指定物理寬高範圍內能顯示的像素數量。
在同樣的寬高區域，低密度的顯示屏能顯示的像素較少，而高密度的顯示屏則能顯示更多的像素。
螢幕密度非常重要，因為其它條件不變的情況下，一共寬高固定的UI元件（比如一個按鈕）在在低密度的顯示屏上顯得很大， 而在高密度顯示屏上看起來就很小。
為簡單起見，Android把所有的螢幕解析度也分為四種尺寸：小，普通，大，超大(分別對應：small, normal, large, and extra large).
應用程式可以為這四種尺寸分別提供不同的資源-平台將透明的對資源進行縮放以適配指定的螢幕解析度。

5.設備獨立像素Density-independent pixel (dp)
應用程式可以用來定義UI元件的虛擬像素單元，通過密度無關的方式來描述佈局尺寸和位置。
一個設備獨立像素相當於一個160 dpi螢幕上的物理像素。
在程式運行時，系統根據螢幕的實際密度透明的處理任何需要縮放的設備獨立像素單元，設備獨立像素轉換成螢幕實際像素的換算很簡單：pixels = dps * (density / 160).
例如在240 dpi的螢幕上，1個設備獨立像素等於1.5物理像素.為確保UI元件在不同的螢幕都能合適的展示，強烈建議使用設備獨立像素單元來定義你的應用程式UI。

四種螢幕尺寸分類：: small, normal, large, and xlarge
四種密度分類: ldpi (low), mdpi (medium), hdpi (high), and xhdpi (extra high)
需要注意的是: xhdpi是從 Android 2.2 (API Level 8)才開始增加的分類.
xlarge是從Android 2.3 (API Level 9)才開始增加的分類.
DPI是「dot per inch」的縮寫，每英吋像素數。
一般情況下的普通螢幕：ldpi是120，mdpi是160，hdpi是240，xhdpi是320。
參考：http://developer.android.com/images/screens_support/screens-ranges.png

兩種獲取螢幕解析度資訊的方法：

DisplayMetrics metrics = new DisplayMetrics();
Display display = activity.getWindowManager().getDefaultDisplay();
display.getMetrics(metrics);
//這裡得到的像素值是設備獨立像素dp

//DisplayMetrics metrics=activity.getResources().getDisplayMetrics(); 這樣獲得的參數資訊不正確，不要使用這種方式。
不能使用android.content.res.Resources.getSystem().getDisplayMetrics()。這個得到的寬和高是空的。
如果需要為Android pad定制資源文件，則res目錄下的目錄可能為：
drawable
drawable-ldpi
drawable-mdpi
drawable-hdpi
drawable-xhdpi
drawable-nodpi
drawable-nodpi-1024×600
drawable-nodpi-1280×800
drawable-nodpi-800×480
values
values-ldpi
values-mdpi
values-hdpi
values-xhdpi
values-nodpi
values-nodpi-1024×600
values-nodpi-1280×800
values-nodpi-800×480

參考：

http://developer.android.com/guide/practices/screens_support.html


/******************************************************************************/
不顯示標題欄(Title Bar)                      android:theme="@style/AppTheme" >
/******************************************************************************/
不顯示標題欄(Title Bar), 可以使用Java程式碼:
import android.view.Window;

//Remove title bar
this.requestWindowFeature(Window.FEATURE_NO_TITLE);


或, 在AndroidManifest.xml內插入XML代碼: 
android:theme="@android:style/Theme.NoTitleBar"
<activity android:name=".helloandroid" <br="">                  
    android:label="我的新名字"
    android:theme="@android:style/Theme.NoTitleBar">
    <intent-filter>
        <action android:name="android.intent.action.MAIN">
            <category android:name="android.intent.category.LAUNCHER">
            </category>
        </action>
    </intent-filter>
</activity>


/******************************************************************************/
Android 開發教學筆記 - 批次、大量設定按鈕事件偵測(setOnClickListener)
/******************************************************************************/
最近的案子很特別，除了一堆 Activity 外，每一個 Activity 裡頭又有一堆 Button/ImageButton 要處理，如果是依照一般教學文：
Button b = null;
if( ( b = (Button)findViewById( R.id.button01) ) != null )
        b.setOnClickListener( new Button.OnClickListener(){ /* ... */ } );
if( ( b = (Button)findViewById( R.id.button02) ) != null )
        b.setOnClickListener( new Button.OnClickListener(){ /* ... */ } );
...

假設有 20~30 個按鈕，就得用 findViewById 處理 20~30 次，程式碼就又臭又長。
另一種作法則是把每個 Button/ImageButton 都設定為同一個 Button.OnClickListener 來管理，透過 View.getId() 來偵測，的確可以省記憶體，但還是不免要把
 layout 上一堆按鈕都先 findViewById 一下，後來跟同事閒聊時，恰好提到用動態新增按鈕的方式，於是被 loop 關鍵字提醒一下，就來惡搞了：

void initOnClickListener() {
        int my_ids[] = {
                R.id.button01, R.id.button02, R.id.button03, ...
        };

        Button b = null;
        for( int i=0 ; i< ids.length ; ++i )
                if( ( b = (Button)findViewById( my_ids[i]) ) != null ) 
                        b.setOnClickListener(this);
}

public void onClick(View v) {
        switch( v.getId() ) {
                case R.id.button01:
                        break;
                case R.id.button02:
                        break;
                // ...
        }
}

其中的 this 就是指 MyActivity extends Activity implements OnClickListener，如此一來可以用最簡短的程式碼，很方便的初始化 layout 上頭的按鈕，也不用每個按鈕
都 new Button.OnClickListener 出來，也會省記憶吧。這樣管理 Button/ImageButton 還滿方便的，只需把要偵測的按鈕，將其 R.id.name 擺在 array 裡頭，跑 loop 來
解決就好啦。如果有用  PagerAdapter/ViewPager 實作 iOS PageControl 的話，更可以用多階層來管理：

final int cntView = 3;
int my_ids[][] = {
        {
                R.id.view1_btn1 , R.id.view1_btn2 , R.id.view1_btn3, ...
        } , 
        {
                R.id.view2_btn1 , R.id.view2_btn2 , R.id.view2_btn3, ...
        } ,
        {
                R.id.view3_btn1 , R.id.view3_btn2 , R.id.view3_btn3, ...
        }
}; 

for( int i=0 ; i<cntView ; ++i ) {
        for( int j=0 ; j<my_ids[i].length ; ++j ) {
                if( ( b = (Button)mPageView.get(i).findViewById( my_ids[i]) ) != null )
                        b.setOnClickListener( this );
        }
} 

其中 mPageView 用來記錄每個 page 的 Activity 囉。


/******************************************************************************/
Android界面基本屬性
/******************************************************************************/
佈局：  
在 android 中我們常用的佈局方式有這麼幾種：
1.LinearLayout ( 線性佈局 ) ：(裡面只可以有一個控件，並且不能設計這個控件的位置，控件會放到左上角)
線性佈局分為水平線性和垂直線性二者的屬性分別為： android:orientation= " horizontal "   android:orientation= "vertical" 。

2.RelativeLayout ( 相對佈局 ) ： (裡面可以放多個控件，但是一行只能放一個控件)
附加幾類 RelativeLayout 的屬性供大家參考：
第一類 : 屬性值為 true 或 false
android:layout_centerHrizontal                  水平居中
android:layout_centerVertical                   垂直居中
android:layout_centerInparent                   相對於父元素完全居中
android:layout_alignParentBottom                貼緊父元素的下邊緣
android:layout_alignParentLeft                  貼緊父元素的左邊緣
android:layout_alignParentRight                 貼緊父元素的右邊緣
android:layout_alignParentTop                   貼緊父元素的上邊緣
android:layout_alignWithParentIfMissing         若找不到兄弟元素以父元素做參照物
 
第二類：屬性值必須為 id 的引用名「 @id/id-name 」
android:layout_below                            在某元素的下方
android:layout_above                            在某元素的上方
android:layout_toLeftOf                         在某元素的左邊
android:layout_toRightOf                        在某元素的右邊
android:layout_alignTop                         本元素的上邊緣和某元素的的上邊緣對齊
android:layout_alignLeft                        本元素的左邊緣和某元素的的左邊緣對齊
android:layout_alignBottom                      本元素的下邊緣和某元素的的下邊緣對齊
android:layout_alignRight                       本元素的右邊緣和某元素的的右邊緣對齊
 
第三類：屬性值為具體的像素值，如 30dip ， 40px
android:layout_marginBottom                     離某元素底邊緣的距離
android:layout_marginLeft                       離某元素左邊緣的距離
android:layout_marginRight                      離某元素右邊緣的距離
android:layout_marginTop                        離某元素上邊緣的距離
 
3.TableLayout ( 表格佈局 ) ： (這個要和TableRow配合使用，很像html裡面的table)
這個表格佈局不像HTML中的表格那樣靈活，只能通過 TableRow 屬性來控制它的行而列的話裡面有幾個控件就是幾列(一般情況)。 如：
<TableLayout>
    <TableRow>
        <EditText></EditText>
        <EditText></EditText>
    </TableRow>
<TableRow>
    <EditText></EditText>
    <EditText></EditText>
</TableRow>
</TableLayout>
表示兩行兩列的一個表格。
android:gravity="center" 書面解釋是權重比。其時就是讓它居中顯示。它還可以動態添加裡面的每行每列。如下代碼所示:
/*根據id查找表格對像*/
TableLayout tableLayout = (TableLayout) findViewById(R.id.table01);
/*創建列對像*/
TableRow tableRow = new TableRow(this);
/*文本框對像*/
TextView temp = new TextView(this);
temp.setText("text的值");
/*將此文本添加到列中*/
tableRow.addView(temp);
android:stretchColumns="1,2,3,4" 它的意思就是自動拉伸1,2,3,4列。
                                                   
4.AbsoluteLayout ( 絕對佈局 ) ： (裡面可以放多個控件，並且可以自己定義控件的x,y的位置)

5.FrameLayout ( 幀佈局 ) ：(裡面可以放多個控件，不過控件的位置都是相對位置)
在它裡面的控件都是按後面的一個控件疊加在前一個控件上來顯示的,所有元素都被放置在最左上角。 如：
<FrameLayout android:layout_width="wrap_content"
        android:layout_height="wrap_content" android:layout_weight="1">
        <ImageView android:id="@+id/iv1" android:layout_width="wrap_content"
                android:layout_height="wrap_content" android:visibility="invisible"
                android:src="@drawable/lotusleaf"></ImageView>
        <ImageView android:id="@+id/f1" android:layout_width="wrap_content"
                android:layout_height="wrap_content" android:src="@drawable/frog_right"
                android:visibility="invisible"></ImageView>
</FrameLayout>
表示的是id為f1的控件疊加在id為iv1的控件上面顯示
(LinearLayout 和 RelativeLayout 應該又是其中用的較多的兩種。AbsoluteLayout 比較少用，因為它是按螢幕的絕對位置來佈局的如果螢幕大小發生改變的話控件的位置也
發生了改變。這個就相當於HTML中的絕對佈局一樣，一般不推薦使用 )  
注意事項：
1 、各佈局不要亂用各自的屬性。比如把屬於 AbsoluteLayout 佈局的android:layout_x和android:layout_y用到 LinearLayout 佈局或 RelativeLayout 佈局，
或者把 RelativeLayout 佈局的 below ， rightof 等屬性應用到其他佈局中。這樣做雖然不會報錯，但這是白浪費感情的工作，根本達不到我們需要的效果。
2 、關於android:layout_width="fill_parent" 和 android:layout_height="wrap_content" ，這是對每個佈局寬和高的設置。 
    wrap_content 可表示隨著其中控件的不同而改變這個佈局的寬度或高度，類似於自動設置寬和高， 
    fill_parent 使佈局填充整個螢幕，另外還有一種 
    match_parent ，它本質上和 fill_parent 一樣，並從 API  Level8 開始替代 fill_parent 。

TextView 的屬性 :
android:autoLink                        //設置是否當文本為URL鏈接/email/電話號碼/map時，文本顯示為可點擊的鏈接。可選值(none/web /email/phone/map/all)
android:autoText                        //如果設置，將自動執行輸入值的拼寫糾正。此處無效果，在顯示輸入法並輸入的時候起作用
android:bufferType                      //指定getText()方式取得的文本類別。選項editable 類似於StringBuilder可追加字元，也就是說getText後可調用append方法設置文本內容。spannable 則可在給定的字元區域使用樣式
android:capitalize                      //設置英文字母大寫類型。此處無效果，需要彈出輸入法才能看得到，參見EditView此屬性說明
android:cursorVisible                   //設定游標為顯示/隱藏，默認顯示
android:digits                          //設置允許輸入哪些字元。如「1234567890.+-*/% ()」
android:drawableBottom                  //在text的下方輸出一個drawable，如圖片。如果指定一個顏色的話會把text的背景設為該顏色，並且同時和background使用時覆蓋後者
android:drawableLeft                    //在text的左邊輸出一個drawable，如圖片
android:drawablePadding                 //設置text與drawable(圖片)的間隔，與drawableLeft、 drawableRight、drawableTop、drawableBottom一起使用，可設置為負數，單獨使用沒有效果
android:drawableRight                   //在text的右邊輸出一個drawable
android:drawableTop                     //在text的正上方輸出一個drawable
android:editable                        //設置是否可編輯
android:editorExtras                    //設置文本的額外的輸入數據
android:ellipsize                       //設置當文字過長時,該控件該如何顯示。有如下值設置：」start」—?省略號顯示在開頭;」end」 ——省略號顯示在結尾;」middle」—-省略號顯示在中間;」marquee」 ——以跑馬燈的方式顯示(動畫橫向移動)
android:freezesText                     //設置保存文本的內容以及游標的位置
android:gravity                         //設置文本位置，如設置成「center」，文本將居中顯示
android:hintText                        //為空時顯示的文字提示資訊，可通過textColorHint設置提示資訊的顏色。此屬性在 EditView中使用，但是這裡也可以用
android:imeOptions                      //附加功能，設置右下角IME動作與編輯框相關的動作，如actionDone右下角將顯示一個「完成」，而不設置默認是一個回車符號。這個在EditView中再詳細說明，此處無用
android:imeActionId                     //設置IME動作ID
android:imeActionLabel                  //設置IME動作標籤
android:includeFontPadding              //設置文本是否包含頂部和底部額外空白，默認為true
android:inputMethod                     //為文本指定輸入法，需要完全限定名(完整的包名)。例如：com.google.android.inputmethod.pinyin，但是這裡報錯找不到
android:inputType                       //設置文本的類型，用於幫助輸入法顯示合適的鍵盤類型。在EditView中再詳細說明，這裡無效果
android:linksClickable                  //設置鏈接是否點擊連接，即使設置了autoLink
android:marqueeRepeatLimit              //在ellipsize指定marquee的情況下，設置重複滾動的次數，當設置為 marquee_forever時表示無限次
android:ems                             //設置TextView的寬度為N個字元的寬度。這裡測試為一個漢字字元寬度
android:maxEms                          //設置TextView的寬度為最長為N個字元的寬度。與ems同時使用時覆蓋ems選項
android:maxLength                       //限制顯示的文本長度，超出部分不顯示
android:lines                           //設置文本的行數，設置兩行就顯示兩行，即使第二行沒有數據
android:maxLines                        //設置文本的最大顯示行數，與width或者layout_width結合使用，超出部分自動換行，超出行數將不顯示
android:minLines                        //設置文本的最小行數，與lines類似
android:lineSpacingExtra                //設置行間距
android:lineSpacingMultiplier           //設置行間距的倍數。如」$2
android:numeric                         //如果被設置，該TextView有一個數字輸入法。此處無用，設置後唯一效果是TextView有點擊效果，此屬性在EdtiView將詳細說明
android:password                        //以小點」.」顯示文本 android:phoneNumber設置為電話號碼的輸入方式
android:privateImeOptions               //設置輸入法選項，此處無用，在EditText將進一步討論
android:scrollHorizontally              //設置文本超出TextView的寬度的情況下，是否出現橫拉條
android:selectAllOnFocus                //如果文本是可選擇的，讓他獲取焦點而不是將游標移動為文本的開始位置或者末尾位置。TextView中設置後無效果
android:shadowColor                     //指定文本陰影的顏色，需要與shadowRadius一起使用
android:shadowDx                        //設置陰影橫向坐標開始位置
android:shadowDy                        //設置陰影縱向坐標開始位置
android:shadowRadius                    //設置陰影的半徑。設置為0.1就變成字體的顏色了，一般設置為3.0的效果比較好
android:singleLine                      //設置單行顯示。如果和layout_width一起使用，當文本不能全部顯示時，後面用「…」來表示。如android:text="test_ singleLine " android:singleLine="true" android:layout_width="20dp"將只顯示「t…」。如果不設置singleLine或者設置為false，文本將自動換行 android:text設置顯示文本. android:textAppearance設置文字外觀。如 「?android:attr/textAppearanceLargeInverse」這裡引用的是系統自帶的一個外觀，?表示系統是否有這種外觀，否則使用默認的外觀。可設置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse
android:textColor                       //設置文本顏色
android:textColorHighlight              //被選中文字的底色，默認為藍色
android:textColorHint                   //設置提示資訊文字的顏色，默認為灰色。與hint一起使用。
android:textColorLink                   //文字鏈接的顏色.
android:textScaleX                      //設置文字之間間隔，默認為$2。
android:textSize                        //設置文字大小，推薦度量單位」sp」，如」15sp」
android:textStyle                       //設置字形[bold(粗體) 0, italic(斜體) 1, bolditalic(又粗又斜) 2] 可以設置一個或多個，用「|」隔開
android:typeface                        //設置文本字體，必須是以下常量值之一：normal 0, sans 1, serif 2, monospace(等寬字體) 3]
android:height                          //設置文本區域的高度，支援度量單位：px(像素)/dp/sp/in/mm(公釐)
android:maxHeight                       //設置文本區域的最大高度
android:minHeight                       //設置文本區域的最小高度
android:width                           //設置文本區域的寬度，支援度量單位：px(像素)/dp/sp/in/mm(公釐)，與layout_width 的區別看這裡
android:maxWidth                        //設置文本區域的最大寬度
android:minWidth                        //設置文本區域的最小寬度 android佈局屬性詳解 RelativeLayout用到的一些重要的屬性：第一類:屬性值為true或false
android:layout_centerHrizontal          //水平居中
android:layout_centerVertical           //垂直居中
android:layout_centerInparent           //相對於父元素完全居中
android:layout_alignParentBottom        //貼緊父元素的下邊緣
android:layout_alignParentLeft          //貼緊父元素的左邊緣
android:layout_alignParentRight         //貼緊父元素的右邊緣
android:layout_alignParentTop           //貼緊父元素的上邊緣
android:layout_alignWithParentIfMissing //如果對應的兄弟元素找不到的話就以父元素做參照物 第二類：屬性值必須為id的引用名「@id/id-name」
android:layout_below                    //在某元素的下方
android:layout_above                    //在某元素的的上方
android:layout_toLeftOf                 //在某元素的左邊
android:layout_toRightOf                //在某元素的右邊
android:layout_alignTop                 //本元素的上邊緣和某元素的的上邊緣對齊
android:layout_alignLeft                //本元素的左邊緣和某元素的的左邊緣對齊
android:layout_alignBottom              //本元素的下邊緣和某元素的的下邊緣對齊
android:layout_alignRight               //本元素的右邊緣和某元素的的右邊緣對齊 第三類：屬性值為具體的像素值，如30dip，40px
android:layout_marginBottom             //離某元素底邊緣的距離
android:layout_marginLeft               //離某元素左邊緣的距離
android:layout_marginRight              //離某元素右邊緣的距離
android:layout_marginTop                //離某元素上邊緣的距離 EditText的android:hint 設置EditText為空時輸入框內的提示資訊　
android:gravity                         //屬性是對該view 內容的限定．比如一個button 上面的text. 你可以設置該text 在view的靠左，靠右等位置．以button為例，android:gravity="right"則button上面的文字靠右 android:layout_gravity android:layout_gravity是用來設置該view相對與起父view 的位置．比如一個button 在linearlayout裡，你想把該button放在靠左、靠右等位置就可以通過該屬性設置．以button為例，android:layout_gravity="right"則button靠右 android:layout_alignParentRight 使當前控件的右端和父控件的右端對齊。這裡屬性值只能為true或false，默認false。 android:scaleType： android:scaleType是控制圖片如何resized/moved來匹對ImageView的size。ImageView.ScaleType / android:scaleType值的意義區別： CENTER /center 按圖片的原來size居中顯示，當圖片長/寬超過View的長/寬，則截取圖片的居中部分顯示 CENTER_CROP / centerCrop 按比例擴大圖片的size居中顯示，使得圖片長(寬)等於或大於View的長(寬) CENTER_INSIDE / centerInside 將圖片的內容完整居中顯示，通過按比例縮小或原來的size使得圖片長/寬等於或小於View的長/寬 FIT_CENTER / fitCenter 把圖片按比例擴大/縮小到View的寬度，居中顯示 FIT_END / fitEnd 把圖片按比例擴大/縮小到View的寬度，顯示在View的下部分位置 FIT_START / fitStart 把圖片按比例擴大/縮小到View的寬度，顯示在View的上部分位置 FIT_XY / fitXY 把圖片不按比例擴大/縮小到View的大小顯示 MATRIX / matrix 用矩陣來繪製，動態縮小放大圖片來顯示。 ** 要注意一點，Drawable文件夾裡面的圖片命名是不能大寫的
 
Edittext 的屬性 :    
EditText繼承關係：View-->TextView-->EditText。 EditText 的屬性很多，這裡介紹幾個：            
android:layout_gravity="center_vertical"      //設置控件顯示的位置：默認top，這裡居中顯示，還有bottom         
android:hint="請輸入數字！"                  //設置顯示在空間上的提示資訊         
android:numeric="integer"                    //設置只能輸入整數，如果是小數則是：decimal         
android:singleLine="true"                     //設置單行輸入，一旦設置為true，則文字不會自動換行。         
android:password="true"                     //設置只能輸入密碼         
android:textColor = "#ff$200"                 //字體顏色         
android:textStyle="bold"                      //字體，bold, italic, bolditalic         
android:textSize="20dip"                     //大小         
android:capitalize = "characters"              //以大寫字母寫         
android:textAlign="center"                    //EditText沒有這個屬性，但TextView有，居中         
android:textColorHighlight="#cccccc"         //被選中文字的底色，默認為藍色         
android:textColorHint="#ffff00"               //設置提示資訊文字的顏色，默認為灰色         
android:textScaleX="1.5"                    //控制字與字之間的間距         
android:typeface="monospace"              //字型，normal, sans, serif, monospace         
android:background="@null"                 //空間背景，這裡沒有，指透明         
android:layout_weight="1"                   //權重，控制控件之間的地位,在控制控件顯示的大小時蠻有用的。         
android:textAppearance="?android:attr/textAppearanceLargeInverse"
     
1.EditText默認不彈出軟體鍵盤
方法一：
在 AndroidMainfest.xml中選擇哪個activity，設置windowSoftInputMode屬性為 adjustUnspecified|stateHidden
   android:windowSoftInputMode="adjustUnspecified|stateHidden"
方法二：
讓 EditText失去焦點，使用EditText的clearFocus方法
   edit.clearFocus();
方法三：
強制隱藏Android輸入法窗口
例如：EditText edit=(EditText)findViewById(R.id.edit);
  InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
  imm.hideSoftInputFromWindow(edit.getWindowToken(),0);
2.EditText始終不彈出軟體鍵盤
例：EditText edit=(EditText)findViewById(R.id.edit);
  edit.setInputType(InputType.TYPE_NULL);

  Button       繼承自 VIEW , VIEW 有的屬性它都能用 
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
<item android:state_pressed="true"> （這裡的樣式是當按鈕被按下時的顯示）
<shape>
    <gradient
        android:startColor="@drawable/gray"
        android:endColor="@drawable/white"
        android:angle="*"/>
    <stroke
        android:width="*dp"
        android:color="@drawable/teal"/>
    <corners
        android:radius="*dp"/>
    <padding
        android:left="**dp"
        android:top="*dp"
        android:right="**dp"
        android:bottom="*dp"/>
</shape>
</item>
 
<item android:state_focused="true">（這裡的樣式是移動到按鈕時的顯示）
<shape>
    <gradient
        android:startColor="@drawable/silver"
        android:endColor="@drawable/springgreen"
        android:angle="*"/>
    <stroke
        android:width="*dp"
        android:color="@drawable/teal"/>
    <corners
        android:radius="*dp"/>
    <padding
        android:left="**dp"
        android:top="*dp"
        android:right="**dp"
        android:bottom="*dp"/>
</shape>
</item>
 
<item> （這裡的樣式是按鈕正常時的顯示）
<shape>
    <gradient
        android:startColor="@drawable/silver"
        android:endColor="@drawable/snow"
        android:angle="*"/>
    <stroke
        android:width="*dp"
        android:color="@drawable/teal"/>
    <corners
        android:radius="*dp"/>
    <padding
        android:left="**dp"
        android:top="*dp"
        android:right="**dp"
        android:bottom="*dp"/>
</shape>
</item>
</selector>
註：
<padding
android:left="**dp"
android:top="*dp"
android:right="**dp"
android:bottom="*dp" />
這裡 left 和 right 控制的是 Button 上的字體與按鈕的左邊緣和右邊緣的距離，也就是控制按鈕是長還是短；這裡的 top 和 bottom 控制的是 Button 上的字體與按鈕的上邊緣和下邊緣的距離，也就是控制按鈕時高還是矮。
 
Shape 樣式圓滑效果：
<?xml version="1.0" encoding="UTF-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
<solid android:color=""/>
<stroke android:width="*dp" android:color=" " />
<padding android:left="*dp" android:top="*dp"
android:right="*dp" android:bottom="*dp"/>
<corners android:radius="*dp"/>
</shape>
 
CheckBox
RadioGroup
Spinner
TimePicker
ScrollView
ProgressBar
RatingBar
ImageView
ImageButton      android:background="#00000000"     //設置背景圖空白的部分直接透視背景
ImageSwicher&Gallery
GradView
Tab
Menu


/******************************************************************************/
Android 自動獲取時間的方法
/******************************************************************************/
對於手機，如果有SIM卡支援的話，在設置時間時可以通過選擇自動從網路獲取時間來取得當地的時間和時區：
但如果手機沒有SIM卡，此時如果有Wifi鏈接，手機依然可以通過網路自動獲取時間（時區此時需要手動設置）。 
查看Android源碼，在android.net 中有 SntpClient類，可以通過訪問NTP伺服器來取得當前的GMT時間。
pool.ntp.org為最常用的一個NTF伺服器。修改SntpClient代碼，你也可以在自己的應用（包括非Android應用）中通過NTP伺服器來取得當前GMT時間，代碼如下：

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Date;
 
public class GetTime {
    public static void main(String[] args) {
        SntpClient client = new SntpClient();
        if (client.requestTime("pool.ntp.org", 30000)) {
            long now = client.getNtpTime() + System.nanoTime() / 1000 - client.getNtpTimeReference();
            Date current = new Date(now);
            System.out.println(current.toString());
        }
    }
}

class SntpClient {
    private static final int ORIGINATE_TIME_OFFSET = 24;
    private static final int RECEIVE_TIME_OFFSET = 32;
    private static final int TRANSMIT_TIME_OFFSET = 40;
    private static final int NTP_PACKET_SIZE = 48;
    private static final int NTP_PORT = 123;
    private static final int NTP_MODE_CLIENT = 3;
    private static final int NTP_VERSION = 3;

    // Number of seconds between Jan 1, 1900 and Jan 1, 1970
    // 70 years plus 17 leap days
    private static final long OFFSET_1900_TO_1970 = ((365L * 70L) + 17L) * 24L * 60L * 60L;

    // system time computed from NTP server response
    private long mNtpTime;
 
    // value of SystemClock.elapsedRealtime() corresponding to mNtpTime
    private long mNtpTimeReference;

    // round trip time in milliseconds
    private long mRoundTripTime;
 
    /**
     * Sends an SNTP request to the given host and processes the response.
     *
     * @param host
     *            host name of the server.
     * @param timeout
     *            network timeout in milliseconds.
     * @return true if the transaction was successful.
     */
    public boolean requestTime(String host, int timeout) {
        try {
            DatagramSocket socket = new DatagramSocket();
            socket.setSoTimeout(timeout);
            InetAddress address = InetAddress.getByName(host);
            byte[] buffer = new byte[NTP_PACKET_SIZE];
            DatagramPacket request = new DatagramPacket(buffer, buffer.length,
                    address, NTP_PORT);
 
            // set mode = 3 (client) and version = 3
            // mode is in low 3 bits of first byte
            // version is in bits 3-5 of first byte
            buffer[0] = NTP_MODE_CLIENT | (NTP_VERSION << 3);
 
            // get current time and write it to the request packet
            long requestTime = System.currentTimeMillis();
            long requestTicks = System.nanoTime() / 1000;
            writeTimeStamp(buffer, TRANSMIT_TIME_OFFSET, requestTime);
 
            socket.send(request);
 
            // read the response
            DatagramPacket response = new DatagramPacket(buffer, buffer.length);
            socket.receive(response);
            long responseTicks = System.nanoTime() / 1000;
            long responseTime = requestTime + (responseTicks - requestTicks);
            socket.close();
 
            // extract the results
            long originateTime = readTimeStamp(buffer, ORIGINATE_TIME_OFFSET);
            long receiveTime = readTimeStamp(buffer, RECEIVE_TIME_OFFSET);
            long transmitTime = readTimeStamp(buffer, TRANSMIT_TIME_OFFSET);
            long roundTripTime = responseTicks - requestTicks
                    - (transmitTime - receiveTime);
            // receiveTime = originateTime + transit + skew
            // responseTime = transmitTime + transit - skew
            // clockOffset = ((receiveTime - originateTime) + (transmitTime -
            // responseTime))/2
            // = ((originateTime + transit + skew - originateTime) +
            // (transmitTime - (transmitTime + transit - skew)))/2
            // = ((transit + skew) + (transmitTime - transmitTime - transit +
            // skew))/2
            // = (transit + skew - transit + skew)/2
            // = (2 * skew)/2 = skew
            long clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime)) / 2;
            // if (Config.LOGD) Log.d(TAG, "round trip: " + roundTripTime +
            // " ms");
            // if (Config.LOGD) Log.d(TAG, "clock offset: " + clockOffset +
            // " ms");

            // save our results - use the times on this side of the network
            // latency
            // (response rather than request time)
            mNtpTime = responseTime + clockOffset;
            mNtpTimeReference = responseTicks;
            mRoundTripTime = roundTripTime;
        } catch (Exception e) {

            return false;
        }
        return true;
    }

    /**
     * Returns the time computed from the NTP transaction.
     *
     * @return time value computed from NTP server response.
     */
    public long getNtpTime() {
        return mNtpTime;
    }

    /**
     * Returns the reference clock value (value of
     * SystemClock.elapsedRealtime()) corresponding to the NTP time.
     *
     * @return reference clock corresponding to the NTP time.
     */
    public long getNtpTimeReference() {
        return mNtpTimeReference;
    }

    /**
     * Returns the round trip time of the NTP transaction
     *
     * @return round trip time in milliseconds.
     */
    public long getRoundTripTime() {
        return mRoundTripTime;
    }

    /**
     * Reads an unsigned 32 bit big endian number from the given offset in the
     * buffer.
     */
    private long read32(byte[] buffer, int offset) {
        byte b0 = buffer[offset];
        byte b1 = buffer[offset + 1];
        byte b2 = buffer[offset + 2];
        byte b3 = buffer[offset + 3];

        // convert signed bytes to unsigned values
        int i0 = ((b0 & 0x80) == 0x80 ? (b0 & 0x7F) + 0x80 : b0);
        int i1 = ((b1 & 0x80) == 0x80 ? (b1 & 0x7F) + 0x80 : b1);
        int i2 = ((b2 & 0x80) == 0x80 ? (b2 & 0x7F) + 0x80 : b2);
        int i3 = ((b3 & 0x80) == 0x80 ? (b3 & 0x7F) + 0x80 : b3);

        return ((long) i0 << 24) + ((long) i1 << 16) + ((long) i2 << 8) + (long) i3;
    }

    /**
     * Reads the NTP time stamp at the given offset in the buffer and returns it
     * as a system time (milliseconds since January 1, 1970).
     */
    private long readTimeStamp(byte[] buffer, int offset) {
        long seconds = read32(buffer, offset);
        long fraction = read32(buffer, offset + 4);
        return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);
    }

    /**
     * Writes system time (milliseconds since January 1, 1970) as an NTP time
     * stamp at the given offset in the buffer.
     */
    private void writeTimeStamp(byte[] buffer, int offset, long time) {
        long seconds = time / 1000L;
        long milliseconds = time - seconds * 1000L;
        seconds += OFFSET_1900_TO_1970;

        // write seconds in big endian format
        buffer[offset++] = (byte) (seconds >> 24);
        buffer[offset++] = (byte) (seconds >> 16);
        buffer[offset++] = (byte) (seconds >> 8);
        buffer[offset++] = (byte) (seconds >> 0);

        long fraction = milliseconds * 0x100000000L / 1000L;
        // write fraction in big endian format
        buffer[offset++] = (byte) (fraction >> 24);
        buffer[offset++] = (byte) (fraction >> 16);
        buffer[offset++] = (byte) (fraction >> 8);
        // low order bits should be random data
        buffer[offset++] = (byte) (Math.random() * 255.0);
    }
}
運行這個Java應用，可以得到當前GMT時間，如：Sat Jun 16 10:52:19 BST 2012


/******************************************************************************/
TabActivity的美化        ref: http://www.oschina.net/question/54100_32909
/******************************************************************************/
第一篇從TabActivity著手，一直以為Android中的TabActivity只能放在上面，只能如此醜陋，直到有一天看到「米聊」。

咋一看，軟體下面的那個功能表欄，覺得像是用LinearLayout+Button來實現的，但事實上，它卻是一個Tab！
怎麼看出來的？我就不多說了，你懂的。

下面我們來抽絲剝繭，一步步分析它的實現過程。
1.TabActivity的佈局
<TabHost xmlns:android="http://schemas.android.com/apk/res/android"
 android:id="@android:id/tabhost"
 android:layout_width="fill_parent"
 android:layout_height="fill_parent"
  >
 <LinearLayout
  android:orientation="vertical"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent">

      <FrameLayout
       android:gravity="center"
       android:id="@android:id/tabcontent"
       android:layout_width="fill_parent"
       android:layout_height="wrap_content"
       android:layout_weight="1.0" >

       <LinearLayout android:id="@+id/first"
              android:orientation="vertical"
              android:background="#ffffff"
              android:layout_width="fill_parent"
              android:layout_height="fill_parent" >

              <TextView android:layout_width="fill_parent"
                  android:layout_height="fill_parent"
                  android:text="first tab" />

       </LinearLayout>
       <LinearLayout android:id="@+id/second"
              android:orientation="vertical"
              android:background="#ffffff"
              android:layout_width="fill_parent"
              android:layout_height="fill_parent" >

              <TextView android:layout_width="fill_parent"
                  android:layout_height="fill_parent"
                  android:text="second tab" />
       </LinearLayout>

      </FrameLayout>
      <TabWidget
       android:id="@android:id/tabs"
       android:background="@drawable/tab_bottom_bg"
       android:padding="3.0dip"
       android:layout_width="fill_parent"
       android:layout_height="wrap_content"
       android:layout_weight="0.0" />

  </LinearLayout>
</TabHost>

我們看到，要自定義一個位於螢幕下方的TAB標籤，首先我們不能使用缺省的TabActivity實現了，啥事都要自己親力親為。
很好理解，把tabs放在tabcontent下面就可以了。其它不多說了。

2.MainActivity的實現代碼
先看看缺省的實現代碼，不複雜，省略一些無關的東西：
private void setIndicator(int icon, int title, int view) {
        String str = getResources().getString(title);

        TabHost.TabSpec localTabSpec=tabhost.newTabSpec(str).setIndicator(str,getResources().getDrawable(icon)).setContent(view);
        tabhost.addTab(localTabSpec);
    }
private void setIndicator(int icon, int title, int view) {
     String str = getResources().getString(title);
      
     TabHost.TabSpec localTabSpec=tabhost.newTabSpec(str).setIndicator(str,getResources().getDrawable(icon)).setContent(view);
     tabhost.addTab(localTabSpec);
    }
可以測試一下，效果出來了吧，雖然有點丑，但它真的在螢幕下方了。

3.美化TAB標籤
現在我們來定制這個TAB的標籤。先看代碼：

private void setIndicator(int icon, int title, int view) {
  
 View localView = LayoutInflater.from(this.tabhost.getContext()).inflate(R.layout.main_activity_tab, null);
 ((ImageView)localView.findViewById(R.id.main_activity_tab_image)).setBackgroundResource(icon);
 ((TextView)localView.findViewById(R.id.main_activity_tab_text)).setText(title);
  
 String str = getResources().getString(title);
  
 TabHost.TabSpec localTabSpec = tabhost.newTabSpec(str).setIndicator(localView).setContent(view);
 tabhost.addTab(localTabSpec);
}
  
注意到這個main_activity_tab的layout了吧，看看它的內容：
<?xml version="1.0" encoding="UTF-8"?> 
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
  android:gravity="center"
  android:orientation="vertical"
  android:id="@id/tabsLayout"
  android:background="@drawable/tab_item_bkg"
  android:padding="3.0dip"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_marginTop="3.0dip"
  android:layout_marginBottom="3.0dip" >

  <FrameLayout
      android:layout_width="fill_parent"
      android:layout_height="fill_parent"
      android:layout_weight="0.6">

      <ImageView
          android:layout_gravity="center"
          android:id="@id/main_activity_tab_image"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:layout_marginTop="2.0dip"
          android:scaleType="center" />
  </FrameLayout>

  <TextView
      android:textSize="12.0dip"
      android:textColor="@drawable/tab_text_selector"
      android:id="@id/main_activity_tab_text"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      android:text="Title" />
</LinearLayout>

這個文件定義了每個TAB標籤的樣式，tab_item_bkg定義每個item的背景（包括focused/selected/pressed），每個item上面的圖示和下面的文字都在代碼中動態定義即可。其中tab_text_selector則定義文字的顏色。


/******************************************************************************/
android體系結構         ref:http://my.oschina.net/huangsm/blog/29100
/******************************************************************************/
android體系結構介紹：
應用程式（application）
應用程式框架（Application Framework）
各種庫和android運行環境
操作層OS

應用程式（application）：
android的應用程式通常涉及用戶界面和交互；

應用程式框架（application Framework）：
1. 一組view（UI元件）：這些UI元件包括List、textbox、button；
2. Content Provider：提供一種機制，通過這個機制應用程式可是實現數據庫共享和互訪；
3. Resourse Manager：負責管理非代碼的訪問，如圖片、xml以及國際化資源文件；
4. Notification Manager：讓程式將警示資訊顯示在狀態欄上；
5. Activity Manager：管理著應用程式的生命週期，提供了應用程式頁面的退出機制，一個應用程式由多個頁面你組成，而每個頁面的單位就是Activity，android應用程式是由多個activity的交互構成；

庫（Libraries）和運行環境（Run Time）：
1. 系統C庫：一個從BSD 繼承來的標準C系統函數庫（LibC），他是專門基於嵌入式Linux的設備定制的；
2. 媒體庫：基於packet Video OpenCORE，該庫支援多種常用的音頻、視頻格式回放和錄製，同時支援靜態圖像文件；
3. Surface Manager：對顯示子系統的管理，並且為多個應用提供了2D和3D圖層的無縫融合；
4. Lib WebCore：一個最新的web瀏覽器引擎，    用來支援android瀏覽器和一個可嵌入的web試圖；
5. SGL：底層的2D圖引擎；
6. 3D libraries：基於openGL ES 1.0 apis實現，該庫可以用硬體3d加速或者使用高度優化的3D軟加速；
7. FreeType：點陣圖（bitmap）和vector字體顯示；
8. Sqlite：關係型數據庫；

每個android應用程式都在它自己的進程中運行，都擁有一個獨立的Dalvik虛擬機實例，Dalvik被設計成一個設備，可以同時高效的運行多個虛擬機設備。
Dalvik虛擬機執行的（.dex）Dalvik可執行文件，該格式文件針對小記憶體使用做了優化。
同時虛擬機是基於寄存器的，所有的類都經過由Java 編譯器，然後通過sdk的「dx」工具轉化成dex格式，有虛擬機執行。

Android應用程式介紹：
一般android應用程式包括以下四個部分：
Activity, Broadcast Intent Receiver, Service, Content Provider
1. Activity介紹：
Activity一般代表手機螢幕的一屏，相當於瀏覽器的一個頁面。當打開一個螢幕時，之前的那一個螢幕會被置為暫停狀態，並且壓入歷史堆棧中，用戶可以通過回退操作返回到以前打開過的螢幕。
開發時需要選擇行的移除沒有必要保留的螢幕，因為打開後的螢幕會保存在堆棧中
Android的生命週期：即「產生、運行、銷毀」
Intent和Intent Filter介紹：一個Intent就是一次對將要執行的操作的抽像描述，通過Intent可以在多個Activity之間進行跳轉，Intent兩個最重要的部分是動作（action）和動作對應的數據，典型的動作類型有，MAIN、view、pick、edit等，而動作對應的數據則以URI的形式表示；例如有兩個activity分別為A和B，要從A跳轉到B可以這樣寫
        Intent intent = new Intent(A.this, B.class);
        startActivity(intent);
與Intent有關聯的類叫做Intent Filters，如果Intent是一個請求，一個Intent Filters描述改元件所能相應Activity請求的能力。

2. Broadcast Intent Receiver介紹：
可以使用BroadcastReceiver來讓應用對外一個外部的事件作出響應。BroadcastReceiver通過NotificationManager來通知用戶這些事情發生了，BroadcastReceiver註冊的有兩種方式，一種是可以在AndroidManifest.xml中註冊，另一種可以在運行時的代碼中使用Context.registerReceiver()進行註冊。用戶還可以通過Context.sendBroadcast()將他們自己的intent broadcasts廣播給其他的應用程式。

3. Service介紹：
Service是一種程式，它可以運行很長的時間，相當於後台的一個服務，通過startService(Intent service)可以啟動一個Service，通過Context.bindService()可以綁定一個Service

4. Content Provider介紹：
數據在android當中是私有的，這些數據包括文件數據和數據庫數據以及其他類型的一些數據。兩個程式之間數據的交互是通過Content Provider來實現，一個Content Provider實現了一組標準的介面，能夠讓其他應用保存或讀取此Content Provider的各種數據類型。所以一個程式可以通過實現以個Content Provider的抽像介面將自己的數據暴露在外面，實現常見的介面有：
Query(URI,String[],String,String[],String)：通過關鍵字查詢；
Insert(Uri,ContentValues)：將一組數據插入到指定的地方 ；
Update(Uri,ContentValues,String,String[])：更新數據；
        Delete(Uri, String, Stringp[]) ：刪除數據；


/******************************************************************************/
Gravity設定元件顯示位置。程式語法如下
/******************************************************************************/
 <GridLayout android:gravity="center">
   ...
 </GridLayout>
常用值如下

設定值   說明
"center"                 水平及垂直置中
"center_horizontal"      水平置中
"center_vertical"        垂直置中
"right"                  靠螢幕置右
"left"                   靠螢幕置左
"top"                    靠螢幕置上
"botton"                 靠螢幕置下


/******************************************************************************/
Toast
/******************************************************************************/
在Android中, Toast是一個視圖(View), 它能顯示一個簡單的短資訊給用戶. 還有, 在一些簡單的調試工作中, 亦可以使用它來協助.

可能是最簡單的用法是(亦是我自己常用的用法):
Toast.makeText(this, "Test!", Toast.LENGTH_LONG).show();
 

/******************************************************************************/
[Android實例] 兩個Activity的跳轉，自定義翻頁效果
/******************************************************************************/
Java代碼 
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);   
startActivityForResult(intent, 11);   
               
//添加界面切換效果，注意只有Android的2.0(SdkVersion版本號為5)以後的版本才支援   
int version = Integer.valueOf(android.os.Build.VERSION.SDK);      
if(version  >= 5) {      
     overridePendingTransition(R.anim.zoomin, R.anim.zoomout); //此為自定義的動畫效果，下面兩個為系統的動畫效果      
     //overridePendingTransition(android.R.anim.fade_in,android.R.anim.fade_out);     
     //overridePendingTransition(android.R.anim.slide_in_left,android.R.anim.slide_out_right);   }    

下面為兩個自定義的動畫效果XML文件，存放位置為：res/anim/

1，動畫進入效果：zoomin.xml
<?xml version="1.0" encoding="utf-8"?>   
<set xmlns:android="http://schemas.android.com/apk/res/android"  
    android:interpolator="@android:anim/decelerate_interpolator">   
    <scale android:fromXScale="2.0" android:toXScale="1.0"  
           android:fromYScale="2.0" android:toYScale="1.0"  
           android:pivotX="50%p" android:pivotY="50%p"  
           android:duration="@android:integer/config_mediumAnimTime" />   
</set>  

動畫在退出市效果：zoomout.xml
<?xml version="1.0" encoding="utf-8"?>   
<set xmlns:android="http://schemas.android.com/apk/res/android"  
        android:interpolator="@android:anim/decelerate_interpolator"  
        android:zAdjustment="top">   
    <scale android:fromXScale="1.0" android:toXScale=".5"  
           android:fromYScale="1.0" android:toYScale=".5"  
           android:pivotX="50%p" android:pivotY="50%p"  
           android:duration="@android:integer/config_mediumAnimTime" />   
    <alpha android:fromAlpha="1.0" android:toAlpha="0"  
           android:duration="@android:integer/config_mediumAnimTime"/>   
</set>   


/******************************************************************************/
Android 開發教學筆記 - 批次、大量設定按鈕事件偵測(setOnClickListener)   ref: http://changyy.pixnet.net/blog/post/30902332
/******************************************************************************/
最近的案子很特別，除了一堆 Activity 外，每一個 Activity 裡頭又有一堆 Button/ImageButton 要處理，如果是依照一般教學文：
Button b = null;
if( ( b = (Button)findViewById( R.id.button01) ) != null )
        b.setOnClickListener( new Button.OnClickListener(){ /* ... */ } );
if( ( b = (Button)findViewById( R.id.button02) ) != null )
        b.setOnClickListener( new Button.OnClickListener(){ /* ... */ } );
...

假設有 20~30 個按鈕，就得用 findViewById 處理 20~30 次，程式碼就又臭又長。
另一種作法則是把每個 Button/ImageButton 都設定為同一個 Button.OnClickListener 來管理，透過 View.getId() 來偵測，的確可以省記憶體，但還是不免要把 layout 
上一堆按鈕都先 findViewById 一下，後來跟同事閒聊時，恰好提到用動態新增按鈕的方式，於是被 loop 關鍵字提醒一下，就來惡搞了：

void initOnClickListener() {

        int my_ids[] = {
                R.id.button01, R.id.button02, R.id.button03, ...
        };

        Button b = null;
        for( int i=0 ; i< ids.length ; ++i )
                if( ( b = (Button)findViewById( my_ids[i]) ) != null ) 
                        b.setOnClickListener(this);
}

public void onClick(View v) {
        switch( v.getId() ) {
                case R.id.button01:
                        break;
                case R.id.button02:
                        break;
                // ...
        }
}
其中的 this 就是指 MyActivity extends Activity implements OnClickListener，如此一來可以用最簡短的程式碼，很方便的初始化 layout 上頭的按鈕，也不用每個按鈕
都 new Button.OnClickListener 出來，也會省記憶吧。這樣管理 Button/ImageButton 還滿方便的，只需把要偵測的按鈕，將其 R.id.name 擺在 array 裡頭，跑 loop 來
解決就好啦。如果有用  PagerAdapter/ViewPager 實作 iOS PageControl 的話，更可以用多階層來管理：

final int cntView = 3;
int my_ids[][] = {
        {
                R.id.view1_btn1 , R.id.view1_btn2 , R.id.view1_btn3, ...
        } , 
        {
                R.id.view2_btn1 , R.id.view2_btn2 , R.id.view2_btn3, ...
        } ,
        {
                R.id.view3_btn1 , R.id.view3_btn2 , R.id.view3_btn3, ...
        }
}; 

for( int i=0 ; i<cntView ; ++i ) {
        for( int j=0 ; j<my_ids[i].length ; ++j ) {
                if( ( b = (Button)mPageView.get(i).findViewById( my_ids[i]) ) != null )
                        b.setOnClickListener( this );
        }
} 
其中 mPageView 用來記錄每個 page 的 Activity 囉。


/******************************************************************************/
Android 的權限設置大全
/******************************************************************************/
android.permission.ACCESS_CHECKIN_PROPERTIES 
//允許讀寫訪問」properties」表在checkin數據庫中，改值可以修改上傳 

android.permission.ACCESS_COARSE_LOCATION 
//允許一個程式訪問CellID或WiFi熱點來獲取粗略的位置 

android.permission.ACCESS_FINE_LOCATION 
//允許一個程式訪問精良位置(如GPS) 

android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 
//允許應用程式訪問額外的位置提供命令 

android.permission.ACCESS_MOCK_LOCATION 
//允許程式創建模擬位置提供用於測試 

android.permission.ACCESS_NETWORK_STATE 
//允許程式訪問有關GSM網路資訊 

android.permission.ACCESS_SURFACE_FLINGER 
//允許程式使用SurfaceFlinger底層特性 

android.permission.ACCESS_WIFI_STATE 
//允許程式訪問Wi-Fi網路狀態資訊 

android.permission.ADD_SYSTEM_SERVICE 
//允許程式發佈系統級服務 

android.permission.BATTERY_STATS 
//允許程式更新手機電池統計資訊 

android.permission.BLUETOOTH 
//允許程式連接到已配對的藍牙設備 

android.permission.BLUETOOTH_ADMIN 
//允許程式發現和配對藍牙設備 

android.permission.BRICK 
//請求能夠禁用設備(非常危險 

android.permission.BROADCAST_PACKAGE_REMOVED 
//允許程式廣播一個提示消息在一個應用程式包已經移除後 

android.permission.BROADCAST_STICKY 
//允許一個程式廣播常用intents 

android.permission.CALL_PHONE 
//允許一個程式初始化一個電話撥號不需通過撥號用戶界面需要用戶確認 

android.permission.CALL_PRIVILEGED 
//允許一個程式撥打任何號碼，包含緊急號碼無需通過撥號用戶界面需要用戶確認 

android.permission.CAMERA 
//請求訪問使用照相設備 

android.permission.CHANGE_COMPONENT_ENABLED_STATE 
//允許一個程式是否改變一個元件或其他的啟用或禁用 

android.permission.CHANGE_CONFIGURATION 
//允許一個程式修改當前設置，如本地化 

android.permission.CHANGE_NETWORK_STATE 
//允許程式改變網路連接狀態 

android.permission.CHANGE_WIFI_STATE 
//允許程式改變Wi-Fi連接狀態 

android.permission.CLEAR_APP_CACHE 
//允許一個程式清楚緩存從所有安裝的程式在設備中 

android.permission.CLEAR_APP_USER_DATA 
//允許一個程式清除用戶設置 

android.permission.CONTROL_LOCATION_UPDATES 
//允許啟用禁止位置更新提示從無線模組 

android.permission.DELETE_CACHE_FILES 
//允許程式刪除緩存文件 

android.permission.DELETE_PACKAGES 
//允許一個程式刪除包 

android.permission.DEVICE_POWER 
//允許訪問底層電源管理 

android.permission.DIAGNOSTIC 
//允許程式RW診斷資源 

android.permission.DISABLE_KEYGUARD 
//允許程式禁用鍵盤鎖 

android.permission.DUMP 
//允許程式返回狀態抓取資訊從系統服務 

android.permission.EXPAND_STATUS_BAR 
//允許一個程式擴展收縮在狀態欄,android開發網提示應該是一個類似Windows Mobile中的托盤程式 

android.permission.FACTORY_TEST 
//作為一個工廠測試程式，運行在root用戶 

android.permission.FLASHLIGHT 
//訪問閃光燈,android開發網提示HTC Dream不包含閃光燈 

android.permission.FORCE_BACK 
//允許程式強行一個後退操作是否在頂層activities 

android.permission.FOTA_UPDATE 
//暫時不瞭解這是做什麼使用的，android開發網分析可能是一個預留權限. 

android.permission.GET_ACCOUNTS 
//訪問一個帳戶列表在Accounts Service中 

android.permission.GET_PACKAGE_SIZE 
//允許一個程式獲取任何package佔用空間容量 

android.permission.GET_TASKS 
//允許一個程式獲取資訊有關當前或最近運行的任務，一個縮略的任務狀態，是否活動等等 

android.permission.HARDWARE_TEST 
//允許訪問硬體 

android.permission.INJECT_EVENTS 
//允許一個程式截獲用戶事件如按鍵、觸摸、軌跡球等等到一個時間流，android 開發網提醒算是hook技術吧 

android.permission.INSTALL_PACKAGES 
//允許一個程式安裝packages 

android.permission.INTERNAL_SYSTEM_WINDOW 
//允許打開窗口使用系統用戶界面 

android.permission.INTERNET 
//允許程式打開網路套接字 

android.permission.MANAGE_APP_TOKENS 
//允許程式管理(創建、催後、 z- order默認向z軸推移)程式引用在窗口管理器中 

android.permission.MASTER_CLEAR 
//目前還沒有明確的解釋，android開發網分析可能是清除一切數據，類似硬格機 

android.permission.MODIFY_AUDIO_SETTINGS 
//允許程式修改全局音頻設置 

android.permission.MODIFY_PHONE_STATE 
//允許修改話機狀態，如電源，人機介面等 

android.permission.MOUNT_UNMOUNT_FILESYSTEMS 
//允許掛載和反掛載文件系統可移動存儲 

android.permission.PERSISTENT_ACTIVITY 
//允許一個程式設置他的activities顯示 

android.permission.PROCESS_OUTGOING_CALLS 
//允許程式監視、修改有關播出電話 

android.permission.READ_CALENDAR 
//允許程式讀取用戶日曆數據 

android.permission.READ_CONTACTS 
//允許程式讀取用戶聯繫人數據 

android.permission.READ_FRAME_BUFFER 
//允許程式螢幕波或和更多常規的訪問幀緩衝數據 

android.permission.READ_INPUT_STATE 
//允許程式返回當前按鍵狀態 

android.permission.READ_LOGS 
//允許程式讀取底層系統日誌文件 

android.permission.READ_OWNER_DATA 
//允許程式讀取所有者數據 

android.permission.READ_SMS 
//允許程式讀取短資訊 

android.permission.READ_SYNC_SETTINGS 
//允許程式讀取同步設置 

android.permission.READ_SYNC_STATS 
//允許程式讀取同步狀態 

android.permission.REBOOT 
//請求能夠重新啟動設備 

android.permission.RECEIVE_BOOT_COMPLETED 
//允許一個程式接收到 

android.permission.RECEIVE_MMS 
//允許一個程式監控將收到MMS彩信,記錄或處理 

android.permission.RECEIVE_SMS 
//允許程式監控一個將收到短資訊，記錄或處理 

android.permission.RECEIVE_WAP_PUSH 
//允許程式監控將收到WAP PUSH資訊 

android.permission.RECORD_AUDIO 
//允許程式錄製音頻 

android.permission.REORDER_TASKS 
//允許程式改變Z軸排列任務 

android.permission.RESTART_PACKAGES 
//允許程式重新啟動其他程式 

android.permission.SEND_SMS 
//允許程式發送SMS短信 

android.permission.SET_ACTIVITY_WATCHER 
//允許程式監控或控制activities已經啟動全局系統中 

android.permission.SET_ALWAYS_FINISH 
//允許程式控制是否活動間接完成在處於後台時 

android.permission.SET_ANIMATION_SCALE 
//修改全局資訊比例 

android.permission.SET_DEBUG_APP 
//配置一個程式用於調試 

android.permission.SET_ORIENTATION 
//允許底層訪問設置螢幕方向和實際旋轉 

android.permission.SET_PREFERRED_APPLICATIONS 
//允許一個程式修改列表參數PackageManager.addPackageToPreferred() 和PackageManager.removePackageFromPreferred()方法 

android.permission.SET_PROCESS_FOREGROUND 
//允許程式當前運行程式強行到前台 

android.permission.SET_PROCESS_LIMIT 
//允許設置最大的運行進程數量 

android.permission.SET_TIME_ZONE 
//允許程式設置時間區域 

android.permission.SET_WALLPAPER 
//允許程式設置壁紙 

android.permission.SET_WALLPAPER_HINTS 
//允許程式設置壁紙hits 

android.permission.SIGNAL_PERSISTENT_PROCESSES 
//允許程式請求發送信號到所有顯示的進程中 

android.permission.STATUS_BAR 
//允許程式打開、關閉或禁用狀態欄及圖示Allows an application to open, close, or disable the status bar and its icons. 

android.permission.SUBSCRIBED_FEEDS_READ 
//允許一個程式訪問訂閱RSS Feed內容提供 

android.permission.SUBSCRIBED_FEEDS_WRITE 
//系統暫時保留改設置,android開發網認為未來版本會加入該功能。 

android.permission.SYSTEM_ALERT_WINDOW 
//允許一個程式打開窗口使用 TYPE_SYSTEM_ALERT，顯示在其他所有程式的頂層(Allows an application to open windows using the type TYPE_SYSTEM_ALERT, shown on top of all other applications. ) 

android.permission.VIBRATE 
//允許訪問振動設備 

android.permission.WAKE_LOCK 
//允許使用PowerManager的 WakeLocks保持進程在休眠時從螢幕消失 

android.permission.WRITE_APN_SETTINGS 
//允許程式寫入API設置 

android.permission.WRITE_CALENDAR 
//允許一個程式寫入但不讀取用戶日曆數據 

android.permission.WRITE_CONTACTS 
//允許程式寫入但不讀取用戶聯繫人數據 

android.permission.WRITE_GSERVICES 
//允許程式修改Google服務地圖 

android.permission.WRITE_OWNER_DATA 
//允許一個程式寫入但不讀取所有者數據 

android.permission.WRITE_SETTINGS 
//允許程式讀取或寫入系統設置 

android.permission.WRITE_SMS 
//允許程式寫短信 

android.permission.WRITE_SYNC_SETTINGS 
//允許程式寫入同步設置 

/******************************************************************************/
Android - 按鈕平均分配寬度 (rid of button padding)      from: http://androidgill.blogspot.tw/2011/12/android-rid-of-button-padding.html
/******************************************************************************/
如果想在畫面的「某一列」，放3個按鈕，而這3個按鈕要平均分配寬度，程式如下:
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="
horizontal" android:layout_width="fill_parent"
    android:layout_height="fill_parent">

    <Button android:id="@+id/button1" android:layout_height="wrap_content" android:text="11111" 
            android:layout_width="fill_parent" android:layout_weight="1"/>
            
    <Button android:id="@+id/button2" android:layout_height="wrap_content" android:text="2222222" 
            android:layout_width="fill_parent" android:layout_weight="1"/>
            
    <Button android:id="@+id/button3" android:layout_height="wrap_content" android:text="3333333333" 
            android:layout_width="fill_parent" android:layout_weight="1"/>

</LinearLayout>
如果不要按鈕之間有padding，有幾種作法

(1) 把padding設負值

(2) 給Button 設android:background="#000cab" 隨便給一個顏色，但是高度會變小，要自己設一下

(3) 自己做一張.9.png圖，給Button 設android:background="你的圖"


/******************************************************************************/
Android - 偵測螢幕方向 (ORIENTATION)
/******************************************************************************/
如果你想偵測目前手機的方向是直式還是橫式，程式如下:

        if (getResources().getConfiguration().orientation == 
            Configuration.ORIENTATION_PORTRAIT){
            //直式
        }
        if (getResources().getConfiguration().orientation == 
            Configuration.ORIENTATION_LANDSCAPE){
            //橫式
        }


/******************************************************************************/
Android - 取得螢幕大小(screen size)
/******************************************************************************/
在Activity底下，使用下列程式碼

Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
int width = display.getWidth(); 
int height = display.getHeight();


/******************************************************************************/
Android - Activity設計建議(1)
/******************************************************************************/
有關設計建議的詳細內容請參考官網說明 
(1)如果你的activity只想被自己設計的application使用，而不想被別的application使用，那就不要建立intent filter,直接使用explicit intents，例如:
   Intent it = new Intent();
   it.setClass(this,MyActivity.class);
   startActivity(it);
這樣就沒有別的applicaton會因為誤發了一個intent而把MyActivity給執行起來。使用intent filter會發佈到Android系統上，讓別的application也有機會執行。

(2)使用intent要特別注意，如果這個intent要呼叫的apk是第三方程式(意即可能被移除)，那startActivity()很有可能會產生Exception。兩種解決方式
   (1) try{
           startActivity();
       }catch(ActivityNotFoundException e){
           //do something if the apk is uninstalled
       }
   (2) 利用package manager確定這個apk是否還在Android裝置裡面，做法可參考這篇文章

(3)如果你的Activity可以單獨執行，應該讓使用者在Launcher可以執行它。也就是application中應該有一個activity要有
            <intent-filter>
                <action android:name="android.intent.action.MAIN"></action>
                <category android:name="android.intent.category.DEFAULT"></category>
            </intent-filter>

(4)相較於上者，如果你有一個不常用的小程式，尤其是系統內也內建有類似功能的程式，或者這個小程式是依附在其他程式底下，那也許不用大費周章的為他在Launcher設立
一個可以執行的icon。只要有intent filter可以在適當的時候被呼叫起來就好了。

(5) 相較於(3)和(4)，如果你有兩支activity可獨立執行，但是有很多資料、程式碼是可以共用的，那可以考慮寫成一支application但是有兩個可以在Launcher執行的icon，
像是Camera 和 Camcorder。在AndroidManifest.xml中，這兩支activity都有
                  <action android:name="android.intent.action.MAIN" />
                  <category android:name="android.intent.category.DEFAULT" />
但是要注意的是要把taskAffinity分開，兩者才不會互相影響。例如
android:taskAffinity="android.task.camera" 和 android:taskAffinity="android.task.Camcorder"，

(6) 如果你的activity會送資料給其它程式，應該設計一個選項讓user知道。利如Gallery會有Share的功能，按下後可以把資料 送給Facebook,Mail,Messages,Twitter....等
。這個時候要特別注意建議(2)有可能發生的錯誤。當想要啟動一個 Activity時，如果會再次返回原Activity並得到一些資料，可以使用startActivityResult()。如果不需要
在返回時取得資 料就可以用startActivity()

(7) 你的Activity可以依特殊需求設計成Widget，而且Widget除了可以放在Home上面之外，也可以放在其它的application上，如果一來可以依需求不停的update內容。

(8) 如果你的Activity會被其它application執行，為了讓activity不會影響該application返回(按下return key)的行為，launch mode盡量使用standard 或 singleTop 而不
要使用 singleTask or singleInstanc。Launch mode四者的差別請參考http://slashgill.blogspot.com/search/label/launchMode

(9) 當使用者由Activity A 按下notification到Activity B後，若按下 Back Key 時應該要能正確返回 Activity A。這時候為了避免Activity B按下Back Key會執行該
application的其它activity(如果這些activity曾被執行而留在activity stack裡面的話)，因此要把Activity B的taskAffinity設定空字串(不可以不設定)

(10)相較於上面的另一種作法是用在執行Activity B的時候，先設定FLAG_ACTIVITY_CLEAR_TOP和ACTIVITY_NEW_TASK，這樣到時候從Activity B按下Back Key時，就會回到
Activity A

(11)盡可能不要改變Back Key的行為，才不會影響使用者原本的操作習慣。


/******************************************************************************/
Android應用開發中模擬按HOME鍵效果
/******************************************************************************/
Android應用開發中， 有一種場景，就是我們不希望用戶直接按Back鍵退出Activity，而是希望應用隱藏到後台，類似於按Home鍵的效果。
 
下面提供代碼示例，請參考。
public boolean onKeyDown(int keyCode, KeyEvent event) {  
    if (keyCode == KeyEvent.KEYCODE_BACK) {  
        Intent intent = new Intent(Intent.ACTION_MAIN);  
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
        intent.addCategory(Intent.CATEGORY_HOME);  
        startActivity(intent);  
        return true;  
    }  
    return super.onKeyDown(keyCode, event);  
}  


/******************************************************************************/
android實現手機震動功能
/******************************************************************************/
[java] view plaincopy
import android.app.Activity;  
import android.app.Service;  
import android.os.Vibrator;  
  
public class TipHelper {   
    public static void Vibrate(final Activity activity, long milliseconds) {  
        Vibrator vib = (Vibrator) activity.getSystemService(Service.VIBRATOR_SERVICE);  
        vib.vibrate(milliseconds);  
    }  
    public static void Vibrate(final Activity activity, long[] pattern,boolean isRepeat) {  
        Vibrator vib = (Vibrator) activity.getSystemService(Service.VIBRATOR_SERVICE);  
        vib.vibrate(pattern, isRepeat ? 1 : -1);  
    }  
}  

還需要在AndroidManifest.xml 中添加震動權限：
[html] view plaincopy
<uses-permission android:name="android.permission.VIBRATE" />  
通過上面操作，我們可以使用TipHelper所定義的函數了。兩個Vibrate函數的參數簡單介紹如下：
final Activity activity  ：調用該方法的Activity實例
long milliseconds ：震動的時長，單位是毫秒
long[] pattern   ：自定義震動模式 。數組中數字的含義依次是[靜止時長，震動時長，靜止時長，震動時長。。。]時長的單位是毫秒
boolean isRepeat ： 是否反覆震動，如果是true，反覆震動，如果是false，只震動一次


/******************************************************************************/
獲取移動設備的IP地址：  from: http://blog.csdn.net/aomandeshangxiao/article/details/7302343
/******************************************************************************/
[java] view plaincopy
public class Tools {  
    public static String getLocalIpAddress() {    
        try {    
            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {    
                NetworkInterface intf = en.nextElement();    
                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {    
                    InetAddress inetAddress = enumIpAddr.nextElement();    
                    if (!inetAddress.isLoopbackAddress()) {    
                        return inetAddress.getHostAddress().toString();    
                    }    
                }    
            }    
        } catch (SocketException ex) {    
            Log.e("出錯啦", ex.toString());    
        }    
        return null;    
    }    
}  
然後  
        WifiManager wm = (WifiManager)getSystemService(WIFI_SERVICE);  
        WifiInfo wi = wm.getConnectionInfo();  
        System.out.println("IP地址是："+Tools.getLocalIpAddress());  
        System.out.println("SSID："+wi.getSSID());  
最後記得加兩個權限  
    <uses-permission android:name="android.permission.INTERNET"/>  
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>  


/******************************************************************************/
將TabWidget顯示在螢幕下方
/******************************************************************************/
[java] view plaincopy
<span style="font-size:16px;">設置TabWidget的屬性 android:layout_alignParentBottom="true"</span>  
為了讓tabHost顯示在下方，要將RadioGroup的layout_gravity設置為bottom，再將FrameLayout的 layout_weight設置為1，這樣就可以將RadioGroup撐到最下方。
style="@style/main_tab_bottom"裡面定義了樣式文件    


/******************************************************************************/
android自動跳轉         from: http://blog.csdn.net/aomandeshangxiao/article/details/7537721
/******************************************************************************/
有些時候需要類似這樣的功能，在一個頁面停留2秒後，跳轉到另外一個頁面！
第一種方法：
[java] view plaincopy
Timer timer = new Timer();  
  
TimerTask timerTask = new TimerTask() {  
         
        @Override  
        public void run() {  
                // 你要干的活  
                 
        }  
};  
timer.schedule(timerTask, 1000 * 2); //2秒後執行  
在run()方法裡面寫上你的跳轉就可以了。

第二種方法：
[java] view plaincopy
private final int SPLASH_DISPLAY_LENGHT = 2000;  
  
        @Override  
        public void onCreate(Bundle savedInstanceState) {  
                super.onCreate(savedInstanceState);  
                this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,    
                WindowManager.LayoutParams.FLAG_FULLSCREEN);    
                setContentView(R.layout.splash);  
                new Handler().postDelayed(new Runnable() {  
                        @Override  
                        public void run() {  
                                Intent intent = new Intent(Splash.this, XXX.class);  
                                Splash.this.startActivity(intent);  
                                overridePendingTransition(R.anim.fade_in, R.anim.fade_out);  
                                Splash.this.finish();  
                        }  
  
                }, SPLASH_DISPLAY_LENGHT);  
        }  
使用handler延遲2秒後跳轉。


/******************************************************************************/
Android螢幕解鎖和點亮螢幕       from: http://blog.csdn.net/aomandeshangxiao/article/details/7537721
/******************************************************************************/
最近在做一個鬧鐘的項目，當鬧鐘響起的時候需要用到自動解鎖和點亮螢幕，因此記錄一下解螢幕鎖與點亮螢幕的代碼：

[java] view plaincopy
KeyguardManager  km= (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE); //得到鍵盤鎖管理器對像  
KeyguardLock kl = km.newKeyguardLock("unLock"); //參數是LogCat裡用的Tag  
  
kl.disableKeyguard(); //解鎖  
  
PowerManager pm=(PowerManager) getSystemService(Context.POWER_SERVICE);//獲取電源管理器對像  
PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, "bright");  
//獲取PowerManager.WakeLock對像,後面的參數|表示同時傳入兩個值,最後的是LogCat裡用的Tag  
wl.acquire();//點亮螢幕  
wl.release();//釋放  
  
要實現自動解鎖和點亮螢幕的功能則需要在AndroidManifest.xml添加權限:  
  
<uses-permission android:name="android.permission.WAKE_LOCK" />  
 <uses-permission android:name="android.permission.DISABLE_KEYGUARD" />  


/******************************************************************************/
用16進製表示的顏色代碼表        from: http://blog.csdn.net/aomandeshangxiao/article/details/6616935
/******************************************************************************/
之前公司工程師在開放iOS的app時，問我一個問題說：他問客戶在app上的元件要什麼樣的顏色，客戶給他了幾個代碼如 Button Color:5C4033...
他問我這是啥東西，我說這就是你要的顏色。他一臉疑狐。
以下來說明一下：
這些值以十六進位表示，前兩位數字代表紅色值；接下來兩位表示綠色；最後兩位表示藍色。
每個紅色、綠色或藍色值可以在00（沒有那種顏色）到FF(完全是那種顏色）之間變化。
 
某些時候我們需要流行顏色及其RGB值， 下面列出一些流行的顏色及其RGB值。
可以使用這些值改變背景色、文本顏色和鏈接顏色。
白色：FFFFFF 
黑色：000000 
紅色：FF0000
綠色：00FF00 
藍色：0000FF
洋紅：FF00FF 
墨綠：00FFFF 
黃色：FFFF00
 
愛麗絲蘭：F0F8FF 
碧綠：70DB93 
巧克力色：5C3317 
藍紫色：9F5F9F 
黃銅：B5A642 
亮金：D9D919 
褐色：A62AA2 
青銅：8C7853 
青銅2：A67D3D 
藏青：5F9F9F 
亮銅：D98719 
銅色：B87333 
珊瑚色：FF7F00 
矢車菊蘭：42426F
深褐色：5C4033 
深綠色：2F4F2F 
深銅綠色：4A766E 
深橄欖綠：4F4F2F 
紫色：9932CD 
深紫色：871F78 
深石板藍：6B238E 
深石板灰：2F4F4F 
深黃褐色：97694F 
深藍玉色：7093DB
暗木色：855E42 
暗灰：545454 
暗玫瑰色：856363
長石色：D19275 
磚紅色：8E2323 
草綠：238E23 
金色：CD7F32 
秋葉色：DBDB70 
灰色:C0C0C0 
銅綠色：527F76 
黃綠色：93DB70 
軍綠：215E21 
印第安紅色：4E2F2F 
土黃：9F9F5F
淺藍：C0D9D9 
淺灰：A8A8A8 
淺銅藍：8F8FBD 
淺木色：E9C2A6 
淺綠：32CD32
橙色：E47833 
栗色：8E236B
中綠：32CD99 
中藍：3232CD 
中草綠：6B8E23 
中秋葉色：EAEAAE 
中紫色：9370DB 
中海綠：426F42 
中石板藍：7F00FF 
中春綠：7FFF00 
中藍玉色：70DBDB 
中紫紅色：DB7093 
中木色：A68064
夜藍色：2F2F4F 
海藍色：23238E 
氖藍色：4D4DFF 
氖粉紅色：FF6EC7 
新夜藍色：00009C 
新黃褐色：EBC79E 
暗金色：CFB53B 
橘色：FF7F00 
橘紅：FF2400 
淡紫：DB70DB 
淡綠： 8FBC8F 
粉紅：BC8F8F 
棕色：EAADEA 
石英色：D9D9F3 
富蘭色：5959AB 
橙紅色：6F4242 
猩紅：8C1717 
海綠：238E68 
半甜巧克力色:6B4226 
赭色：8E6B23 
銀色：E6E8FA 
天藍：3299CC 
石板藍：007FFF 
香粉紅：FF1CAE 
春綠：00FF7F 
鋼藍：236B8E 
夏天的天空：38B0DE 
黃褐色：DB9370 
藍玉色：ADEAEA 
暗褐色：5C4033 
亮灰：CDCDCD 
紫羅蘭色：4F2F4F 
紫紅：CC3299 
麥色：D8D8BF 
暗黃：99CC32


/******************************************************************************/
通過AudioManager 設置調整系統各項音量(鈴聲 媒體等)
/******************************************************************************/
前面講過AudioManager可以修改系統的情景模式,其實看它名字,就知道Android系統的音量也是由它管理的.
下面介紹幾個AudioManager的幾個音量調整方面的方法.
首先是得到AudioManager實例:
AudioManager am=(AudioManager)getSystemService(Context.AUDIO_SERVICE);

調整音量方法有兩種,一種是漸進式,即像手動按音量鍵一樣,一步一步增加或減少,另一種是直接設置音量值.
首先是步進的方法:
public void adjustStreamVolume (int streamType, int direction, int flags)
am.adjustStreamVolume (AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, AudioManager.FLAG_SHOW_UI);
解釋一下三個參數
第一個streamType是需要調整音量的類型,這裡設的是媒體音量,可以是:
STREAM_ALARM 警報
STREAM_MUSIC 音樂回放即媒體音量
STREAM_NOTIFICATION 窗口頂部狀態欄Notification,
STREAM_RING 鈴聲
STREAM_SYSTEM 系統
STREAM_VOICE_CALL 通話
STREAM_DTMF 雙音多頻,不是很明白什麼東西
第二個direction,是調整的方向,增加或減少,可以是:
ADJUST_LOWER 降低音量
ADJUST_RAISE 升高音量
ADJUST_SAME 保持不變,這個主要用於向用戶展示當前的音量
第三個flags是一些附加參數,只介紹兩個常用的
FLAG_PLAY_SOUND 調整音量時播放聲音
FLAG_SHOW_UI 調整時顯示音量條,就是按音量鍵出現的那個

然後是直接設置音量值的方法:
public void setStreamVolume (int streamType, int index, int flags)
am.setStreamVolume(AudioManager.STREAM_MUSIC, am.getStreamMaxVolume(AudioManager.STREAM_MUSIC), AudioManager.FLAG_PLAY_SOUND);
第一個和第三個參數與上面的相同,第二個參數是一個音量的int值,getStreamMaxVolume(int streamType)得到的是該類型音量的最大值,
可以根據這個值計算你需要的音量,我這裡直接調到最大.


/******************************************************************************/
關於mediaplay中緩衝和seekbar同步的問題  from: http://www.eoeandroid.com/thread-34350-1-1.html
/******************************************************************************/
最近在看關於流媒體的內容，然後看到大部分處理流媒體的方案是把視頻或者音樂先下載下來，然後再setSecondaryProgress顯示再seekbar上面。
我看到在資料裡面有一個listener是setOnBufferingUpdateListener，然後我就在想能不能利用這個再seekbar上顯示緩衝進度。
我是個新手，寫了如下的代碼。但是存在問題，就是在stop之後進度條SecondaryProgress的值被記錄了下來，當再次play的時候，發現seekbar會在現在的進度和現在進度加
上過去進度的地方來回的取值，一直搞不明白是為什麼，把代碼貼出來大家看看，我以為是handler的問題，但是我已經用了removeCallbacks的命令清空pending post，為什
麼還會有問題呢~~~希望大家解答，謝謝

package OnlineMusicPlayer_Ver001.leewind;

import android.app.Activity;
import android.content.Context;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnBufferingUpdateListener;
import android.media.MediaPlayer.OnCompletionListener;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.TextView;

public class OnlineMusicPlayer extends Activity {
    /** Called when the activity is first created. */
        private Button buttonPlay, buttonPause, buttonContinuePlay, buttonStop,buttonVolUp, buttonVolDown,buttonReplay;
        private TextView textState;
        private MediaPlayer mediaPlayer;
        private AudioManager audioManager;
        private SeekBar processSeekBar;
        private static final int[] visibilitySetting={View.VISIBLE, View.GONE};
        private static final String[] Song={"http://www.rzk9.com/UserFiles/Blog/tdrmusic/UploadFiles/20100914022110953.mp3", 
                "http://f4.wretch.yimg.com/katieshin/12/1136569569.mp3"};
        private int downLoadProgress;
        private int bufferingProgress;
        private int songProgress;
                
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
                
        buttonPlay=(Button)findViewById(R.id.play);
        buttonContinuePlay=(Button)findViewById(R.id.continuePlay);
        buttonPause=(Button)findViewById(R.id.pause);
        buttonStop=(Button)findViewById(R.id.stop);
        buttonVolUp=(Button)findViewById(R.id.volup);
        buttonVolDown=(Button)findViewById(R.id.voldown);
        buttonReplay=(Button)findViewById(R.id.replay);
        textState=(TextView)findViewById(R.id.state);
        processSeekBar=(SeekBar)findViewById(R.id.process);
        
        mediaPlayer=new MediaPlayer();
        audioManager=(AudioManager)getSystemService(Context.AUDIO_SERVICE);
        mediaPlayerInitialization();
        
        
        /*widget state*/                        
        buttonPlay.setOnClickListener(buttonPlayOnClickListener);
        buttonContinuePlay.setOnClickListener(buttonContinuePlayOnClickListener);
        buttonPause.setOnClickListener(buttonPauseOnClickListener);
        buttonStop.setOnClickListener(buttonStopOnClickListener);
        buttonVolUp.setOnClickListener(buttonVolUpOnClickListener);
        buttonVolDown.setOnClickListener(buttonVolUpOnClickListener);
        buttonReplay.setOnClickListener(buttonReplayOnClickListener);
                 
    }
       
    Handler handler=new Handler();
    Runnable updateThread= new Runnable() {                        
                @Override
                public void run() {
                        // TODO Auto-generated method stub
                        
                        bufferingProgress=downLoadProgress*processSeekBar.getMax()/100;
                        processSeekBar.setSecondaryProgress(bufferingProgress);
                        
                        songProgress=mediaPlayer.getCurrentPosition();
                        processSeekBar.setProgress(songProgress);
                        handler.postDelayed(updateThread, 100);
                }
        };
    
    OnSeekBarChangeListener processSeekBarListener=new OnSeekBarChangeListener(){

                @Override
                public void onProgressChanged(SeekBar seekBar, int progress,
                                boolean fromUser) {
                        // TODO Auto-generated method stub
                        if (fromUser==true) {
                                mediaPlayer.seekTo(progress);
                        }

                }

                @Override
                public void onStartTrackingTouch(SeekBar seekBar) {
                        // TODO Auto-generated method stub
                        
                }

                @Override
                public void onStopTrackingTouch(SeekBar seekBar) {
                        // TODO Auto-generated method stub
                        int songProcess=seekBar.getProgress();                        
                        mediaPlayer.seekTo(songProcess);
                }
            
    };
       
    OnCompletionListener mediaPlayerOnCompletionListener= new OnCompletionListener() {
                
                @Override
                public void onCompletion(MediaPlayer mp) {
                        // TODO Auto-generated method stub
                                handler.removeCallbacks(updateThread);
                                mediaPlayer.stop();
                                mediaPlayerInitialization();
                        }
        };
    
    private void mediaPlayerInitialization() {
                // TODO Auto-generated method stub
            buttonPlay.setEnabled(true);
        buttonPlay.setVisibility(visibilitySetting[0]);
        buttonReplay.setVisibility(visibilitySetting[1]);
        buttonContinuePlay.setVisibility(visibilitySetting[1]);
        buttonPause.setVisibility(visibilitySetting[1]);
        buttonStop.setVisibility(visibilitySetting[1]);
        buttonVolUp.setVisibility(visibilitySetting[1]);
        buttonVolDown.setVisibility(visibilitySetting[1]);
        processSeekBar.setMax(mediaPlayer.getDuration());
        
        Uri uri=Uri.parse(Song[0]);
        mediaPlayer=MediaPlayer.create(OnlineMusicPlayer.this,uri);
        
        processSeekBar.setMax(mediaPlayer.getDuration());
        songProgress=0;
        processSeekBar.setProgress(songProgress);
        downLoadProgress=0;
        bufferingProgress=0;
        processSeekBar.setSecondaryProgress(bufferingProgress);
        processSeekBar.setOnSeekBarChangeListener(processSeekBarListener);
        textState.setText("-- idle --");                                              
        }

        OnClickListener buttonPlayOnClickListener = new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                
                                mediaPlayer.setLooping(false);
                                mediaPlayer.start();
                                mediaPlayer.setOnBufferingUpdateListener(bufferingDownloadListener);
                                mediaPlayer.setOnCompletionListener(mediaPlayerOnCompletionListener);                                
                                                                
                                textState.setText("-- Playing --");
                                handler.post(updateThread);
                                                                                                
                                buttonPlay.setVisibility(visibilitySetting[1]);
                                buttonContinuePlay.setVisibility(visibilitySetting[1]);
                                buttonReplay.setVisibility(visibilitySetting[0]);
                                buttonPause.setVisibility(visibilitySetting[0]);
                                buttonStop.setVisibility(visibilitySetting[0]);
                                buttonVolUp.setVisibility(visibilitySetting[0]);
                                buttonVolDown.setVisibility(visibilitySetting[0]);                        
                                
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }
                }
        };
        
        OnBufferingUpdateListener bufferingDownloadListener = new OnBufferingUpdateListener(){

                @Override
                public void onBufferingUpdate(MediaPlayer mp, int percent) {
                        // TODO Auto-generated method stub
                        downLoadProgress=percent;                        
                }
                
        };
        
        OnClickListener buttonReplayOnClickListener =new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                mediaPlayer.stop();
                                handler.removeCallbacks(updateThread);
                                mediaPlayerInitialization();
                                mediaPlayer.setLooping(false);
                                mediaPlayer.start();
                                mediaPlayer.setOnBufferingUpdateListener(bufferingDownloadListener);
                                mediaPlayer.setOnCompletionListener(mediaPlayerOnCompletionListener);                
                                                                                                
                                textState.setText("-- Playing --");
                                handler.post(updateThread);
                                                                                                
                                buttonPlay.setVisibility(visibilitySetting[1]);
                                buttonContinuePlay.setVisibility(visibilitySetting[1]);
                                buttonReplay.setVisibility(visibilitySetting[0]);
                                buttonPause.setVisibility(visibilitySetting[0]);
                                buttonStop.setVisibility(visibilitySetting[0]);
                                buttonVolUp.setVisibility(visibilitySetting[0]);
                                buttonVolDown.setVisibility(visibilitySetting[0]);        
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }                        
                }
        };
        
        OnClickListener buttonContinuePlayOnClickListener= new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                mediaPlayer.start();
                                textState.setText("-- Playing --");
                                
                                buttonPlay.setVisibility(visibilitySetting[1]);
                                buttonContinuePlay.setVisibility(visibilitySetting[1]);
                                buttonReplay.setVisibility(visibilitySetting[0]);
                                buttonPause.setVisibility(visibilitySetting[0]);
                                buttonStop.setVisibility(visibilitySetting[0]);
                                buttonVolUp.setVisibility(visibilitySetting[0]);
                                buttonVolDown.setVisibility(visibilitySetting[0]);
                    } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }

                }
        };
        
        OnClickListener buttonPauseOnClickListener=new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                mediaPlayer.pause();
                                textState.setText("-- Pause --");
                                                                                        
                        buttonPlay.setVisibility(visibilitySetting[1]);
                                buttonContinuePlay.setVisibility(visibilitySetting[0]);
                                buttonReplay.setVisibility(visibilitySetting[0]);
                                buttonPause.setVisibility(visibilitySetting[1]);
                                buttonStop.setVisibility(visibilitySetting[0]);
                                buttonVolUp.setVisibility(visibilitySetting[1]);
                                buttonVolDown.setVisibility(visibilitySetting[1]);
                                
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }
                        
                }
        };
        
        OnClickListener buttonStopOnClickListener=new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {                                                                
                                mediaPlayer.stop();
                                textState.setText("-- Stop --");
                                handler.removeCallbacks(updateThread);
                                mediaPlayerInitialization();
                                                                
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }
                        
                }
        };
        
        OnClickListener buttonVolUpOnClickListener =new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                audioManager.adjustVolume(AudioManager.ADJUST_RAISE, 0);
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }                        
                }
        };
        
        OnClickListener buttonVolDownOnClickListener = new OnClickListener() {
                
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        try {
                                audioManager.adjustVolume(AudioManager.ADJUST_LOWER, 0);
                        } catch (IllegalStateException e) {
                                // TODO: handle exception
                                e.printStackTrace();
                        }                
                }
        };
}


/******************************************************************************/
自定義seekbar的樣式     from: http://www.eoeandroid.com/thread-82075-1-1.html
/******************************************************************************/
在xml佈局文件中：
<SeekBar android:id="@android:id/progress"
        style="?android:attr/progressBarStyleHorizontal"
        android:progressDrawable="@drawable/seekbar_style"
        android:thumb="@drawable/thumb"
        android:layout_width="fill_parent"
        android:layout_height="23dip"
        android:paddingLeft="25dip"
        android:paddingRight="25dip"  
        android:paddingBottom="4dip" />

最重要的是：
android:progressDrawable="@drawable/seekbar_style"     
android:thumb="@drawable/thumb"  

seekbar_style.xml的定義
<?xml version="1.0" encoding="UTF-8"?>     
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">     
   <item android:id="@android:id/background">     
      <shape>     
         <corners android:radius="10dip" />     
         <gradient     
             android:startColor="#ffffffff"  
             android:centerColor="#ff000000"     
             android:endColor="#ff808A87"    
             android:centerY="0.45"     
             android:angle="270"/>     
      </shape>     
   </item>     
      
   <item android:id="@android:id/progress">     
       <clip>     
          <shape>     
              <corners android:radius="10dip" />     
              <gradient     
                  android:startColor="#ffffffff"  
                  android:centerColor="#ffFFFF00"     
                  android:endColor="#ffAABD00"    
                  android:centerY="0.45"     
                  android:angle="270"/>     
          </shape>     
       </clip>     
   </item>     
</layer-list>

thumb.xml的定義
<?xml version="1.0" encoding="UTF-8"?>     
<selector xmlns:android="http://schemas.android.com/apk/res/android">           
    <!-- 按下狀態 -->    
    <item       
        android:state_pressed="true"       
        android:drawable="@drawable/xxxxxxxxxx" />      
                
    <!-- 普通無焦點狀態 -->    
   <item       
        android:state_focused="false"       
        android:state_pressed="false"     
        android:drawable="@drawable/xxxxxxx" />   
  
上面的xxxxxxx是圖片
</selector>

效果圖如下： 自行測試。


/******************************************************************************/
SeekBar 自定義樣式後的圓角      from : http://www.eoeandroid.com/thread-60655-1-1.html
/******************************************************************************/
<SeekBar android:id="@+id/playgauge"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:progressDrawable="@drawable/seekbar_style"
    android:thumb="@drawable/thumb"
    android:max="100000"
    android:progress="0"
    android:secondaryProgress="0"
    android:scrollbarStyle="insideOverlay"
    />

<?xml version="1.0" encoding="UTF-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">     
    <!-- 按下狀態-->
    <item
    android:state_focused="true"
    android:state_pressed="true"
    android:drawable="@drawable/playgaugedot" />

    <!-- 普通無焦點狀態 -->
    <item
    android:state_focused="false"
    android:state_pressed="false"
    android:drawable="@drawable/playgaugedot" />

    <!-- 有焦點狀態-->
    <item
    android:state_focused="true"
    android:state_pressed="false"
    android:drawable="@drawable/playgaugedot" />

    <!-- 有焦點 -->
    <item
    android:state_focused="true"
    android:drawable="@drawable/playgaugedot" />
/selector>


<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@android:id/background"
          android:drawable="@drawable/playgaugebackground" />
         <item android:id="@android:id/secondaryProgress">
    <clip android:drawable="@drawable/playgauge" />
        </item>
    <item android:id="@android:id/progress"
          android:drawable="@drawable/playgauge">
    </item>
</layer-list>



/******************************************************************************/
模組化佈局              from: http://blog.chinaunix.net/uid-26727976-id-3200883.html
/******************************************************************************/
所謂,模組化佈局就是要你熟悉使用<include /> 這個標籤!
一個經典的Tab類佈局由三部分組成,我們可以根據這三部分創建三個可以重用的佈局
head_menu.xml
content_showweibo.xml
bottom_menu.xml
然後我們可以很靈活的組合我們要顯示的,例如要完成上面的那個weibo佈局
<?xml version="1.0" encoding="utf-8"?> 
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    android:orientation="vertical" > 
    <include android:id="@+id/head_menu" layout="@layout/head_menu" /> 
    <include android:id="@+id/content" layout="@layout/content_showweibo" /> 
    <include android:id="@+id/bottom_menu" layout="@layout/bottom_menu" /> 
</LinearLayout>
 
熟練的使用<include />標籤就可以大大的減少我們日後都維護工作!


/******************************************************************************/
在Android中調用圖片、視頻、音頻、錄音、拍照 
/******************************************************************************/
//選擇圖片 requestCode 返回的標識
Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT); //"android.intent.action.GET_CONTENT"
innerIntent.setType(contentType); //查看類型 String IMAGE_UNSPECIFIED = "image/xxx";
Intent wrapperIntent = Intent.createChooser(innerIntent, null);
((Activity) context).startActivityForResult(wrapperIntent, requestCode);
 
//視頻
Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT);
innerIntent.setType(contentType); //String VIDEO_UNSPECIFIED = "video/xxx";
Intent wrapperIntent = Intent.createChooser(innerIntent, null);
((Activity) context).startActivityForResult(wrapperIntent, requestCode);
 
//添加音頻
Intent innerIntent = new Intent(Intent.ACTION_GET_CONTENT);
innerIntent.setType(contentType); //String VIDEO_UNSPECIFIED = "video/xxx";
Intent wrapperIntent = Intent.createChooser(innerIntent, null);
((Activity) context).startActivityForResult(wrapperIntent, requestCode);
 
//錄音
Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
intent.setType(ContentType.AUDIO_AMR); //String AUDIO_AMR = "audio/amr";
intent.setClassName("com.android.soundrecorder",
"com.android.soundrecorder.SoundRecorder");
((Activity) context).startActivityForResult(intent, requestCode);
 
//拍攝視頻
int durationLimit = getVideoCaptureDurationLimit(); //SystemProperties.getInt("ro.media.enc.lprof.duration", 60);
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0);
intent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, sizeLimit);
intent.putExtra(MediaStore.EXTRA_DURATION_LIMIT, durationLimit);
startActivityForResult(intent, REQUEST_CODE_TAKE_VIDEO);
 
//拍照 REQUEST_CODE_TAKE_PICTURE 為返回的標識
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //"android.media.action.IMAGE_CAPTURE";
intent.putExtra(MediaStore.EXTRA_OUTPUT, Mms.ScrapSpace.CONTENT_URI); // output,Uri.parse("content://mms/scrapSpace");
startActivityForResult(intent, REQUEST_CODE_TAKE_PICTURE);


/******************************************************************************/
Android的Intent用法     from: http://blog.chinaunix.net/uid-26727976-id-3159166.html
/******************************************************************************/
如果是從BroadcastReceiver 啟動一個新的Activity , 不要忘記i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
public class MyReceiver extends BroadcastReceiver{
        public static final String action="acc";
        public void onReceive(Context context, Intent intent) {
                Intent i=new Intent(context,Receivered.class);
                i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(i);
        }
}

1. 指定action和type
// SIM import
Intent importIntent = new Intent(Intent.ACTION_VIEW);
importIntent.setType("vnd.android.cursor.item/sim-contact");
importIntent.setClassName("com.android.phone", "com.android.phone.SimContacts");
menu.add(0, 0, 0, R.string.importFromSim)
.setIcon(R.drawable.ic_menu_import_contact)
.setIntent(importIntent);

2. 指定act ion, da ta和type
(1)隱式查找type
示例代碼：
uri: content://simcontacts/simPeople/(id)
intent = new Intent("android.intent.action.SIMEDIT",uri);
startActivity(intent);
程式會很據data中的uri去查找匹配的type（必須的）
provider中的getType()
case SIM_PEOPLE_ID:
return "vnd.android.cursor.item/sim-contact";
配置文件中的filter設定
AndroidManifest.xml
<intent-filter>
<action android:name="android.intent.action.SIMEDIT" />
<category android:name="android.intent.category.DEFAULT" />
<data android:mimeType="vnd.android.cursor.item/sim-contact" />
</intent-filter>
也可以自己設定type，但只能使用 setDataAndType()

3. 其他設定intent的屬性方式
Intent setComponent(ComponentName component)
Intent setClassName(Context packageContext, String className)
Intent setClassName(String packageName, String className)
Intent setClass(Context packageContext, Class<?> cls)
Intent 應該算是Android中特有的東西。你可以在Intent中指定程式 要執行的動作（比如：view,edit,dial），以及程式執行到該動作時所需要的資料。
都指定好後，只要調用startActivity()，Android系統 會自動尋找最符合你指定要求的應用 程式，並執行該程式。

//+++++++++++++++
下面列出幾種Intent的用法
顯示網頁:
Uri uri = Uri.parse("http://www.google.com");
Intent it  = new Intent(Intent.ACTION_VIEW,uri);
startActivity(it);
顯示地圖:
Uri uri = Uri.parse("geo:38.899533,-77.036476");
Intent it = new Intent(Intent.Action_VIEW,uri);
startActivity(it);
路徑規劃:
Uri uri = Uri.parse("http://maps.google.com/maps?f=dsaddr=startLat%20startLng&daddr=endLat%20endLng&hl=en");
Intent it = new Intent(Intent.ACTION_VIEW,URI);
startActivity(it);
撥打電話:
調用撥號程式
Uri uri = Uri.parse("tel:xxxxxx");
Intent it = new Intent(Intent.ACTION_DIAL, uri);
startActivity(it);
Uri uri = Uri.parse("tel.xxxxxx");
Intent it =new Intent(Intent.ACTION_CALL,uri);
要使用這個必須在配置文件 中加入<uses-permission id="android .permission.CALL_PHONE" />
發送SMS/MMS
調用發送短信的程式
Intent it = new Intent(Intent.ACTION_VIEW);
it.putExtra("sms_body", "The SMS text");
it.setType("vnd.android-dir/mms-sms");
startActivity(it);
發送短信
Uri uri = Uri.parse("smsto:0800000123");
Intent it = new Intent(Intent.ACTION_SENDTO, uri);
it.putExtra("sms_body", "The SMS text");
startActivity(it);
發送彩信
Uri uri = Uri.parse("content://media/external/images/media/23");
Intent it = new Intent(Intent.ACTION_SEND);
it.putExtra("sms_body", "some text");
it.putExtra(Intent.EXTRA_STREAM, uri);
it.setType("image/png");
startActivity(it);
發送Email
Uri uri = Uri.parse("mailto:xxx@abc.com");
Intent it = new Intent(Intent.ACTION_SENDTO, uri);
startActivity(it);
Intent it = new Intent(Intent.ACTION_SEND);
it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com");
it.putExtra(Intent.EXTRA_TEXT, "The email body text");
it.setType("text/plain");
startActivity(Intent.createChooser(it, "Choose Email Client"));
Intent it=new Intent(Intent.ACTION_SEND);
String[] tos={"me@abc.com"};
String[] ccs={"you@abc.com"};
it.putExtra(Intent.EXTRA_EMAIL, tos);
it.putExtra(Intent.EXTRA_CC, ccs);
it.putExtra(Intent.EXTRA_TEXT, "The email body text");
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");
it.setType("message/rfc822");
startActivity(Intent.createChooser(it, "Choose Email Client"));
添加附件
Intent it = new Intent(Intent.ACTION_SEND);
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");
it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/mysong.mp3");
sendIntent.setType("audio/mp3");
startActivity(Intent.createChooser(it, "Choose Email Client"));
播放多媒體
Intent it = new Intent(Intent.ACTION_VIEW);
Uri uri = Uri.parse("file:///sdcard/song.mp3");
it.setDataAndType(uri, "audio/mp3");
startActivity(it);
Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1");
Intent it = new Intent(Intent.ACTION_VIEW, uri);
startActivity(it);
Uninstall 程式
Uri uri = Uri.fromParts("package", strPackageName, null);
Intent it = new Intent(Intent.ACTION_DELETE, uri);
startActivity(it);
uninstall apk
Uri uninstallUri = Uri.fromParts("package", "xxx", null);
returnIt = new Intent(Intent.ACTION_DELETE, uninstallUri);
install apk
Uri installUri = Uri.fromParts("package", "xxx", null);
returnIt = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);
play audio
Uri playUri = Uri.parse("file:///sdcard/download/everything.mp3");
returnIt = new Intent(Intent.ACTION_VIEW, playUri);
//發送附件
Intent it = new Intent(Intent.ACTION_SEND);
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");
it.putExtra(Intent.EXTRA_STREAM, "file:///sdcard/eoe.mp3");
sendIntent.setType("audio/mp3");
startActivity(Intent.createChooser(it, "Choose Email Client"));
//搜索應用
Uri uri = Uri.parse("market://search?q=pname:pkg_name");
Intent it = new Intent(Intent.ACTION_VIEW, uri);
startActivity(it);
//where pkg_name is the full package path for an application
//顯示指定應用的詳細頁面（這個好像不支援了，找不到app_id）
Uri uri = Uri.parse("market://details?id=app_id");
Intent it = new Intent(Intent.ACTION_VIEW, uri);
startActivity(it);
//where app_id is the application ID, find the ID
//by clicking on your application on Market home
//page, and notice the ID from the address bar


/******************************************************************************/
android button background 效果
/******************************************************************************/
如果想在android製作不同的button效果！
要先建立一個自己取檔名.xml（這裡暫取button_style)檔！放在drawable底下！
並且準備三張button的圖片！
建議使用9-patch產生的圖片！這樣比較不會失真！
至於如何用9-patch就看之前的教學文章吧！

這三張圖片一樣放在drawable底下！
button_style.xmll格式如下

<?xml version="1.0" encoding="utf-8"?>    
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item  android:state_pressed="true"android:drawable="@drawable/button_pressed" />
    <item android:state_focused="true" android:drawable="@drawable/button_focused" />
    <item android:state_focused="false" android:state_pressed="false" android:drawable="@drawable/button_normal" />
</selector>

android:state_focused="false" android:state_pressed="false"
意思是button預設的樣子！既沒有受到焦點、也沒有被按的狀態下的樣子！
android:state_focused="true"
意思是當button被焦點時的樣子！
android:state_pressed="true"
意思是當button被按下時的樣子！

接著在main.xml中的button的屬性裡加入一個屬性！
把button的background設為我們剛剛為它特別設計的樣式！
這樣就可以為你的BUTTON設置特別的效果喔!
android:background="@drawable/button_style"


/******************************************************************************/
實作Facebook Login 【新版】     from: http://blog.kenyang.net/2012/01/facebook-login.html
/******************************************************************************/
今天發現前陣子有使用到Facebook登入的案子，突然掛了! 不能使用Facebook登入了....
去查了一下，原來Facebook API改版....
老實說，我覺得這樣機制很差....應該也保留舊有機制，而不是連通知都沒有就改版了!

Ok, fine! 其實也沒有太大差別!主要是改一些參數名稱!至於前面的註冊手續都相同! 可以來前一篇看!

至於coding實作如下，一樣得嵌入js檔，
<script src="http://connect.facebook.net/en_US/all.js"></script>

接著一樣要init，但是多了一個參數，就是oauth，以及從以前的response.session改成response.authResponse
<script>
 //先做init的動作，輸入自己的app id
 FB.init({ 
    appId:'你自己的app id', 
    cookie:true, 
    status:true, 
    xfbml:true,
    oauth : true // 多了這個參數
 });
 
 //下面是實作一個登入的function
function fnLoginFb(){
    FB.login(function(response) {
        //先判斷是否已經登入了，如果是，就直接
        if (response.authResponse){  
            FB.api('/me', function(response) {
                alert(response.email);
            });
        //下面是沒有登入時才會做的，會去subscribe一個event，就是去監聽一個login event（也就是說login成功以後，會接收到訊息）
        }else{
            FB.Event.subscribe('auth.login', function(response) {
                if (response.authResponse) {
                    FB.api('/me', function(response) {
                        alert(response.email);
                    });          
                }
            }); 
        }

    }, {scope:'email'});
} 
</script>
然後下面就是實作FB登入的按鈕了!


/******************************************************************************/
多個Activity之間傳值
/******************************************************************************/
本章將借用一個實例，講解如何註冊並激活一個新的Activity，以及多個Activity之間如何傳值。
下面是主Activity的代碼：
Java代碼
package com.chaoyang.activity;  
  
import android.app.Activity;  
import android.content.Intent;  
import android.os.Bundle;  
import android.text.style.BulletSpan;  
import android.view.View;  
import android.widget.Button;  
import android.widget.Toast;  
  
public class MainActivity extends Activity {  
    /** Called when the activity is first created. */  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        Button button =(Button)findViewById(R.id.button);  
        button.setOnClickListener(new View.OnClickListener() {  
              
            //給按鈕註冊點擊事件，打開新的Acticity  
            @Override  
            public void onClick(View v) {  
                // TODO Auto-generated method stub  
                //為Intent設置要激活的元件（將要激活TheOtherActivity這個Activity）  
                Intent intent =new Intent(MainActivity.this,TheOtherActivity.class);//  
                //寫法一 intent.setClass(MainActivity.this, OtherActivity.class);//設置要激活的元件  
                //寫法二 intent.setComponent(new ComponentName(MainActivity.this, TheOtherActivity.class));//設置要激活的元件  
                  
                //第一種傳值方式(代碼看起來更加更簡潔)  
                /* 
                intent.putExtra("name", "dinglang"); 
               intent.putExtra("age", 22); 
               */  
                //第二種傳值方式  
                Bundle bundle =new Bundle();  
                bundle.putString("name", "dinglang");  
                bundle.putInt("age", 22);  
                intent.putExtras(bundle);  
                /* 
                 Intent提供了各種常用類型重載後的putExtra()方法，如： putExtra(String name, String value)、 putExtra(String name, long value)，在putExtra()方法內部會判斷當前Intent對像內部是否已經存在一個Bundle對像，如果不存在就會新建Bundle對像，以後調用putExtra()方法傳入的值都會存放於該Bundle對像 
                                            這些其實可以通過看源碼的，內部實現的原理都是一樣的 
                 */  
                //startActivity(intent);//不需要接收元件的返回值，就可以直接這樣激活了  
                //需要接收返回結果。注意返回的結果碼  
                startActivityForResult(intent, 100);  
            }  
        });  
    }  
  
    @Override  
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {  
        // TODO Auto-generated method stub  
          
        Toast.makeText(this, data.getStringExtra("result"), 1).show();//得到返回結果  
        super.onActivityResult(requestCode, resultCode, data);  
    }  
}  

下面是otherActivity部分代碼：
在相同包下，新建一個類，繼承至Activity這個類,重寫onCreate方法...
Java代碼
package com.chaoyang.activity;  
  
import android.app.Activity;  
import android.content.Intent;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
import android.widget.TextView;  
  
public class TheOtherActivity extends Activity {  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        // TODO Auto-generated method stub  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.other);//設置該Activity所對應的xml佈局文件  
        Intent intent =this.getIntent();//得到激活她的意圖  
        String name =intent.getStringExtra("name");  
        int age=intent.getExtras().getInt("age");//第二種取值方式  
        TextView textView = (TextView)this.findViewById(R.id.result);  
        textView.setText("姓名："+ name+"  年齡："+ age);  
        Button button = (Button)this.findViewById(R.id.close);  
        button.setOnClickListener(new View.OnClickListener() {  
              
            //返回結果給前面的Activity  
            @Override  
            public void onClick(View v) {  
                // TODO Auto-generated method stub  
                Intent intent =new Intent();  
                intent.putExtra("result", "這是處理結果");  
                setResult(20, intent);//設置返回數據  
                finish();//關閉activity  
            }  
        });  
    }  
  
}  

新建Activity之間，注意要在layout文件夾中新建一個XML的佈局文件。（新建Android項目時如果選擇了創建Activity，會默認新建一個XML的佈局文件）
下面是佈局文件main.xml：
Html代碼
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:orientation="vertical"  
    android:layout_width="fill_parent"  
    android:layout_height="fill_parent"  
    >  
<TextView    
    android:layout_width="fill_parent"   
    android:layout_height="wrap_content"   
    android:text="@string/hello"  
    />  
      
    <Button    
        android:layout_width="wrap_content"   
        android:layout_height="wrap_content"   
        android:text="打開OtherActivity"  
        android:id="@+id/button"  
        />  
</LinearLayout>  

下面是佈局文件other.xml
Html代碼
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout  
  xmlns:android="http://schemas.android.com/apk/res/android"  
  android:orientation="vertical"  
  android:layout_width="fill_parent"  
  android:layout_height="fill_parent">  
    
  <TextView    
    android:layout_width="fill_parent"   
    android:layout_height="wrap_content"   
    android:text="這是OtherActivity"  
    android:id="@+id/result"  
    />  
      
      <Button    
    android:layout_width="wrap_content"   
    android:layout_height="wrap_content"   
    android:text="關閉Activity"  
    android:id="@+id/close"  
    />  
</LinearLayout>  

最後，注意修改項目清單文件。在裡面添加，註冊新的Acticity名稱
Html代碼
<?xml version="1.0" encoding="utf-8"?>  
<manifest xmlns:android="http://schemas.android.com/apk/res/android"  
      package="com.chaoyang.activity"  
      android:versionCode="1"  
      android:versionName="1.0">  
    <uses-sdk android:minSdkVersion="8" />  
  
    <application android:icon="@drawable/icon" android:label="@string/app_name">  
        <activity android:name=".MainActivity"  
                  android:label="@string/app_name">  
            <intent-filter>  
                <action android:name="android.intent.action.MAIN" />  
                <category android:name="android.intent.category.LAUNCHER" />  
            </intent-filter>  
        </activity>  
        <!-- 注意項目清單文件中要加上 -->  
<activity android:name="TheOtherActivity" android:label="the other Activity"/>  
    </application>  
</manifest>  

需要注意的知識點：
使用Intent元件附件數據時候，為Activity之間傳值的兩種寫法。
值得一提的是Bundle類的作用
Bundle類用作攜帶數據，它類似於Map，用於存放key-value名值對形式的值。相對於Map，它提供了各種常用類型的putXxx()/getXxx()方法，如:putString()/getString()和putInt()/getInt()，putXxx()用於往Bundle對像放入數據，getXxx()方法用於從Bundle對像裡獲取數據。Bundle的內部實際上是使用了HashMap<String,Object>類型的變數來存放putXxx()方法放入的值。
還有就是在onActivityResult這個方法中，第一個參數為請求碼，即調用startActivityForResult()傳遞過去的值 ，第二個參數為結果碼，結果碼用於標識返回數據來自哪個新Activity。都是起簡單的標識作用的（不要和http協定中的404，200等狀態碼搞混了），可以根據自己的業務需求填寫，匹配，必要時候可以根據這個去判斷。
這裡就不做深入的講解了。


/******************************************************************************/
Android Bluetooth 應用之 HelloBTUart(RS-232)    from: http://cheng-min-i-taiwan.blogspot.tw/2012/01/android-bluetooth-hellobtuartrs-232.html
/******************************************************************************/
在NDK這篇HelloUart中，有人詢問到開發平台轉移至智慧型手機上應該如何實現呢??
另一個答案就是藍牙(Bluetooth)。

因此，今天的主題就是在Android手機上實現藍牙規範中的 Serial Port Profile(SPP)作為RS-232的通訊。
Android從2.0版本開始就已經支援藍牙，相關程式撰寫可參考android.bluetooth這個package:
http://developer.android.com/reference/android/bluetooth/package-summary.html

一般來說，藍芽裝置通訊步驟如下：
1.設定藍芽
2.搜尋已配對的或接收範圍內的裝置
3.連接裝置
4.傳輸資料
因此，經常會用的類包括:
BluetoothAdapter : 藍牙裝置選擇，主要用來管理藍牙的基本服務，包括初始化藍牙、藍牙的配對、資料傳輸的管理。
BluetoothDevice : 描述藍牙裝置。
BluetoothSocket : 藍牙Socket；這有點類似TCP/IP的Socket是用在藍牙間的通訊。
BluetoothServerSocket : 藍牙Server Socket；類似TCP/IP的Server Socket。與上述不同處在於一個是連接時通訊使用；而這個類比較像是監聽的功能。


/******************************************************************************/
Android 用webview閱讀pdf文件
/******************************************************************************/
Android本身不支援打開pdf文件，搜了好多資料一直沒有找到合適的方法，後來發現google提供了在線解析pdf。方法其實很簡單。

WebView webview = (WebView) findViewById(R.id.wv);  
webview.getSettings().setJavaScriptEnabled(true);   
String pdf ="http://www.*****.pdf";  
webview.loadUrl("http://docs.google.com/gview?embedded=true&url=" + pdf);  


/******************************************************************************/
Android Alarm manager 定時鬧鐘開發詳解          from: http://www.51mokao.com/Groups/ForumPost.aspx?id=34136
                                                        http://note.jhpeng.com/2011/08/android-alarm-manager.html
/******************************************************************************/
Alarm manager 主要管理硬體時鐘。
一些與時間相關的應用，如日曆，鬧鐘等需要使用Alarm Manager的服務。Alarm manager功能相對比較簡單，相關代碼位於
frameworks/base/core/jni/server/com_android_server_AlarmManagerService.cpp
frameworks/base/services/java/com/android/server/AlarmManagerService.java

一. frameworks/base/core/jni/server/com_android_server_AlarmManagerService.cpp
這部分代碼直接管理硬體時鐘，設備名為/dev/alarm。包括打開設備，關閉設備，設置時區，設置觸發時間（timeout），以及等待時鐘觸發。
二. frameworks/base/services/java/com/android/server/AlarmManagerService.java
這部分封裝目錄一中的代碼，向上提供java介面，同時與用戶端（如calendar）交互，接收來自用戶端的時鐘設置請求，並在時鐘觸發時通知用戶端。
Alarm是在預定的時間上觸發Intent的一種獨立的方法。
 
Alarm超出了應用程式的作用域，所以它們可以用於觸發應用程式事件或動作，甚至在應用程式關閉之後。與Broadcast Receiver結合，它們可以變得尤其的強大，可以通過設置Alarm來啟動應用程式或者執行動作，而應用程式不需要打開或者處於活躍狀態。
舉個例子，你可以使用Alarm來實現一個鬧鐘程式，執行正常的網路查詢，或者在「非高峰」時間安排耗時或有代價的操作。
對於僅在應用程式生命週期內發生的定時操作，Handler類與Timer和Thread類的結合是一個更好的選擇，它允許Android更好地控制系統資源。
Android中的Alarm在設備處於睡眠模式時仍保持活躍，它可以設置來喚醒設備;然而，所有的Alarm在設備重啟時都會被取消。
Alarm的操作通過AlarmManager來處理，通過getSystemService可以獲得其系統服務，如下所示：
AlarmManager alarms = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
為了創建一個新的Alarm，使用set方法並指定一個Alarm類型、觸發時間和在Alarm觸發時要調用的Intent。如果你設定的Alarm發生在過去，那麼，它將立即觸發。
這裡有4種Alarm類型。你的選擇將決定你在set方法中傳遞的時間值代表什麼，是特定的時間或者是時間流逝：
? RTC_WAKEUP
在指定的時刻（設置Alarm的時候），喚醒設備來觸發Intent。
? RTC
在一個顯式的時間觸發Intent，但不喚醒設備。
? ELAPSED_REALTIME
從設備啟動後，如果流逝的時間達到總時間，那麼觸發Intent，但不喚醒設備。流逝的時間包括設備睡眠的任何時間。注意一點的是，時間流逝的計算點是自從它最後一次啟動算起。
? ELAPSED_REALTIME_WAKEUP
從設備啟動後，達到流逝的總時間後，如果需要將喚醒設備並觸發Intent。

Alarm的創建過程演示如下片段所示：
int alarmType = AlarmManager.ELAPSED_REALTIME_WAKEUP;
long timeOrLengthofWait = 10000;
String ALARM_ACTION = 「ALARM_ACTION」;
Intent intentToFire = new Intent(ALARM_ACTION);
PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intentToFire, 0);
alarms.set(alarmType, timeOrLengthofWait, pendingIntent);
 
當Alarm到達時，你指定的PendingIntent將被觸發。設置另外一個Alarm並使用相同的PendingIntent來替代之前存在的Alarm。
取消一個Alarm，調用AlarmManager的cancel方法，傳入你不再希望被觸發的PendingIntent，如下面的代碼所示：
alarms.cancel(pendingIntent);
接下來的代碼片段中，設置了兩個Alarm，隨後馬上取消了第一個Alarm。第一個Alarm顯式地設置了在特定的時間喚醒設備並發送Intent。第二個設置為從設備啟動後，流逝時間為30分鐘，到達時間後如果設備在睡眠狀態也不會喚醒它。
AlarmManager alarms = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
 
String MY_RTC_ALARM = 「MY_RTC_ALARM」;
String ALARM_ACTION = 「MY_ELAPSED_ALARM」;
PendingIntent rtcIntent = PendingIntent.getBroadcast(this, 0, new Intent(MY_RTC_ALARM), 1);
PendingIntent elapsedIntent = PendingIntent.getBroadcast(this, 0, new Intent(ALARM_ACTION), 1);
 
// Wakeup and fire intent in 5 hours.(註釋可能有錯)
Date t = new Date();
t.setTime(java.lang.System.currentTimeMillis() + 60*1000*5);
alarms.set(AlarmManager.RTC_WAKEUP, t.getTime(), rtcIntent);
 
// Fire intent in 30 mins if already awake.
alarms.set(AlarmManager.ELAPSED_REALTIME, 30*60*1000, elapsedIntent);
 
// Cancel the first alarm.
alarms.cancel(rtcIntent);


/******************************************************************************/
Android撥放音樂         from: http://note.jhpeng.com/search/label/Android
/******************************************************************************/
package com.jhpeng.note.Test04_01;

import java.util.Timer; 
import java.util.TimerTask;
import android.app.Activity; 
import android.media.MediaPlayer; 
import android.os.Bundle; 
import android.view.View; 
import android.widget.Button;

public class Test04_Sound_PlayMusicActivity extends Activity { 
    
    private MediaPlayer playerChannel = null; // initialize null 
    private Timer timerChannel; 
    
    @Override 
    public void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.main); 
        
        
        Button  playBtn = (Button) findViewById(R.id.button1); 
        playBtn.setOnClickListener(new View.OnClickListener() {            
            @Override 
            public void onClick(View v) { 
                
                //撥放音樂 
                playerChannel = MediaPlayer.create(getApplicationContext(), R.raw.music_1); 
                playerChannel.start(); 
                
                
                //播放三秒 
                timerChannel = new Timer(); 
                timerChannel.schedule(new TimerTask() 
                { 
                    synchronized public void run() // Add synchronized method 
                    { 
                        releasePlayer();// Stop current channel playing                        
                        releaseTimer();// Stop timer                    
                    } 
                }, 3000);    
                
            } 
        }); 
        
                            
    } 
    
    
    synchronized private void releasePlayer() // Add synchronized method 
    { 
        if (playerChannel != null) 
        { 
            if (playerChannel.isPlaying()) 
            { 
                playerChannel.stop(); 
            } 
            playerChannel.release(); 
            playerChannel = null; 
        } 
    }    
    
    synchronized private void releaseTimer() 
    { 
        if (timerChannel != null) 
        { 
            timerChannel.cancel(); 
            timerChannel = null; 
        } 
    }        
}


/******************************************************************************/
Android開發之Socket編程
/******************************************************************************/
read: http://note.jhpeng.com/2011/11/socket-socketsocketsocketsockettcpipsoc.html


/******************************************************************************/
Intent 用法大公開
/******************************************************************************/
顯示網頁
Uri uri = Uri.parse("http://google.com"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it); 

顯示地圖
Uri uri = Uri.parse("geo:38.899533,-77.036476"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);  
//其他 geo URI 範例
//geo:latitude,longitude
//geo:latitude,longitude?z=zoom
//geo:0,0?q=my+street+address
//geo:0,0?q=business+near+city
//google.streetview:cbll=lat,lng&cbp=1,yaw,,pitch,zoom&mz=mapZoom

路徑規劃
Uri uri = Uri.parse("http://maps.google.com/maps?f=d&saddr=startLat%20startLng&daddr=endLat%20endLng&hl=en"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it); 
//where startLat, startLng, endLat, endLng are a long with 6 decimals like: 50.123456

撥打電話
//叫出撥號程式
Uri uri = Uri.parse("tel:0800000123"); 
Intent it = new Intent(Intent.ACTION_DIAL, uri); 
startActivity(it); 
//直接打電話出去
Uri uri = Uri.parse("tel:0800000123"); 
Intent it = new Intent(Intent.ACTION_CALL, uri); 
startActivity(it); 
//用這個，要在 AndroidManifest.xml 中，加上
//<uses-permission id="android.permission.CALL_PHONE" />

傳送 SMS/MMS
//叫起簡訊程式
Intent it = new Intent(Intent.ACTION_VIEW); 
it.putExtra("sms_body", "The SMS text");  
it.setType("vnd.android-dir/mms-sms"); 
startActivity(it); 
//傳送簡訊
Uri uri = Uri.parse("smsto:0800000123"); 
Intent it = new Intent(Intent.ACTION_SENDTO, uri); 
it.putExtra("sms_body", "The SMS text"); 
startActivity(it); 
//傳送 MMS
Uri uri = Uri.parse("content://media/external/images/media/23"); 
Intent it = new Intent(Intent.ACTION_SEND);  
it.putExtra("sms_body", "some text");  
it.putExtra(Intent.EXTRA_STREAM, uri); 
it.setType("image/png");  
startActivity(it); 
//如果是 HTC Sense 手機，你要用
Intent sendIntent = new Intent("android.intent.action.SEND_MSG");   
sendIntent.putExtra("address", toText);   
sendIntent.putExtra(Intent.EXTRA_SUBJECT, "subject");  
sendIntent.putExtra("sms_body", textMessage);   
sendIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(url));  
sendIntent.setType("image/jpeg");   
startActivity(sendIntent); 
//底下這段更好，可在所有手機上用
//refer to http://stackoverflow.com/questions/2165516/sending-mms-into-different-android-devices
Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("mmsto:<number>");  
intent.putExtra("address", <number>);  
intent.putExtra("subject", <subject>);  
startActivity(intent);  

傳送 Email
Uri uri = Uri.parse("mailto:xxx@abc.com"); 
Intent it = new Intent(Intent.ACTION_SENDTO, uri); 
startActivity(it); 
Intent it = new Intent(Intent.ACTION_SEND); 
it.putExtra(Intent.EXTRA_EMAIL, "me@abc.com"); 
it.putExtra(Intent.EXTRA_TEXT, "The email body text"); 
it.setType("text/plain"); 
startActivity(Intent.createChooser(it, "Choose Email Client")); 
Intent it=new Intent(Intent.ACTION_SEND);   
String[] tos={"me@abc.com"};   
String[] ccs={"you@abc.com"};   
it.putExtra(Intent.EXTRA_EMAIL, tos);   
it.putExtra(Intent.EXTRA_CC, ccs);   
it.putExtra(Intent.EXTRA_TEXT, "The email body text");   
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text");   
it.setType("message/rfc822");   
startActivity(Intent.createChooser(it, "Choose Email Client"));  
//傳送影音附件檔
Intent it = new Intent(Intent.ACTION_SEND); 
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text"); 
it.putExtra(Intent.EXTRA_STREAM, Uri.parse("file:///sdcard/mysong.mp3")); 
it.setType("audio/mp3"); 
startActivity(Intent.createChooser(it, "Choose Email Client")); 
//傳送圖片附件檔
Intent it = new Intent(Intent.ACTION_SEND); 
it.putExtra(Intent.EXTRA_SUBJECT, "The email subject text"); 
it.putExtra(Intent.EXTRA_STREAM, Uri.parse("file:///sdcard/mypic.jpg")); 
it.setType("image/jpeg"); 
startActivity(Intent.createChooser(it, "Choose Email Client")); 

顯示聯絡人清單
Intent it = new Intent(Intent.ACTION_VIEW, People.CONTENT_URI); 
startActivity(it); 

顯示某個朋友的詳細資料
Uri uriPerson = ContentUris.withAppendedId(People.CONTENT_URI, 5); //5 是朋友的 ID
Intent it = new Intent(Intent.ACTION_VIEW, uriPerson); 
startActivity(it); 

播放多媒體
Intent it = new Intent(Intent.ACTION_VIEW); 
Uri uri = Uri.parse("file:///sdcard/song.mp3"); 
it.setDataAndType(uri, "audio/mp3"); 
startActivity(it); 
Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it); 

從圖庫中回傳選到的圖片
Intent it = new Intent(Intent.ACTION_GET_CONTENT);   
it.addCategory(Intent.CATEGORY_OPENABLE);   
it.setType("image/*"); 
startActivityForResult(it, 0); 
//回傳的圖片可透過 it.getData() 取得圖片之 Uri

啟動照相機，並將相片存在指定的檔案中
Intent it = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);   
//假設你要將相片存在 /sdcard/xxx.jpg 中
File f = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/xxx.jpg"); 
it.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(f));  
startActivity(it, 0); 

Market 相關
//尋找某個應用程式
Uri uri = Uri.parse("market://search?q=pname:pkg_name"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it); 
//where pkg_name is the full package path for an application
//顯示某應用程式詳細畫面
Uri uri = Uri.parse("market://details?id=pkg_name_or_app_id"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it); 
//where app_id is the application ID, find the ID
//by clicking on your application on Market home
//page, and notice the ID from the address bar

Uninstall 應用程式
Uri uri = Uri.fromParts("package", strPackageName, null);  
Intent it = new Intent(Intent.ACTION_DELETE, uri);  
startActivity(it);  

安裝 APK 檔
Uri uri = Uri.parse("url_of_apk_file"); 
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
it.setData(uri); 
it.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); 
it.setClassName("com.android.packageinstaller", 
"com.android.packageinstaller.PackageInstallerActivity"); 
startActivity(it);  
//make sure the url_of_apk_file is readable for all users
 
來源：http://ysl-paradise.blogspot.com/2008/12/intent.html


/******************************************************************************/
Android String字串處理          http://iskens.blogspot.tw/2011/01/android-string.html
/******************************************************************************/
記得之前寫過一篇"Object C - String"，會寫這些很簡單就是因為我大腦記不住，反正知道去哪找就好，超小的腦容量要記住這麼多東西真是有點困難。
這邊就紀錄一下常用的合併、切割、型態轉換、搜尋、替換、找出位置...等

合併
/* 合併 */
String cht = "一二三四五六七八九十";
String num = "1234567890";
String append = cht+num;
System.out.println("append = "+append);
//一二三四五六七八九十1234567890

切割
/* 切割字串 */
String eng = "abcdefghijklmnopqrstuvwxyz";
String[] array = eng.split("k");
for(int i = 0 ; i < array.length ; i ++){ 
    System.out.println("array["+i+"] = "+array[i]);     //array[0] = abcdefghij //array[1] = lmnopqrstuvwxyz
} 

型態轉換
/* 轉換型態 */
String num = "1234567890";
//string轉int
int number = Integer.valueOf(num); //string to int
int aaa = 9999999;
//int轉string
String fromInt = String.valueOf(aaa);
System.out.println("fromInt = "+fromInt+" || number = "+number);
//fromInt = 9999999 || number = 1234567890

搜尋字串(從0開始算)
/* 搜尋字串 */
String eng = "abcdefghijklmnopqrstuvwxyz";
int searchLoc = eng.indexOf("i");
System.out.println("i = "+searchLoc);
//i = 8

searchLoc = eng.indexOf("xy");
System.out.println("xy = "+searchLoc);
//xy = 23

searchLoc = eng.indexOf("isken");
System.out.println("isken = "+searchLoc);
//isken = -1(找不到)

搜尋字元(從0開始算)
/* 搜尋字元 */
String cht = "一二三四五六七八九十";
String num = "1234567890";
char c = cht.charAt(2);
System.out.println("cht third char = "+c);
//cht third char = 三

c = eng.charAt(1);
System.out.println("eng second char = "+c);
//eng second char = b

取得字串指定位置(從0開始算)
/* 取得字串指定位置 */
String num = "1234567890";
String subTest = num.substring(1, 4);
System.out.println("subTest = "+subTest);
//subTest = 234

字串長度
/* 字串長度 */
System.out.println("cht length = "+cht.length());
//cht length = 10

替換字串
/* 替換字串 */
//替換全部
String replaceTest = "abcabcabc";
String replaced = replaceTest.replaceAll("abc", "123");
System.out.println("replaceAll = "+replaced);
//replaceAll = 123123123

//替換最先找到那個
replaced = replaceTest.replaceFirst("abc", "123");
System.out.println("replaceFirst = "+replaced);
//replaceFirst = 123abcabc

格式化字串
/* 格式化字串 */
String formatTest = "%02d";//定義為兩位不足兩位則補"0"
for(int i = 5; i < 15; i++){ System.out.println("format = "+String.format(formatTest, i)); } //format = 05 //format = 06 //... //format = 13 //format = 14

清除空白字串(清除前後所有的空白，但是字串與字串間空格不會被清除)
/* 清除字串空格 */
String trimTest1 = "abc ";
String trimTest2 = " abc";
String trimTest3 = " abc ";
String trimTest4 = "abc abc";
String trimTest5 = " d abc";
System.out.println("trimTest1 = "+trimTest1.trim());
System.out.println("trimTest2 = "+trimTest2.trim());
System.out.println("trimTest3 = "+trimTest3.trim());
System.out.println("trimTest4 = "+trimTest4.trim());
System.out.println("trimTest5 = "+trimTest5.trim());
//trimTest1 = abc
//trimTest2 = abc
//trimTest3 = abc
//trimTest4 = abc abc
//trimTest5 = d abc

字串比對
/* 字串比對 */
String cht = "一二三四五六七八九十";
String num = "1234567890";
String equalcht = "一二三四五六七八九十";
System.out.println("cht & equalcht = "+cht.equals(equalcht)+" || cht & eng = "+cht.equals(eng));
//print cht & equalcht = true || cht & eng = false 

字串轉字元
/* 字串轉字元 */
String cht = "一二三四五六七八九十";
char c = cht.toCharArray()";
for(int i = 0; i < c.length; i++){ System.out.print("["+i+"] = "+c[i]); }


/******************************************************************************/
Android xml文件裡讀取string array
/******************************************************************************/
XML file: res/values/strings.xml :
<resources> 
    <string-array name="WeekOfDaySel">
        <item >Sunday</item>
        <item >Monday</item>
        <item >Tuesday</item>
        <item >Wednesday</item>
        <item >Thursday</item>
        <item >Friday</item>
        <item >Saturday</item>
    </string-array>
</resources> 

Java code:
Resources res = getResources () ;   
String [] planets = res.getStringArray (R.array.WeekOfDaySel);


/******************************************************************************/
Android的數據存儲方式
/******************************************************************************/
1.SharedPreferences：
  用來存儲"key-value paires"格式的數據，它是一個輕量級的鍵值存儲機制，只可以存儲基本數據類型。 
2.文件存儲：
  通過FileInputStream和FileOutputStream對文件進行操作。在Android中，文件是一個應用程式私有的，一個應用無法讀寫其他應用程式的文件。 
3.SQLite數據庫存儲：
  Android提供的一個標準數據庫，支援SQL語句。 
網路：通過網路來存儲和獲得數據。 
4.ContentProvider：
  是所有應用程式之間數據存儲和檢索的一個橋樑，它的作用就是使得各個應用程式之間實現數據共享。
  它是一個特殊的存儲數據的類型，它提供了一套標準的介面用來獲取數據、操作數據。
  系統也提供了音頻、視頻、圖像和個人資訊等幾個常用的Content Providers。
  如果你想公開自己的私有數據，可以創建自己的Content Provider類，或者當你對這些數據擁有控制、寫入的權限時講這些數據添加到Content Provider中實現共享。
  外部訪問通過ContentResolver去訪問並操作這些被暴露的數據。組織數據主要包括：存儲數據，讀取數據，以數據庫的方式暴露數據。
  數據的存儲需要根據設計的需求，選擇合適的存儲結構，首選數據庫，當然也可以選擇本地其他文件，甚至可以是網路上的數據。
  數據的讀取，以數據庫的方式暴露數據這就要求，無論數據是如何存儲的，數據最後必須以數據的方式訪問。


/******************************************************************************/
Android自定義對話方塊(Dialog)位置,大小
/******************************************************************************/
代碼:

package angel.devil;

import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.view.Gravity;
import android.view.Window;
import android.view.WindowManager;

public class DialogDemoActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        Dialog dialog = new Dialog(this);
        
        // setContentView可以設置為一個View也可以簡單地指定資源ID
        // LayoutInflater
        // li=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
        // View v=li.inflate(R.layout.dialog_layout, null);
        // dialog.setContentView(v);
        dialog.setContentView(R.layout.dialog_layout);

        dialog.setTitle("Custom Dialog");

        /* 
         * 獲取聖誕框的窗口對象及參數對像以修改對話方塊的佈局設置,
         * 可以直接調用getWindow(),表示獲得這個Activity的Window
         * 對像,這樣這可以以同樣的方式改變這個Activity的屬性.
         */
        Window dialogWindow = dialog.getWindow();
        WindowManager.LayoutParams lp = dialogWindow.getAttributes();
        dialogWindow.setGravity(Gravity.LEFT | Gravity.TOP);

        /*
         * lp.x與lp.y表示相對於原始位置的偏移.
         * 當參數值包含Gravity.LEFT時,對話方塊出現在左邊,所以lp.x就表示相對左邊的偏移,負值忽略.
         * 當參數值包含Gravity.RIGHT時,對話方塊出現在右邊,所以lp.x就表示相對右邊的偏移,負值忽略.
         * 當參數值包含Gravity.TOP時,對話方塊出現在上邊,所以lp.y就表示相對上邊的偏移,負值忽略.
         * 當參數值包含Gravity.BOTTOM時,對話方塊出現在下邊,所以lp.y就表示相對下邊的偏移,負值忽略.
         * 當參數值包含Gravity.CENTER_HORIZONTAL時
         * ,對話方塊水平居中,所以lp.x就表示在水平居中的位置移動lp.x像素,正值向右移動,負值向左移動.
         * 當參數值包含Gravity.CENTER_VERTICAL時
         * ,對話方塊垂直居中,所以lp.y就表示在垂直居中的位置移動lp.y像素,正值向右移動,負值向左移動.
         * gravity的預設值為Gravity.CENTER,即Gravity.CENTER_HORIZONTAL |
         * Gravity.CENTER_VERTICAL.
         * 
         * 本來setGravity的參數值為Gravity.LEFT | Gravity.TOP時對話方塊應出現在程式的左上角,但在
         * 我手機上測試時發現距左邊與上邊都有一小段距離,而且垂直坐標把程式標題欄也計算在內了,
         * Gravity.LEFT, Gravity.TOP, Gravity.BOTTOM與Gravity.RIGHT都是如此,據邊界有一小段距離
         */
        lp.x = 100; // 新位置X坐標
        lp.y = 100; // 新位置Y坐標
        lp.width = 300; // 寬度
        lp.height = 300; // 高度
        lp.alpha = 0.7f; // 透明度

        // 當Window的Attributes改變時系統會調用此函數,可以直接調用以應用上面對窗口參數的更改,也可以用setAttributes
        // dialog.onWindowAttributesChanged(lp);
        dialogWindow.setAttributes(lp);

        /*
         * 將對話方塊的大小按螢幕大小的百分比設置
         */
//        WindowManager m = getWindowManager();
//        Display d = m.getDefaultDisplay(); // 獲取螢幕寬、高用
//        WindowManager.LayoutParams p = getWindow().getAttributes(); // 獲取對話方塊當前的參數值
//        p.height = (int) (d.getHeight() * 0.6); // 高度設置為螢幕的0.6
//        p.width = (int) (d.getWidth() * 0.65); // 寬度設置為螢幕的0.95
//        dialogWindow.setAttributes(p);

        dialog.show();

    }
}

 
佈局文件:
main.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="#00FF00"
    android:orientation="vertical" >

    <TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/hello" />

</LinearLayout>

dialog_layout.xml

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/layout_root"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal"
    android:padding="10dp" >

    <ImageView
        android:id="@+id/image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginRight="10dp"
        android:src="@drawable/ic_launcher" />

    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="A Dialog"
        android:textColor="#FFF" />

</LinearLayout>


/******************************************************************************/
如何使用Listener        from: http://givemepass.blogspot.tw/2012/01/listener.html#more
/******************************************************************************/
假設你有兩個元件要建立事件
也許你會這樣做
button1 = (Button)findViewById(R.id.btn1);
button2 = (Button)findViewById(R.id.btn2);
textView1 = (TextView)findViewById(R.id.text_view1);
textView2 = (TextView)findViewById(R.id.text_view2);
class MyOnClickListener implements OnClickListener{
    public void onClick(View v){
        textView1.setText("textview1");
    }
    public void onClick(View v){
        textView2.setText("textview2");
    }
}
private MyOnClickListener myOnClickListener = new MyOnClickListener();
button1.setOnClickListener(myOnClickListener);
button2.setOnClickListener(myOnClickListener);
不! 你不能這樣做, 因為你不能在同一個類別內實作同一個方法兩次,
而且你會被編譯器擋下, 那怎麼辦呢?

也許可以這樣做
class MyOnClickListener implements OnClickListener{
    public void onClick(View v){
        if(v.getId()==R.id.btn1){
            textView1.setText("textview1");
        }
        else if(v.getId()==R.id.btn2){
            textView2.setText("textview2");
        }
    }
}

甚至比較乾淨的做法是
class MyOnClickListener implements OnClickListener{
    public void onClick(View v){
        switch(v.getId()){
        case R.id.btn1:
            textView1.setText("textview1");
            break;
        case R.id.btn2:
            textView2.setText("textview2");
            break;
        }
    }
}

最後在補上
private MyOnClickListener myOnClickListener = new MyOnClickListener();
button1.setOnClickListener(myOnClickListener);
button2.setOnClickListener(myOnClickListener);

看起來似乎不錯, 但是萬一某一天我想要改變某個動作,
那又等重新修改整段程式碼的事件, 也許手殘會把其他的事件弄亂,
這樣一點也不好。

那如果這樣呢? 分別寫在不同的類別
public MyActivity extends Activity{
    public void onCreate(){
        button1 = (Button)findViewById(R.id.btn1);
        button2 = (Button)findViewById(R.id.btn2);
        textView1 = (TextView)findViewById(R.id.text_view1);
        textView2 = (TextView)findViewById(R.id.text_view2);
    }
    private MyOnClickListener1 myOnClickListener1 = new MyOnClickListener1();
    private MyOnClickListener2 myOnClickListener2 = new MyOnClickListener2();
    button1.setOnClickListener(myOnClickListener1);
    button2.setOnClickListener(myOnClickListener2);
}
class MyOnClickListener1 implements OnClickListener{
    public void onClick(View v){
        textView1.setText("textview1");
    }
    
}
class MyOnClickListener2 implements OnClickListener{
    public void onClick(View v){
        textView2.setText("textview2");
    }
}


你會被編譯器擋下來, 因為在MyOnClickListener1和MyOnClickListener2並不存在
textView1跟textView2這兩個類別成員。

所以我們又想到一個好辦法, 那就是把事件類別寫在我們要處理事件的類別內，
改成這樣就沒問題了!
public MyActivity extends Activity{
    private TextView textView1;
    private TextView textView2;
 
    private MyOnClickListener1 myOnClickListener1;
    private MyOnClickListener2 myOnClickListener2;
    public void onCreate(){
        button1 = (Button)findViewById(R.id.btn1);
        button2 = (Button)findViewById(R.id.btn2);
        textView1 = (TextView)findViewById(R.id.text_view1);
        textView2 = (TextView)findViewById(R.id.text_view2);
        myOnClickListener1 = new MyOnClickListener1();
        myOnClickListener2 = new MyOnClickListener2();
        button1.setOnClickListener(myOnClickListener1);
        button2.setOnClickListener(myOnClickListener2);
    }
    
    class MyOnClickListener1 implements OnClickListener{
        public void onClick(View v){
            textView1.setText("textview1");
        }
    }
    class MyOnClickListener2 implements OnClickListener{
        public void onClick(View v){
            textView2.setText("textview2");
        }
    }
}


類別內的類別稱作inner class, 那inner class稱呼包著它的類別就叫做outer class,
inner class可以使用outer class的任何成員,就算是private的也是可行,
如上面的例子, 內部類別可以取用textView1,textView2。

但是!
寫程式總是會想要偷懶, 少寫幾行又能完成相同的功能,
那我們就會開始想辦法偷懶,
你有沒有發現每次都要宣告類別, 定義要處理的事件,
然後在宣告實體, 最後將實體配置給某個元件的監聽器,
有夠麻煩的, 因此我們就會會想,
不如把定義事件跟宣告該事件類別的物件一起寫,
這樣不就方便多了?
所以改成這樣, 也許會好一點!

public MyActivity extends Activity{
    private TextView textView1;
    private TextView textView2;
 
    //private MyOnClickListener1 myOnClickListener1;
    //private MyOnClickListener2 myOnClickListener2;
    public void onCreate(){
        button1 = (Button)findViewById(R.id.btn1);
        button2 = (Button)findViewById(R.id.btn2);
        textView1 = (TextView)findViewById(R.id.text_view1);
        textView2 = (TextView)findViewById(R.id.text_view2);
        //myOnClickListener1 = new MyOnClickListener1();
        //myOnClickListener2 = new MyOnClickListener2();
        button1.setOnClickListener(mOnClickListener1);
        button2.setOnClickListener(mOnClickListener2);
    }
    
    private OnClickListener mOnClickListener1 = new OnClickListener(){
        public void onClick(View v){
            textView1.setText("textview1");
        }
    }
    private OnClickListener mOnClickListener2 = new OnClickListener(){
        public void onClick(View v){
            textView2.setText("textview2");
        }
    }
}


嗯...看起來少寫幾行的感覺真爽!
但是全聯先生說:省還可以更省。
如果我們再將定義事件類別宣告的變數省起來,
直接寫進setOnClickListener, 不是更好嗎?
因此終極省法出現了!
public MyActivity extends Activity{
    private TextView textView1;
    private TextView textView2;
 
    public void onCreate(){
        button1 = (Button)findViewById(R.id.btn1);
        button2 = (Button)findViewById(R.id.btn2);
        textView1 = (TextView)findViewById(R.id.text_view1);
        textView2 = (TextView)findViewById(R.id.text_view2);
        button1.setOnClickListener(new MyOnClickListener1(){
            public void onClick(View v){
                textView1.setText("textview1");
            }
        });
        button2.setOnClickListener(new MyOnClickListener2(){
            public void onClick(View v){
                textView2.setText("textview2");
            }
        });
    }
}


整個世界乾淨多了!
現在你知道為什麼要這樣寫了嗎?



我們有時候必須考慮到很多種情況
來挑是否使用匿名類別物件
今天假設你有一百個Button 且 事件內容都相同 這種情況下
就不可能使用匿名類別物件了
因為你會寫到瘋掉
Button[] button = new Button[100];
buttton[0].setOnClickListener(new OnClickListener(){
    public void onClick(View v){
       textView.setText("hello");
    }
});
buttton[1].setOnClickListener(new OnClickListener(){
    public void onClick(View v){
       textView.setText("hello");
    }
});
....100次


你會說 反正複製貼上而已 很快!
那萬一今天你想修改事件內容呢? 你會改到瘋掉

所以比較好的做法反而是之前的宣告一個事件物件
然後用for迴圈去註冊事件
private OnClickListener mOnClickListener = new OnClickListener(){
    public void onClick(View v){
         textView.setText("ya");
    }
};
for(int i=0;i<button.length;i++){
    button[i].setOnClickListener(mOnClickListener);
}


如果你想改事件, 那麼就直接改裡面的事件囉,
所以看情況來決定使用的方法才是一個重點!


/******************************************************************************/
Android - LayoutInflater
/******************************************************************************/
在實際開發中LayoutInflater這個類還是非常有用的，它的作用類似於findViewById()。
不同點是LayoutInflater是用來找res/layout/下的xml佈局文件，並且實例化；而findViewById()是找xml佈局文件下的具體widget控件(如 Button、TextView等)。
具體作用：
1、對於一個沒有被載入或者想要動態載入的界面，都需要使用LayoutInflater.inflate()來載入；
2、對於一個已經載入的界面，就可以使用Activiyt.findViewById()方法來獲得其中的界面元素。
LayoutInflater 是一個抽像類，在文檔中如下聲明：
 
Java代碼
public abstract class LayoutInflater extends Object    
 獲得 LayoutInflater 實例的三種方式：
 
Java代碼
1. LayoutInflater inflater = getLayoutInflater();  //調用Activity的getLayoutInflater()  
2. LayoutInflater localinflater =  (LayoutInflater)context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);  
3. LayoutInflater inflater = LayoutInflater.from(context);     
   
其實，這三種方式本質是相同的，從源碼中可以看出：
getLayoutInflater()：
Activity 的 getLayoutInflater() 方法是調用 PhoneWindow 的getLayoutInflater()方法，看一下該源代碼：
 
Java代碼
public PhoneWindow(Context context) {    
        super(context);    
        mLayoutInflater = LayoutInflater.from(context);    
}    
 可以看出它其實是調用 LayoutInflater.from(context)。
LayoutInflater.from(context)：
Java代碼
 
public static LayoutInflater from(Context context) {     
    LayoutInflater LayoutInflater =     
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);     
    if (LayoutInflater == null) {     
        throw new AssertionError("LayoutInflater not found.");     
    }     
    return LayoutInflater;     
}   
 
可以看出它其實調用 context.getSystemService()。
 
結論：所以這三種方式最終本質是都是調用的Context.getSystemService()。
 
inflate 方法 
通過 sdk 的 api 文檔，可以知道該方法有以下幾種過載形式，返回值均是 View 對像，如下：
Java代碼
 
public View inflate (int resource, ViewGroup root)    
public View inflate (XmlPullParser parser, ViewGroup root)    
public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)    
public View inflate (int resource, ViewGroup root, boolean attachToRoot)   
 1：
  public View inflate (int resource, ViewGroup root) 
  reSource：View的layout的ID
  root：如果為null，則將此View作為根,此時既可以應用此View中的其他控件了。
          如果!null,  則將默認的layout作為View的根。
 2:
  public View inflate ( XmlPullParser parser, ViewGroup root) 
   parser:你需要解析xml的解析介面
   root：如果null，則將此View作為根,此時既可以應用此View中的其他控件了。
          如果!null, 則將默認的layout作為View的根。
 3:
  public View inflate ( XmlPullParser parser, ViewGroup root, boolean attachToRoot) 
   parser:你需要解析View的xml的解析介面
   root：如果null，則將此View作為根,此時既可以應用此View中的其他控件了。
          如果!null, 則將默認的layout作為View的根。
   attachToRoot：
   ture：也就將此解析的xml作為View根
   fase：則為默認的xml，做為根視圖View
 4:
  public View inflate (int resource, ViewGroup root, boolean attachToRoot) 
  resource：View的layout的ID
  root：如果null，則將此View作為根,此時既可以應用此View中的其他控件了。
           如果!null, 則將默認的layout作為View的根。
  attachToRoot：
  ture：也就將此解析的xml作為View根
  fase：則為默認的xml，做為根視圖View
 
示意代碼：
Java代碼
 
LayoutInflater inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);    
View view = inflater.inflate(R.layout.custom, (ViewGroup)findViewById(R.id.test));    
    
//EditText editText = (EditText)findViewById(R.id.content);// error    
EditText editText = (EditText)view.findViewById(R.id.content);   
 同時在此講講讓我去API中去理解這四個函數的原因吧！嘿嘿！你肯定又會多學一招！ 
在Activity中：
大家是否知道,在setContentView(new MySurfaceView(this))後，此Activity中聲明的View控件，
如：TextView 為什麼引用不到layout佈局文件中的控件ID呢！初一看能夠應用到，但是為什麼編譯就報空指針呢！原因：在setContentView(new MySurfaceView(this))後，此時的View變為了根視圖了，雖然能應用到TextView對應的ID,但是我在 MySurfaceView中根本就沒有這個對象，所以就報空指針咯！解決辦法：
View view = LayoutInflater.from(this).inflate(R.layout.passover, null);註：每解析一次都會產生不同的對象 
然後你再引用沒問題，使用自如了。


/******************************************************************************/
Android Back Key  from: http://milkmidi.blogspot.tw/2012/01/android-back-key.html
/******************************************************************************/
在使用 Android 時，有時會不小心按到 Back 鍵而離開應用程式
理想的操作，應該要有個提示讓使用者知道是否要離開。
只要 Override Activity 的 onKeyDown 事件，
加上提示的程式即可
常用的方法有二個，
1. 使用 Toast 提示，在一定的時間內按二次 Back 鍵
private long exitTime = 0;

@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
 if(keyCode == KeyEvent.KEYCODE_BACK
   && event.getAction() == KeyEvent.ACTION_DOWN){
     if((System.currentTimeMillis()-exitTime) > 2000){
         Toast.makeText(getContext(), "再按一次退出程式", Toast.LENGTH_SHORT).show();
         exitTime = System.currentTimeMillis();
  } else {
   finish();
   System.exit(0);
  }
     return true;
    }
 return super.onKeyDown(keyCode, event);
}



2. 使用 AlertDialog ，讓使用者自行決定。
new AlertDialog.Builder( getContext)
.setIcon(R.drawable.icon_info).setTitle("  ")
.setMessage("確定要離開應用程式嗎?")
.setNegativeButton("取消", new OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {

}
}).setNeutralButton("確定", new OnClickListener() {
 @Override
 public void onClick(DialogInterface dialog, int which) {
  finish();
   System.exit(0);
 }
}).create().show();


/******************************************************************************/
Android: main.out.xml文件
/******************************************************************************/
在使用 eclipse 開發時，會很自然的切換到 xml 來編輯 layout 或是 resource 
然後ctrl + F11(run), 結果碰到下面的錯誤:
Error in an XML file: aborting build.
res\layout\main.xml:0: error: Resource entry main is already defined.
res\layout\main.out.xml:0: Originally defined here.
方法：
要執行時, 把焦點由 xml 移開到專案
在 Project->Clean 清除目前的編譯
刪除多餘的 xxx.out.xml
再重新 run 一次
超麻煩。因此要問問Google , 有沒有較好的方法，以下找到另一個方法，一次搞定。
http://www.cnblogs.com/chunhui588/archive/2010/06/26/Android-debug-main-out-xml-parsing-error.html


/******************************************************************************/
取得螢幕大小    from: http://abow520.blogspot.tw/2011/10/blog-post.html
/******************************************************************************/
DisplayMetrics

DisplayMetrics dm = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(dm);
dm.widthPixels;
dm.heightPixels;

DP 換算 Pixels
Resources r = getResources();
 (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, Value, r.getDisplayMetrics())


/******************************************************************************/
播放MP3         from: http://abow520.blogspot.tw/2011/08/mp3.html#more
/******************************************************************************/
AndroidManifest.xml
<service android:name=".MusicService">
    <intent-filter>
        <action android:name="com.angel.Android.MUSIC"/>
        <category android:name="android.intent.category.default"/>
    </intent-filter>
</service>


Code
public class MusicService extends Service {
    private MediaPlayer mediaPlayer;
    @Override 
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override 
    public void onStart(Intent intent,int startId){
        super.onStart(intent, startId);
        if(mediaPlayer==null){
            mediaPlayer = new MediaPlayer();
            try {
                mediaPlayer.setDataSource(mp3路徑);
                mediaPlayer.setLooping(true);
  mediaPlayer.prepare();
                mediaPlayer.start();
     } catch (IllegalArgumentException e) {
         // TODO Auto-generated catch block
     } catch (IllegalStateException e) {
  // TODO Auto-generated catch block
            } catch (IOException e) {
  // TODO Auto-generated catch block
     }
        }
    }

    @Override
    public void onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy();
        mediaPlayer.stop();
    }

開始/停止 音樂
private void MusicControl(int musicStatus){
    Intent i=new Intent(this, MusicService.class);
    switch( musicStatus){
        case 0:
            /* 音樂開啟 */
     this.startService(i);
            /* 變更音樂圖示 */
     ibtnMusic.setBackgroundResource(R.drawable.musicon);
     break;
 case 1:
     this.stopService(i);
     ibtnMusic.setBackgroundResource(R.drawable.musicoff);
     break;
    }
}


/******************************************************************************/
android-ListView
/******************************************************************************/
LinearLayout myLinearLayout = (LinearLayout) findViewById(R.id.lvContactList);
myLinearLayout.removeAllViews();
ListView myListView = new ListView(this);
LinearLayout.LayoutParams param = new LinearLayout.LayoutParams(
    LinearLayout.LayoutParams.FILL_PARENT,
    LinearLayout.LayoutParams.WRAP_CONTENT);

myListView.setBackgroundColor(android.graphics.Color.BLACK);
myListView.setDividerHeight(2);
myLinearLayout.addView(myListView, param);

ArrayList< HashMap < String,String >> myArrayList=
       new ArrayList< HashMap < String,String > >();

HashMap< String, String > map = new HashMap< String, String >();
map.put("itemDispalyName",連絡人姓名)));
map.put("itemDispalyName",連絡人電話)));
map.put("itemDispalyName",連絡人email)));

SimpleAdapter mySimpleAdapter=
       new SimpleAdapter(this, myArrayList,R.layout.listviewdemo,new String[]
          {"itemDispalyName","itemPhone","itemEmail"}, new int[] 
          {R.id.itemName,R.id.itemPhone,R.id.itemEmail});

myListView.setAdapter(mySimpleAdapter);

//-------------------------------------------------------------------
ListView中需要動態載入圖片的範例
利用HastMap <string,object>
及setViewBinder達成

LinearLayout lvAttendList = (LinearLayout) findViewById(R.id.lvAttendingList);
lvAttendList.removeAllViews();
ListView AttendList = new ListView(this);
LinearLayout.LayoutParams param = new LinearLayout.LayoutParams(
     LinearLayout.LayoutParams.FILL_PARENT,
     LinearLayout.LayoutParams.WRAP_CONTENT);
lvAttendList.addView(AttendList, param);

List<hashmap<string,object> myArrayList=new ArrayList<hashmap<string,object>();
HashMap<string, object> map = new HashMap<string, object=>();
map.put("strUserName", liReplyStatus.get(i).getUserName());
map.put("strReplyStatus", liReplyStatus.get(i).getReplyStatus());
map.put("imgUser", liReplyStatus.get(i).getUserePic());
myArrayList.add(map); 

SimpleAdapter mySimpleAdapter=new SimpleAdapter(this, 
      myArrayList,
      R.layout.activity_reply_status_list,
      new String[]{"strUserName","strReplyStatus","imgUser"}, 
      new int[]{R.id.txtUserName,R.id.txtReplyStatus,R.id.imgUserPic});
mySimpleAdapter.setViewBinder(new ViewBinder(){
    public boolean setViewValue(View view, 
        Object data, 
        String textRepresentation) {  
        if(view instanceof ImageView  && data instanceof Bitmap ){
            if (data != null){
                ImageView iv = (ImageView) view;  
                iv.setImageBitmap((Bitmap) data);
            }
            return true;     
        }else  
            return false;  
    }  
});
AttendList.setAdapter(mySimpleAdapter);


/******************************************************************************/
Create a custom multi-line ListView bound to an ArrayList in Android
ref: http://sochinda.wordpress.com/2012/02/08/create-a-custom-multi-line-listview-bound-to-an-arraylist-in-android/
/******************************************************************************/
The Android HelloListView tutorial shows how to bind a ListView to an array of string objects, but you'll probably outgrow that pretty quickly. 
This post will show you how to bind the ListView to an ArrayList of custom objects, as well as create a multi-line ListView.
Let's say you have some sort of search functionality that returns a list of people, along with addresses and phone numbers. 
We're going to display that data in three formatted lines for each result, and make it clickable.
First, create your new Android project, and create two layout files. Main.xml will probably already be created by default, so paste this in:

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TextView
        android:layout_height="wrap_content"
        android:text="Custom ListView Contents"
        android:gravity="center_vertical|center_horizontal"
        android:layout_width="fill_parent" />
    <ListView
        android:id="@+id/ListView01"
        android:layout_height="wrap_content"
        android:layout_width="fill_parent"/>
</LinearLayout>

Next, create a layout file called custom_row_view.xml. This layout will be the template for each individual row in the ListView. 
You can use pretty much any type of layout – Relative, Table, etc., but for this we'll just use Linear:

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TextView android:id="@+id/name"
        android:textSize="14sp"
        android:textStyle="bold"
        android:textColor="#FFFF00"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/cityState"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/phone"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
</LinearLayout>

Now, add an object called SearchResults. Paste this code in:
public class SearchResults {
    private String name = "";
    private String cityState = "";
    private String phone = "";

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setCityState(String cityState) {
        this.cityState = cityState;
    }

    public String getCityState() {
        return cityState;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getPhone() {
        return phone;
    }
}
This is the class that we』ll be filling with our data, and loading into an ArrayList.

Next, you'll need a custom adapter. This one just extends the BaseAdapter, but you could extend the ArrayAdapter if you prefer.
public class MyCustomBaseAdapter extends BaseAdapter {
    private static ArrayList<SearchResults> searchArrayList;

    private LayoutInflater mInflater;
    public MyCustomBaseAdapter(Context context, ArrayList<SearchResults> results) {
        searchArrayList = results;
        mInflater = LayoutInflater.from(context);
    }

    public int getCount() {
        return searchArrayList.size();
    }

    public Object getItem(int position) {
        return searchArrayList.get(position);
    }

    public long getItemId(int position) {
        return position;
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;
        if (convertView == null) {
            convertView = mInflater.inflate(R.layout.custom_row_view, null);
            holder = new ViewHolder();
            holder.txtName = (TextView) convertView.findViewById(R.id.name);
            holder.txtCityState = (TextView) convertView.findViewById(R.id.cityState);
            holder.txtPhone = (TextView) convertView.findViewById(R.id.phone);

            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }
            holder.txtName.setText(searchArrayList.get(position).getName());
            holder.txtCityState.setText(searchArrayList.get(position).getCityState());
            holder.txtPhone.setText(searchArrayList.get(position).getPhone());

            return convertView;
    }

    static class ViewHolder {
        TextView txtName;
        TextView txtCityState;
        TextView txtPhone;
    }
}

(This is basically the same as the List14.java API demo)

Finally, we』ll wire it all up in the main class file:
public class CustomListView extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        ArrayList<SearchResults> searchResults = GetSearchResults();

        final ListView lv1 = (ListView) findViewById(R.id.ListView01);
        lv1.setAdapter(new MyCustomBaseAdapter(this, searchResults));

        lv1.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> a, View v, int position, long id) {
                Object o = lv1.getItemAtPosition(position);
                SearchResults fullObject = (SearchResults)o;
                Toast.makeText(ListViewBlogPost.this, "You have chosen: " + " " + fullObject.getName(), Toast.LENGTH_LONG).show();
            }
        });
    }

    private ArrayList<SearchResults> GetSearchResults(){
        ArrayList<SearchResults> results = new ArrayList<SearchResults>();

        SearchResults sr1 = new SearchResults();
        sr1.setName("John Smith");
        sr1.setCityState("Dallas, TX");
        sr1.setPhone("214-555-1234");
        results.add(sr1);

        sr1 = new SearchResults();
        sr1.setName("Jane Doe");
        sr1.setCityState("Atlanta, GA");
        sr1.setPhone("469-555-2587");
        results.add(sr1);

        sr1 = new SearchResults();
        sr1.setName("Steve Young");
        sr1.setCityState("Miami, FL");
        sr1.setPhone("305-555-7895");
        results.add(sr1);

        sr1 = new SearchResults();
        sr1.setName("Fred Jones");
        sr1.setCityState("Las Vegas, NV");
        sr1.setPhone("612-555-8214");
        results.add(sr1);

        return results;
    }
}

Notice that we first get an ArrayList of SearchResults objects (normally this would be from an external data source…), 
pass it to the custom adapter, then set up a click listener. The listener gets the item that was clicked, 
converts it back to a SearchResults object, and does whatever it needs to do.
Fire it up in the emulator, and you should wind up with something like this:


/******************************************************************************/
android dialog用法匯總  from : http://fecbob.pixnet.net/blog/post/35494291-android-dialog%E7%94%A8%E6%B3%95%E5%8C%AF%E7%B8%BD
/******************************************************************************/
1、AlertDialog，具有0-3個按鈕，可以放選項、核取方塊單選框等，以建議的方式域使用者交互可以。
2、ProgressDialog，顯示一個進度的圓環或者進度條。
3、DataPickerDialog，選擇日期的dialog。
4、TimePickerDialog，選擇時間的dialog。

使用者可以繼承Dialog類或者它的子類並且創建一個新的leyout。

Showing a Dialog
Dialog總是作為一個Activity的一部分來創建和顯示的。正常可以使用Activity的onCreateDialog（int）回呼函數來創建Dialog。
使用這個回呼函數的時候，系統會自動管理每個dialog的狀態，並把它們關聯到這個Activity，有效的使它成為dialog的所有者。
這樣每個第啊咯個都從父Activity繼承一些屬性。
For example, when a dialog is open, the Menu key reveals the options menu defined for the Activity and the volume keys modify the audio stream used by 
the Activity.
注意：如果你在onCreate（）之外創建dialog，他不會附屬於任何的Activity，可以使用dialog的setOwnerActivity(Activity)來設置。
當想顯示一個dialog的時候，調用showDialog（int），並傳遞一個整數來唯一標識想要顯示的dialog即可。
當第一次使用一個dialog的時候，Android會調用onCreateDialog（int），應該在這裡創建dialog。這個回檔方法的參數是你傳遞給showDialog（int）的id。創建Dialog結束後，返回這個dialog物件。
在現實一個dialog之前，Android會先用可選的回檔非法onPrepareDialog（int）。如果想在每次打開dialog的時候改變它的屬性就可以通過重寫這個方法來實現。他會在每次打開dialog的時候被調用，而onCreateDialog（int）只在第一次打開一個dialog的時候調用。如果不定義onPrepareDialog（），那麼dialog將保持塌方上次被打開的屬性。This method is also passed the dialog's ID, along with the Dialog object you created in onCreateDialog()。

創建Dialog的Example：
static final int DIALOG_PAUSED_ID = 0;
static final int DIALOG_GAMEOVER_ID = 1;
protected Dialog onCreateDialog(int id) {
    Dialog dialog;
    switch(id) {
        case DIALOG_PAUSED_ID:
            // do the work to define the pause Dialog
            break;
        case DIALOG_GAMEOVER_ID:
            // do the work to define the game over Dialog
            break;
        default:
            dialog = null;
    }
    return dialog;
}
顯示創建的dialog：showDialog(DIALOG_PAUSED_ID);

Dismissing a Dialog
當準備關閉dialog的時候，可以調用dialogobject的dismiss（）方法。如果必要，可以調用Activity的dismissDialog（int），它會有效的調用dialog的dismiss（）。
如果你使用onCreateDialog(int)來管理dialog的狀態，那麼每次關閉dialog的時候，dialog的狀態都會被Activity保存。如果這個dialog不會再次被使用或者清除它的狀態很
重要，可以調用removeDialog（int），這回清除內部任何對它的引用，如果它正在顯示，會被關閉。
Using dismiss listeners
如果想在dialog被關閉的時候執行一些操作，應該為dialog設置on-dismiss listener。
首先定義DialogInterfacev.OnDismissListener介面。這個介面只有一個方法，vonDismiss(DialogInterface)，當關閉dialog的時候會調用這個方法。
把OnDismissListener的實現傳遞給setOnDismissListener（）就可以了。
注意，dialog可以被取消。這是由使用者顯示取消dialog的特殊情況,在使用者點擊back鍵或者顯示調用cancel（）函數就是這種情況。
當dialog被cancel的時候，OnDismissListener不會被通知，如果你想知道dialog被顯示的cancel（不是正常的關閉），那麼你應該用setOnCancel（）
註冊一個vDialogInterface.OnCancelListener。

Creating an AlertDialog
AlertDialog是Dialog的子類，它可以構造使用者交互的多數dialog，是建議的dialog類型。下列情況可以使用AldertDialog：
A tittle；
A text message；
One，two，or three buttons；
A list of selectable items （with optional checkboxes or radio buttons）
可以使用AlertDialog.Builder的子類來創建AlertDialog。通過AlertDialogBuilder(Context)來創建一個builder並使用這個builder的public方法來定義AlertDialog的所有
屬性。在使用builder創建結束後，使用create（）來得到創建的AlertDialog物件。
The following topics show how to define various properties of the AlertDialog using the AlertDialog.Builder class. If you use any of the following sample
code inside your onCreateDialog() callback method, you can return the resulting Dialog object to display the dialog.

Adding buttons
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setMessage("Are you sure you want to exit?")
    .setCancelable(false)
    .setPositiveButton("Yes", new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int id) {
            MyActivity.this.finish();
        }
    })
    .setNegativeButton("No", new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int id) {
            dialog.cancel();
        }
    });
    AlertDialog alert = builder.create();
注意：每種類型的按鈕只能添加一個。這限制了按鈕的個數（3個）。這些名字於其功能無關只用來說明你記住這些按鈕是幹嘛的。

Adding a list
final CharSequence[] items = {"Red", "Green", "Blue"};
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("Pick a color");
builder.setItems(items, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
            Toast.makeText(getApplicationContext(), items[item], Toast.LENGTH_SHORT).show();
    }
});
AlertDialog alert = builder.create();

Adding checkboxes and radio buttons
可以用vsetMultiChoiceitems()和setSingleChoiceItems()來在AlertDialog上設置多選或者單選清單。如果使用onCreateDialog()創建這些選項清單，那麼Android會維護這個選項清單的狀態。在Activity存活期間，這個dialog會記住先前的選項狀態，但是當使用者利卡這個Activity時，選項狀態就會丟失。
注意：為了在使用者退出或者暫停這個Activity時保存選項狀態，你必須在整個Activity的生命週期中恰當的保存和恢復選項狀態。為了永久的保存選項狀態（甚至在Activity進程完全結束之後），你應該使用資料存儲技術來保存選項狀態。
To create an AlertDialog with a list of single-choice items like the one shown to the right, use the same code from the previous example, but replace the setItems() method with setSingleChoiceItems():
final CharSequence[] items = {"Red", "Green", "Blue"};
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("Pick a color");
builder.setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener() {
    public void onClick(DialogInterface dialog, int item) {
        Toast.makeText(getApplicationContext(), items[item], Toast.LENGTH_SHORT).show();
    }
});
AlertDialog alert = builder.create();
在setSingleChoiceItems()的第二個參數是一個整形表示哪個item被選中，item的標識從0開始，-1表示沒有item預設被選中。

Creating a ProgressDialog
ProgressDialog是AlertDialog的子類，可以顯示進度動畫：用旋轉的環表示進度未定義的task；用進度條表示定義了進度的task。這個dialog也可以提供按鈕，比如下載過程中的取消按鈕。
打開一個進度dialog簡單到只要調用ProgressDialog.show()就可以了。
比如：
ProgressDialog dialog = ProgressDialog.show(MyActivity.this, "","Loading. Please wait...", true);
第一個參數是程式的context, 第二個參數是tittle,第三個是message, 
第三個參數表示這個progress時候是不清楚的(它只在創建進度條的時候有意義, which is discussed in the next section).

Showing a progress bar
顯示一個用動畫表示進度的進度條：
1、用構造方法ProgressDialog(Context)初始一個ProgressDialog。
2、用setProgressStyle(int)設置style為STYLE_HORIZONTAL，並設置其他的屬性，比如message等。
3、準備顯示dialog的時候調用show()或者使用onCreateDialog(int)來返回這個ProgressDialog。
4、可以調用setProgress(int)傳遞目前完成的全部百分比或者vincrementProgressBy(int)傳遞增量值來增加進度條顯示的進度。
比如：
ProgressDialog progressDialog;
progressDialog = new ProgressDialog(mContext);
progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(false);
設置ProgressDialog很簡單，創建ProgressDialog的多數代碼多數是用來更新它的。你會發現需要使用Handler來創建新的執行緒來進行這項工作並把進度反映到Activity的UI上。
Example ProgressDialog with a second thread
This example uses a second thread to track the progress of a process (which actually just counts up to 100). The thread sends a Message back to the main Activity through a Handler each time progress is made. The main Activity then updates the ProgressDialog.

package com.example.progressdialog;
import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
導入 android.os.Bundle ；
導入 android.os.Handler ；
導入 android.os.Message ；
導入 android.view.View ；
導入 android.view.View.OnClickListener ；
導入 android.widget.Button ；

公共類 NotificationTest 擴展活動 {
靜態最後 int PROGRESS_DIALOG = 0 ；
按鈕 ；
ProgressThread progressThread ；
此時的此時 ；

/ ** 第一次創建活動時調用。*/
public void 倚仗 （Bundle savedInstanceState) {
    super.onCreate(savedInstanceState) ；
    setContentView(R.layout.main) ；

    / / 設置啟動進度對話方塊中的按鈕
    button = findViewById(R.id.progressDialog) （Button） ；
    button.setOnClickListener （new OnClickListener() {
        pulic void onClick (View v) {
            showDialog(PROGRESS_DIALOG) ；
    }
    });
}

保護對話方塊的 onCreateDialog(int id) {
    switch(id) {
        case （PROGRESS_DIALOG）：
            此時 = new ProgressDialog(NotificationTest.this) ；
            progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL) ；
            progressDialog.setMessage("Loading...") ；
            progressThread = new ProgressThread(handler) ；
            progressThread.start() ；
            return；
        default：
            return；
    }
}

/ / 定義的處理常式接收來自該執行緒的消息和更新進度
處理常式的最終處理常式 = new Handler() {
    public void handleMessage (消息味精) {
        int sum = msg.getData().getInt("total") ；
        progressDialog.setProgress(total) ；
        if (sum > = 100) {
            dismissDialog(PROGRESS_DIALOG) ；
            progressThread.setState(ProgressThread.STATE_DONE) ；
        }
    }
};

/ ** 嵌套類的執行進度計算 （計算） * /
private ProgressThread 類執行緒 {
    MHandler 處理常式 ；
    final static int STATE_DONE = 0 ；
    final static int STATE_RUNNING = 1 ；
    int mState；
    int sum；

    ProgressThread (處理常式 h) {
        mHandler = h ；
    }

    public void run() {
        mState = STATE_RUNNING ；
        sum = 0 ；
        if （mState = = STATE_RUNNING) {
            try {
            Thread.sleep(100) ；
            } catch (InterruptedException e) {
                Log.e （"錯誤"，"執行緒中斷"） ；
            }
            消息味精 = mHandler.obtainMessage() ；
            Bundle b = new Bundle() ；
            b.putInt("sum", sum） ；
            msg.setData(b) ；
            mHandler.sendMessage(msg) ；
            ++sum ；
        }
    }

    / * 設置執行緒的當前狀態
    * 用於停止執行緒 * /
    public void setState(int state) {
        mState = state;
        }
    }
}

Creating a Custom Dialog
如果需要一個自訂設計的dialog，你可以創建自己的layout。定義好layout後，傳遞root View物件或者leyout資源ID給setContentView(View)。
例如：
1、創建XML layout：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/layout_root"
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:padding="10dp">
    <ImageView android:id="@+id/image"
        android:layout_width="wrap_content"
        android:layout_height="fill_parent"
        android:layout_marginRight="10dp"
    />
    <TextView android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="fill_parent"
        android:textColor="#FFF"
    />
</LinearLayout>
2、設置這個layout為這個dialog的內容 並定義ImageView和TextView的內容。
Context mContext = getApplicationContext();
Dialog dialog = new Dialog(mContext);
dialog.setContentView(R.layout.custom_dialog);
dialog.setTitle("Custom Dialog");
TextView text = (TextView) dialog.findViewById(R.id.text);
text.setText("Hello, this is a custom dialog!");
ImageView image = (ImageView) dialog.findViewById(R.id.image);
image.setImageResource(R.drawable.android);
在初始化dialog後，使用setContentView(int)設置自訂的layout為dialog的content view。這時這個dialog已
經定義好了layout，你可以使用dialog的findViewByID(int)來從layout中得到View物件，並修改其中的內容。
3、好了，現在你可以顯示這個dialog了。
通過基類Dialog創建的dialog的必須有tittle，如果不調用setTittle()，那麼tittle的空間會空著而且可見。如果你根本不需要tittle，那麼應該使用AlertDialog來創建自訂的dialog。因為使用AlertDialog.Builder來創建AlertDialog更容易，你也不需要訪問vsetContentView(int)而是用setView(View)。它接受一個View物件參數，所以你需要inflate the layout's root View object from XML。
To inflate the XML layout，使用getLayoutInflater()或者getSystemService()得到LayoutInflater，然後調用inflate(int, ViewGroup)（第一個參數是layout的資源ID，第二個是root view的識別字）。至此，你可以用這個inflated layout來得到layout中的View物件並且定義其中的內容了。然後初始AlertDialog.Builder並setView為這個inflated layout。
例如：
AlertDialog.Builder builder;
AlertDialog alertDialog;
Context mContext = getApplicationContext();
LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(LAYOUT_INFLATER);
View layout = inflater.inflate(R.layout.custom_dialog,
(ViewGroup) findViewById(R.id.layout_root));
TextView text = (TextView) layout.findViewById(R.id.text);
text.setText("Hello, this is a custom dialog!");
ImageView image = (ImageView) layout.findViewById(R.id.image);
image.setImageResource(R.drawable.android);
builder = new AlertDialog.Builder(mContext);
builder.setView(layout);
alertDialog = builder.create();
Using an AlertDialog for your custom layout lets you take advantage of built-in AlertDialog features like managed buttons, selectable lists, a title, an icon and so on.

 
/******************************************************************************/
TabHost.TabSpec         from: http://www.cnblogs.com/over140/archive/2010/12/13/1904085.html
/******************************************************************************/
前言
　　本章內容是 android.widget.TabHost.TabSpec，版本為Android 2.3 r1，翻譯來自"madgoat"，歡迎大家訪問他的博客：http://madgoat.cn/，
再次感謝"madgoat" ！期待你加入Android中文翻譯組，聯繫我over140@gmail.com。
 
正文
一、結構
public class TabHost.TabSpec extends Object
java.lang.Object
android.widget.TabHost.TabSpec

二、概述
每個選項卡都有一個選項卡指示符,內容和tag標籤用於跟蹤。這種生成器可以幫助從這些選項中做出選擇。針對選項卡的指示符，你可以選擇：
1)設置一個標題
2)設置一個標題和圖示
針對選項卡的內容，你可以選擇：
1)視圖的ID
2)TabHost.TabContentFactory創建的視圖內容
3)加載Activity的Intent對像

三、公共方法
public String getTag () （譯者註：獲取tag標籤字串）
public TabHost.TabSpec setContent (int viewId)
為選項卡的內容指定視圖的ID（譯註：即設定選項卡內容的視圖）
public TabHost.TabSpec setContent (Intent intent)
指定一個加載activity的Intent對像作為選項卡內容
public TabHost.TabSpec setContent (TabHost.TabContentFactory contentFactory)
指定一個TabHost.TabContentFactory用於創建選項卡的內容
public TabHost.TabSpec setIndicator (CharSequence label)
指定一個標籤作為選項卡指示符
public TabHost.TabSpec setIndicator (View view)
指定一個視圖作為選項卡指示符
public TabHost.TabSpec setIndicator (CharSequence label, Drawable icon)
為選項卡指示符指定一個標籤和圖示

四、補充
文章鏈接
TabHost中的TabSpec的標題能不能縮小啊？
android的TabActivity

五、相關章節
android 2.3 r1 中文 api (58) —— TabHost


/******************************************************************************/
ArrayList的使用方法【轉載】 ref: http://120152191.blog.163.com/blog/static/9310785201010951232442/ 
/******************************************************************************/
1、什麼是ArrayList
    ArrayList就是傳說中的動態數組，用MSDN中的說法，就是Array的複雜版本，它提供了如下一些好處：
動態的增加和減少元素 
實現了ICollection和IList介面 
靈活的設置數組的大小

2、如何使用ArrayList
最簡單的例子：
ArrayList List = new ArrayList();
for( int i=0;i<10;i++ ) //給數組增加10個Int元素
    List.Add(i); 
//..程式做一些處理
List.RemoveAt(5);//將第6個元素移除
for( int i=0;i<3;i++ ) //再增加3個元素
    List.Add(i+20);
Int32[] values = (Int32[])List.ToArray(typeof(Int32));//返回ArrayList包含的數組
這是一個簡單的例子，雖然沒有包含ArrayList所有的方法，但是可以反映出ArrayList最常用的用法

3、ArrayList重要的方法和屬性
（1）構造器
ArrayList提供了三個構造器：
public ArrayList();
默認的構造器，將會以默認（16）的大小來初始化內部的數組
public ArrayList(ICollection);
用一個ICollection對像來構造，並將該集合的元素添加到ArrayList
public ArrayList(int);
用指定的大小來初始化內部的數組
（2）IsSynchronized屬性和ArrayList.Synchronized方法
IsSynchronized屬性指示當前的ArrayList實例是否支援線程同步，而ArrayList.Synchronized靜態方法則會返回一個ArrayList的線程同步的封裝。
如果使用非線程同步的實例，那麼在多線程訪問的時候，需要自己手動調用lock來保持線程同步，例如：
ArrayList list = new ArrayList();
//...
lock( list.SyncRoot ) //當ArrayList為非線程包裝的時候，SyncRoot屬性其實就是它自己，但是為了滿足ICollection的SyncRoot定義，這裡還是使用SyncRoot來保持源代碼的規範性
{
    list.Add( 「Add a Item」 );
}
如果使用ArrayList.Synchronized方法返回的實例，那麼就不用考慮線程同步的問題，這個實例本身就是線程安全的，實際上ArrayList內部實現了一個保證線程同步的內部類，ArrayList.Synchronized返回的就是這個類的實例，它裡面的每個屬性都是用了lock關鍵字來保證線程同步。

****
但是，使用這個方法（ArrayList.Synchronized）並不能保證枚舉的同步，例如，一個線程正在刪除或添加集合項，而另一個線程同時進行枚舉，這時枚舉將會拋出異常。所以，在枚舉的時候，你必須明確使用 SyncRoot 鎖定這個集合。
Hashtable與ArrayList關於線程安全性的使用方法類似。
****
（3）Count屬性和Capacity屬性
Count屬性是目前ArrayList包含的元素的數量，這個屬性是只讀的。
Capacity屬性是目前ArrayList能夠包含的最大數量，可以手動的設置這個屬性，但是當設置為小於Count值的時候會引發一個異常。
（4）Add、AddRange、Remove、RemoveAt、RemoveRange、Insert、InsertRange
這幾個方法比較類似
Add方法用於添加一個元素到當前列表的末尾
AddRange方法用於添加一批元素到當前列表的末尾
Remove方法用於刪除一個元素，通過元素本身的引用來刪除
RemoveAt方法用於刪除一個元素，通過索引值來刪除
RemoveRange用於刪除一批元素，通過指定開始的索引和刪除的數量來刪除
Insert用於添加一個元素到指定位置，列表後面的元素依次往後移動
InsertRange用於從指定位置開始添加一批元素，列表後面的元素依次往後移動
另外，還有幾個類似的方法：
Clear方法用於清除現有所有的元素
Contains方法用來查找某個對象在不在列表之中
其他的我就不一一累贅了，大家可以查看MSDN，上面講的更仔細
（5）TrimSize方法
這個方法用於將ArrayList固定到實際元素的大小，當動態數組元素確定不在添加的時候，可以調用這個方法來釋放空餘的記憶體。
（6）ToArray方法
這個方法把ArrayList的元素Copy到一個新的數組中。


4、ArrayList與數組轉換
例1：
ArrayList List = new ArrayList();
List.Add(1);
List.Add(2);
List.Add(3);
Int32[] values = (Int32[])List.ToArray(typeof(Int32));
例2：
ArrayList List = new ArrayList();
List.Add(1);
List.Add(2);
List.Add(3);
Int32[] values = new Int32[List.Count];
List.CopyTo(values);
上面介紹了兩種從ArrayList轉換到數組的方法
例3：
ArrayList List = new ArrayList();
List.Add( 「string」 );
List.Add( 1 );
//往數組中添加不同類型的元素
object[] values = List.ToArray(typeof(object)); //正確
string[] values = (string[])List.ToArray(typeof(string)); //錯誤
和數組不一樣，因為可以轉換為Object數組，所以往ArrayList裡面添加不同類型的元素是不會出錯的，但是當調用ArrayList方法的時候，要麼傳遞所有元素都可以正確轉型的類型或者Object類型，否則將會拋出無法轉型的異常。
5、ArrayList最佳使用建議
這一節我們來討論ArrayList與數組的差別，以及ArrayList的效率問題
（1）ArrayList是Array的複雜版本
ArrayList內部封裝了一個Object類型的數組，從一般的意義來說，它和數組沒有本質的差別，甚至於ArrayList的許多方法，如Index、IndexOf、Contains、Sort等都是在內部數組的基礎上直接調用Array的對應方法。
（2）內部的Object類型的影響
對於一般的引用類型來說，這部分的影響不是很大，但是對於值類型來說，往ArrayList裡面添加和修改元素，都會引起裝箱和拆箱的操作，頻繁的操作可能會影響一部分效率。
但是恰恰對於大多數人，多數的應用都是使用值類型的數組。
消除這個影響是沒有辦法的，除非你不用它，否則就要承擔一部分的效率損失，不過這部分的損失不會很大。
（3）數組擴容
這是對ArrayList效率影響比較大的一個因素。
每當執行Add、AddRange、Insert、InsertRange等添加元素的方法，都會檢查內部數組的容量是否不夠了，如果是，它就會以當前容量的兩倍來重新構建一個數組，將舊元素Copy到新數組中，然後丟棄舊數組，在這個臨界點的擴容操作，應該來說是比較影響效率的。
例1：比如，一個可能有200個元素的數據動態添加到一個以默認16個元素大小創建的ArrayList中，將會經過：
16*2*2*2*2 = 256
四次的擴容才會滿足最終的要求，那麼如果一開始就以：
ArrayList List = new ArrayList( 210 );
的方式創建ArrayList，不僅會減少4次數組創建和Copy的操作，還會減少記憶體使用。
     例2：預計有30個元素而創建了一個ArrayList：
ArrayList List = new ArrayList(30);
在執行過程中，加入了31個元素，那麼數組會擴充到60個元素的大小，而這時候不會有新的元素再增加進來，而且有沒有調用TrimSize方法，那麼就有1次擴容的操作，並且浪費了29個元素大小的空間。如果這時候，用：
ArrayList List = new ArrayList(40);
那麼一切都解決了。
所以說，正確的預估可能的元素，並且在適當的時候調用TrimSize方法是提高ArrayList使用效率的重要途徑。
   （4）頻繁的調用IndexOf、Contains等方法（Sort、BinarySearch等方法經過優化，不在此列）引起的效率損失
首先，我們要明確一點，ArrayList是動態數組，它不包括通過Key或者Value快速訪問的算法，所以實際上調用IndexOf、Contains等方法是執行的簡單的循環來查找元素，所以頻繁的調用此類方法並不比你自己寫循環並且稍作優化來的快，如果有這方面的要求，建議使用Hashtable或SortedList等鍵值對的集合。
ArrayList al=new ArrayList();
al.Add("How");
al.Add("are");
al.Add("you!");
al.Add(100);
al.Add(200);
al.Add(300);
al.Add(1.2);
al.Add(22.8);
.........
//第一種遍歷 ArrayList 對象的方法
foreach(object o in al)
{
Console.Write(o.ToString()+" ");
}
//第二種遍歷 ArrayList 對象的方法
IEnumerator ie=al.GetEnumerator();
while(ie.MoveNext())
{
Console.Write(ie.Curret.ToString()+" ");
}
//第三種遍歷 ArrayList 對象的方法
我忘記了,好像是 利用 ArrayList對象的一個屬性,它返回一此對像中的元素個數.
然後在利用索引 
for(int i=0;i<Count;i++)
{
Console.Write(al[i].ToString()+" ");
}
*************************************************************************************

ListView 是android開發中最常用的元件之一，它通過一個adapter來構建顯示通常有三種adapter可以使用ArrayAdapter ，SimpleAdapter，CursorAdapter。CursorAdapter主要正對數據庫使用，下面通過例子介紹ArrayAdapter ，SimpleAdapter的簡單使用：
   1：ArrayAdapter 它接受一個數組或者List作為參數來構建。
      一下通過簡單例子說明：
  創建Test 繼承ListActivity 這裡我們傳入一個string數組

public class ListTest extends ListActivity {
    /** Called when the activity is first created. */

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        String[] sw = new String[100];
        for (int i = 0; i < 100; i++) {
            sw = "listtest_" + i;
        }
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,sw);//使用系統已經實現好的xml文件simple_list_item_1
        setListAdapter(adapter);
    }


/******************************************************************************/
Android藍牙開發淺談(轉載)
/******************************************************************************/
首先，要操作藍牙，先要在AndroidManifest.xml裡加入許可權
<uses-permissionandroid:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permissionandroid:name="android.permission.BLUETOOTH" />
然後，看下api，Android所有關於藍牙開發的類都在android.bluetooth包下，如下圖，只有8個類
BluetoothAdapter
BluetoothClass
BluetoothClass.Device
BluetoothClass.Device.Major
BluetoothClass.Service
BluetoothDevice
BluetoothServerSocket
BluetoothSocket

而我們需要用到了就只有幾個而已：
1.BluetoothAdapter 顧名思義，藍牙適配器，直到我們建立bluetoothSocket連接之前，都要不斷操作它
BluetoothAdapter裡的方法很多，常用的有以下幾個：
cancelDiscovery() 根據字面意思，是取消發現，也就是說當我們正在搜索設備的時候調用這個方法將不再繼續搜索
disable()關閉藍牙
enable()打開藍牙，這個方法打開藍牙不會彈出提示，更多的時候我們需要問下使用者是否打開，一下這兩行代碼同樣是打開藍牙，不過會提示使用者：
Intemtenabler=newIntent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
startActivityForResult(enabler,reCode);//同startActivity(enabler);
getAddress()獲取本地藍牙位址
getDefaultAdapter()獲取預設BluetoothAdapter，實際上，也只有這一種方法獲取BluetoothAdapter
getName()獲取本地藍牙名稱
getRemoteDevice(String address)根據藍牙位址獲取遠端藍牙設備
getState()獲取本地藍牙適配器當前狀態（感覺可能調試的時候更需要）
isDiscovering()判斷當前是否正在查找設備，是返回true
isEnabled()判斷藍牙是否打開，已打開返回true，否則，返回false
listenUsingRfcommWithServiceRecord(String name,UUID uuid)根據名稱，UUID創建並返回BluetoothServerSocket，這是創建BluetoothSocket伺服器端的第一步
startDiscovery()開始搜索，這是搜索的第一步
2.BluetoothDevice看名字就知道，這個類描述了一個藍牙設備
createRfcommSocketToServiceRecord(UUIDuuid)根據UUID創建並返回一個BluetoothSocket
這個方法也是我們獲取BluetoothDevice的目的——創建BluetoothSocket
這個類其他的方法，如getAddress(),getName(),同BluetoothAdapter
3.BluetoothServerSocket如果去除了Bluetooth相信大家一定再熟悉不過了，既然是Socket，方法就應該都差不多，
這個類一種只有三個方法
兩個重載的accept(),accept(inttimeout)兩者的區別在於後面的方法指定了過時時間，需要注意的是，執行這兩個方法的時候，直到接收到了用戶端的請求
（或是過[attach]3[/at期之後），都會阻塞執行緒，應該放在新執行緒裡運行！
還有一點需要注意的是，這兩個方法都返回一個BluetoothSocket，最後的連接也是伺服器端與用戶端的兩個BluetoothSocket的連接
close()這個就不用說了吧，翻譯一下——關閉！
4.BluetoothSocket,跟BluetoothServerSocket相對，是用戶端
一共5個方法，不出意外，都會用到
close(),關閉
connect()連接
getInptuStream()獲取輸入流
getOutputStream()獲取輸出流
getRemoteDevice()獲取遠端設備，這裡指的是獲取bluetoothSocket指定連接的那個遠端藍牙設備
寫到這的時候，恭喜你，你要用到的就只用這4個類！
但是你可能沒看懂，因為這跟看api沒什麼區別，不過就是翻譯過來了...沒錯，我之前看的大部分文章 都是這樣的，所以當時沒看完了，還是不知道怎麼入手
附件下載位址：http://www.apk-bbs.net/forum.php?mod=viewthread&tid=15&extra=page%3D1


/******************************************************************************/
[Android] bluetooth headset connect sequence    from: http://fecbob.pixnet.net/blog/post/34683347-%5Bandroid%5D-bluetooth-headset-connect-sequence
/******************************************************************************/
1. AndroidManifest.xml permission
<user-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<user-permission android:name="android.permission.BLUETOOTH />

2. Get BlueToothAdapter
BluetoothAdapter 通過類的靜態 api 的預設物件。
mBtAdapter = BluetoothAdapter.getDeafultAdapter();

3. Discovery檢索設備通過 bluetoothAdapter
mBtAdapter.startDiscovery();

4. Device Broadcast
如果您開始搜索，檢測到設備，該設備工具來進行廣播。
Get 操作只是為了給接收方註冊倚仗 () ACTION_FOUND
public void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstranceState);

    IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
    this.registerReceiver(mReceiver, filter);
    filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINSIHSED);
    this.registerReciver(mReceiver, filter);
}

private final BroadcastRecevier mReceiver = new BroadcastReceiver(){
    public void onReceiver(Context context, Intent intent){
        String action = intent.getAction();
        if(BluetoothDevice.ACTION_FOUND.equals(action)) {
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

            if(device.getBondState() != BluetoothDevice.BOND_BONDED){
                mNewDevicesArrayAdater.add(device.getName() + "\n" + device.getAddress());
            }
        }else if(BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)){
            setProgressBarIndeterminateVisibility(false);
            setTitle(R.string.select_device);
            if(mNewDevicesArrayAdapter.getCount() == 0){
                String noDevices = getText(R.string.non_found).toString();
                mNewDevicesArrayAdapter.add(noDevices);
            }
        }
    }
};
5.設備連接
讓我們停止搜索，連接設備之前設備
Android 開發網站，掃瞄作業看是奇慢，所以搜索是成功的或自己的資源，馬尼結束慌亂吃對 concelDiscovery 的調用。
此外，不調用 startDiscovery () () 調用 cancelDiscovery
因此，當對連接前無條件安全的藍牙設備 cancelDiscovery () 的調用。
mAdapter.cacnelDiscovery();

生成檢測到的設備 bluetoothDevice 通過 MAC 位址
BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);

Android 藍牙串口創建通訊端，取決於結構
使用 UUID uuid 模組將耳機與通信
現在使用耳機耳機連接服務的 uuid。大多數情況下，不過，不應只和最高人民檢察院抓住了免提相關聯。
為什麼是那裡諸如 A2DP 近似 Android 核心撥號程式從免提只，所以只有時間才能告訴該協定和 … …Heh heh heh
private static final UUID MY_UUID = UUID.fromString("00001108-0000-1000-8000-00805F9B34FB");
mmSocket = device.createRfcommSocketToServiceRecord(MY_UUID);

通過創建通訊端連接設備
mmSocket.connect();


/******************************************************************************/
Connecting to Bluetooth enabled device  from: http://androidcookbook.com/Recipe.seam?recipeId=1665
/******************************************************************************/
For any bluetooth application you need to add these two permissions to AndroidManifest.xml
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH" />

You will create the socket connection to the other bluetooth device. Then you shall continuously listen for the data from the socket stream in a thread.
 You can write to connected stream outside the thread. The connection is a blocking call and bluetooth device discovery being a heavy process, may slow 
 down the connection. So it is a good practice to cancel the device discovery before trying to connect to other device.

Note:The bluetooth socket connection is a blocking call and returns only if a connection is successful or if an exception occurs while connecting to device.
The BluetoothConnection shall create the socket connection to other device, once instantiated and start listening to the data from connected device.

private class BluetoothConnection extends Thread {
        private final BluetoothSocket mmSocket;
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;
        byte[] buffer;

        // Unique UUID for this application, you may use different
        private static final UUID MY_UUID = UUID
                        .fromString("fa87c0d0-afac-11de-8a39-0800200c9a66");
                        
        public BluetoothConnection(BluetoothDevice device) {
                
                BluetoothSocket tmp = null;

                // Get a BluetoothSocket for a connection with the given BluetoothDevice
                try {
                        tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
                } catch (IOException e) {
                        e.printStackTrace();
                }
                mmSocket = tmp;
                
                //now make the socket connection in separate thread to avoid FC
                Thread connectionThread  = new Thread(new Runnable() {
                                
                                @Override
                                public void run() {
                                        // Always cancel discovery because it will slow down a connection
                                        mAdapter.cancelDiscovery();

                                        // Make a connection to the BluetoothSocket
                                        try {
                                                // This is a blocking call and will only return on a
                                                // successful connection or an exception
                                                mmSocket.connect();
                                        } catch (IOException e) {
                                                //connection to device failed so close the socket
                                                try {
                                                        mmSocket.close();
                                                } catch (IOException e2) {
                                                        e2.printStackTrace();
                                                }
                                        }
                                }
                        });
                
                connectionThread.start();
                
                InputStream tmpIn = null;
                OutputStream tmpOut = null;

                // Get the BluetoothSocket input and output streams
                try {
                        tmpIn = socket.getInputStream();
                        tmpOut = socket.getOutputStream();
                        buffer = new byte[1024];
                } catch (IOException e) {
                        e.printStackTrace();
                }

                mmInStream = tmpIn;
                mmOutStream = tmpOut;
        }

        public void run() {
                
                // Keep listening to the InputStream while connected
                while (true) {
                        try {
                                //read the data from socket stream
                                mmInStream.read(buffer);
                                // Send the obtained bytes to the UI Activity
                        } catch (IOException e) {
                                //an exception here marks connection loss
                                //send message to UI Activity
                                break;
                        }
                }
        }

        public void write(byte[] buffer) {
                try {
                        //write the data to socket stream
                        mmOutStream.write(buffer);
                } catch (IOException e) {
                        e.printStackTrace();
                }
        }

        public void cancel() {
                try {
                        mmSocket.close();
                } catch (IOException e) {
                        e.printStackTrace();
                }
        }
}


/******************************************************************************/
Listening for Bluetooth Connection Requests.
/******************************************************************************/
Problem
Creating a listening server for Bluetooth Connections.

Solution
For Bluetooth devices to interact, prior to the establishment of a connection, one of the communicating devices acts like a server. 
It obtains an instance BluetoothServerSocket and listens for incoming requests. 
This instance is obtained by calling the listenUsingRfcommWithServiceRecord method on the Bluetooth adapter

Discussion
With the instance of BluetoothServerSocket, we can start listening for incoming requests from remote devices through the start() method. 
Listening is a blocking process so we have make a new thread and call it within the thread otherwise the UI of the application becomes unresponsive.


//Making the host device discoverable
startActivityForResult(new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE),DISCOVERY_REQUEST_BLUETOOTH);
        @Override
        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                if (requestCode == DISCOVERY_REQUEST_BLUETOOTH) {
                        boolean isDiscoverable = resultCode > 0;
                        if (isDiscoverable) {
                                UUID uuid = UUID.fromString("a60f35f0-b93a-11de-8a39-08002009c666");
                                String serverName = "BTserver";
                                final BluetoothServerSocket bluetoothServer = bluetoothAdapter.listenUsingRfcommWithServiceRecord(serverName, uuid);
                                
                                Thread listenThread = new Thread(new Runnable() {
                                
                                        public void run() {
                                                try {
                                                        
                                                        BluetoothSocket serverSocket = bluetoothServer.accept();

                                                } catch (IOException e) {
                                                
                                                        Log.d("BLUETOOTH", e.getMessage());
                                                }
                                        }
                                });
                                listenThread.start();
                        }
                }
        }


/******************************************************************************/
Android Bluetooth       from: http://kidheart-android.blogspot.tw/search/label/Bluetooth
/******************************************************************************/
Android平台支援藍芽網路，它允許與其他藍芽裝置連結無線交換數據，應用程式架構通過Android bluetooth APIs提供藍芽存取功能，APIs讓應用程式無線地與其他藍芽裝置
連結，可以點對點與多點無線屬性。
有Bluetooth APIs，應用程式可以執行以下功能:
掃瞄其他藍芽裝置。
查詢本地藍芽適配器去配對藍芽裝置。
建立RFCOMM頻道。
透過裝置探詢與其它裝置連結。
與其他裝置傳輸數據。
管理多個連結。

1. The basics
此部分要學習如何使用Android bluetooth APIs建立四個主要運用藍芽功能所需的任務:
設置藍芽、搜尋本地的配對或是可用的藍芽裝置、連結裝置、傳輸資料。

所有的android藍芽APIs都裝在android.bluetooth包中，這裡總結建立藍芽連線需要的類別與介面:
BluetoothAdapter-表示本地的藍芽適配器(藍芽電台，bluetooth radio)。
    BlueAdpater是所有藍芽的進入點，使用它，你可以發現其他藍芽裝置，查詢一系列配對裝置，實體化BluetoothDevice得知MAC位址，然後建立BluetoothServerSocket接
    聽其他裝置的訊息。
BluetoothDevice-表示一個遠端藍芽裝置。
    使用它能通過BluetoothSocket請求與其它裝置連結或是查詢裝置的資訊，名稱、位址、狀態。
BluetoothSocket-表示藍芽socket的介面。
    它是連結點，允許應用程式與其他藍芽裝置交換數據，通過InputStream及OutputStream。
BluetoothServerSocket-表示一個開放server socket，接聽傳入的請求。
    為了連結兩個Android裝置，一個裝置必須開放server socket，當遠端的裝置請求連結此裝置，BluetoothServerSocket回傳BluetoothSocket接受連結的請求。
BluetoothClass-描述連芽裝置的一般特性與能力。
    這是一個唯讀的屬性，它定義了裝置的主要與次要的裝置類別及它的服務。然而，描述所有藍芽屬性及支援的服務是不可靠的，但是它作為裝置型態的提示是有用的。
BluetoothProfile-顯示藍芽資料的介面。
    藍芽資料是無線藍芽通訊介面的規範。例如，免提規範。
BluetoothHeadset-提供行動手機支援藍芽耳機。
    包括藍芽耳機和免提規範。
BluetoothA2dp-A2Dp代表了高級音頻傳輸規範
    定義如何使高品質音頻流通過藍芽連結從一個裝置流到另一個裝置。
BluetoothProfile.ServiceListener-告知BluetoothProfile IPC用戶端的介面。
    當它們已經與其他裝置連結或斷線時。

2. Bluetooth Permissions
為了在應用程式中使用藍芽，你至少有宣告兩個藍芽權限的其中一個:BLUETOOTH及BLUETOOTH_ADMIN。
執行藍芽通訊必須請求BLUETOOTH權限，比如，請求連線、接收連線、傳輸數據。
啟動裝置探索或操作藍芽設定必須請求BLUETOOTH_ADMIN權限，大部分應用程式需要此權限僅是用來探詢本地藍芽裝置。
此權限授予的其他功能應該是用不上，除非應用程式是"power manager"，用到修改藍芽設定的請求。注意:如果有BLUETOOTH_ADMIN權限，大部分也有BLUETOOTH權限。
在應用程式的manifest檔案宣告藍芽權限:
<manifest ... >
  <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
  <uses-permission android:name="android.permission.BLUETOOTH" />
  ...</manifest>

3. Setting Up Bluetooth
在你的應用程式用藍芽通訊之前，你需要驗證裝置支援藍芽，然後確認它是否可用。
如果沒支援藍芽，你應該優雅地停止任何藍芽屬性。如果支援藍芽，但停用的，你可以不用離開應用程式的情況下，請求用戶啟用藍芽裝置。
啟用的過程由兩個步驟建立，使用BluetoothAdapter。
a. 取得BluetoothAdapter
BluetoothAdapter是任何及所有藍芽Activity需要的，呼叫靜態的getDefaultAdapter()方法取得BluetoothAdapter，此方法回傳的BluetoothAdapter表示裝置本身自己的藍芽
適配器(藍芽電台)，還有一個負責整個系統的藍芽適配器，你的應用程式可以使用回傳的適配器與負責整個系統的適配器互動。
如果getDefaultAdapter()回傳直視null，表示裝置不支援藍芽。
BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
if (mBluetoothAdapter == null) {
    // Device does not support Bluetooth
}

b. 啟用藍芽
接下來就需要確認藍芽適可用的，呼叫isEnable()方法檢驗目前是否有可用的藍芽，如果回傳值為false，藍芽是未啟用的，呼叫startActivityForResult()方法並傳入參數動
作值ACTION_REQUEST_ENABLE的意圖物件，請求藍芽功能啟用，這將發出一個請求，通過系統設定啟用藍芽功能。
if (!mBluetoothAdapter.isEnabled()) {
    Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
}
對話方塊顯示請求用戶權限來啟用藍芽功能，如果用戶回應"Yes"，系統將開始啟用藍芽功能，程式完成後(或是失敗)焦點會再回到應用程式。
若不想要顯示請求用戶權限來啟用藍芽功能，則用
myBTadapter.enable();.enable();
如果啟用藍芽功能成功，你的Activity就在onActivityResult()回呼方法中接收到RESULT_OK，如果藍芽功能啟用失敗(或是用戶回應"No")，接收到RESULT_CANCELED。
另外可選，你的應用程式也可以監聽ACTION_STATE_CHANGED廣播意圖，藍芽狀態改變時系統將會廣播出去，廣播包括EXTRA_STATE、EXTRA_PREVIOUS_STATE，分別為新的和舊的
藍芽狀態，其他可能值有STATE_TURNING_ON、STATE_ON、STATE_TURNING_OFF、STATE_OFF，監聽廣播幫助你的應用程式在運行時偵測藍芽的狀態。

4. Finding Devices
使用BluetoothAdapter，你可以找到遠端的藍芽裝置，不管是通過裝置探詢或是查詢配對裝置。
裝置探詢(device discovery)是掃瞄程式，搜尋本地可用的藍芽裝置，然後，一一要求一些資訊。當在本地區的藍芽裝置目前能夠是被發現的，它才會回應探詢的請求。
如果裝置是可發現的，它將分享一些資訊回應探尋的請求，比如名稱、類別、位址。使用這些資訊，執行探詢的裝置可以選擇初始化連線的裝置。
一旦與遠端裝置第一次連線，配對要求自動顯示給用戶，當配對成功，裝置的基本資料就會被儲存並且可經由Bluetooth APIs讀取。
使用已知的遠端裝置的MAC位址，就能在任何時間執行連線無需在經過探詢。
記住能被配對(paired)與能被連線(connected)是不相同的，能被配對是指兩個裝置知道彼此是存在的，彼此已經分享了link-key用來認證，且彼此之間是有能力建立加密連線。
能被連線是指裝置目前分享RFCOMM頻道且可以彼此傳遞數據。目前Android Bluetooth APIs的要求裝置配對之前必須先建立RFCOMM連線。
以下我們就來學習如何找到裝置進行配對或是使用裝置探詢找到新裝置。
a. Querying paired devices
在執行裝置探詢之前，查詢已配對裝置瞭解想連線的裝置是否已是我們已配對裝置是值得的，呼叫getBondedDevice()方法，此方法回傳一系列BluetoothDevices顯示配對裝置。
例如，你可以查詢所有的已配對裝置，然後顯示出它們的名稱給用戶，使用ArrayAdapter:
Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
// If there are paired devices
if (pairedDevices.size() > 0) {
    // Loop through paired devices
    for (BluetoothDevice device : pairedDevices) {
        // Add the name and address to an array adapter to show in a ListView
        mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
    }
}
所有來自BluetoothDevice物件以啟動連線的訊息就是MAC位址。在此例中，我們將資訊存在ArrayAdapter中顯示給用戶。
MAC位址會在之後要連線時取出(see in Connecting Device)。

b. Discovering devices
啟動裝置探詢，呼叫startDiscovery()，該程式是異步並且會立刻回傳一個布林值表示探詢工作是否已經成功開始。
探詢程式通常涉及調查掃瞄大約12秒鐘，通過已找到的裝置的每頁掃瞄取得藍芽名稱。
你的應用程式必須註冊廣播接收器接收ACTION_DOUND意圖，為了接收每個被探詢的裝置資訊。
對每個裝置，系統會廣播ACTION_FOUND意圖，意圖夾帶EXTRA_DEVICE和EXTRA_CLASS額外檔案，分別包括一個BluetoothDevice和一個BluetoothClass。
舉例，當裝置被探詢時，你可以如何註冊處理廣播。
// Create a BroadcastReceiver for ACTION_FOUND
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // Get the BluetoothDevice object from the Intent
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            // Add the name and address to an array adapter to show in a ListView
            mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
        }
    }
};
// Register the BroadcastReceiver
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy

c. Enabling discoverablilty
如果你想要使本地裝置能被其他裝置找到，呼叫startActivityForResult(intent , int)方法，ACTION_REQUEST_DISCOVERABLE動作意圖，這將發出一個請求，以便通過系統設
定啟用可發現模式，預設情況下，裝置變成可發現的長達120秒，你可以藉著EXTRA_DISCOVERABLE_DURATION意圖定義不同的持續時間，最大可以設定為3600秒，數值0表示裝置
永遠是可發現的，任何低於0及高於3600的值都會被設成120秒。以下舉例設定為300秒。
Intent discoverableIntent = new
Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
startActivity(discoverableIntent);
對話方塊會顯示，請求用戶權限使裝置為可發現的，如下圖，如果用戶回應"Yes"，裝置將變成可發現的時間長達指定的時間，你的Activity接著呼叫onActivityResult()回調
方法，如果用戶回應"No"或發生錯誤，結果代碼將是Activity.RESULT_CANCELED。
裝置在配發的時間內靜靜地保持可發現的模式，如果你想要當可發現模式改變時的告知，你可以為ACTION_SCAN_MODE_CHANGE意圖註冊廣播接收器，意圖會包括兩個額外的字段
，EXTRA_SCAN_MODE和EXTRA_PREVIOUS_SCAN_MODE，它們分別為新的和舊的掃瞄模式，每個字段的值有可能為SCAN_MODE_CONNECTABLE_DISCOVERABLE、SCAN_MODE_CONNECTABLE
、SCAN_MODE_NONE，它們分別表示裝置在可發現的模式，不在可發現模式但是可以接受連線，或是不在可發現模式且無法接受連線。
如果你將啟動與遠端裝置的連線，你無需啟用裝置為可發現。啟用可發現模式只在當你想要你的應用程式是主機伺服器接收傳入的連線才需要，因為遠端裝置必須在連線之前
能夠發現裝置。

5. Connecting Devices
為了建立兩個裝置上的應用程式之間的連線，你必須執行伺服器端與用戶端的機制，因為一個裝置必須開啟伺服器插口，另一個必須啟動連線(使用伺服器端的MAC位址建立連
線)，當它們彼此有已連線的BluetoothSocket在相同的RFCOMM頻道上時，表示伺服器端與用戶端彼此已建立連線，在此點，彼此都獲得輸出與輸入的資訊流然後數據傳輸就可
以開始了。此部分會在Managing a Connection中學習到。
伺服器端裝置與用戶端裝置都以不同方式獲得所需的BluetoothSocket，伺服器端會在接受連入的時候獲得，用戶端會在開啟通往伺服器端的RFCOMM頻道時獲得。
有一個技術是自動將每個裝置視為伺服器端，因此每個裝置都有一個開啟的伺服器插口並監聽連線，且裝置可以啟動與其他裝置的連線，成為用戶端，另外，一台裝置可以明
確地為"主機"連線，並開放伺服器插口點播，其他裝置可以輕易地實現連線。

a. Connecting as a server
如果你想要連接兩個裝置，一個裝置必須作為伺服器，持有一個開放的BluetoothServerSocket，伺服器插口的目的是監聽連入的請求，並且當它接受後，提供一個已連線的
BluetoothSocket。當BluetoothSocket已經從BluetoothServerSocket收購，BluetoothServerSocket應該被丟棄，除非你想接受更多連線。
以下是設置伺服器插口語接受連線的基本程式:
呼叫]listenUsingRfcommWithServiceRecord(String , UUID)取得BluetoothServerSocket。
傳入的字串參數是你的服務的可辨識名稱，系統自動地將字串寫入新的Service Dicovery Protocol(SDP)在裝置的資料庫中。
參數UUID也是包括在SDP中並且將是用戶端連線許可的基礎，當用戶端視著與此裝置連線，用戶端會帶著唯一辨識想連線伺服器的UUID，這些UUID必須相匹配，連線才會被接受。
呼叫accept()方法監聽連線的請求。
這是阻絕式呼叫，當連線已經被接受時或是異常發生時它回傳。連線被接受只在遠端裝置已發送UUID的連線請求，且UUID與已註冊正在監聽的伺服器插口的UUID相匹配時。
當連線成功，accept()方法回傳已連線BluetoothSocket。
呼叫close()方法，除非你想接受更多連線。
釋放伺服器插口及所有資源，但不會關閉用accept()方法請求來的已連線的BluetoothSocket。不像TCP/IP、RFCOMM一個頻道同時只允許一個用戶端連線，所以在大部分的案例
中，在接受一個已連線的插口後，很直覺的立即呼叫BluetoothServerSocket的close()方法。
呼叫accept()方法不應該在主Activity的UI執行續中執行，因為它是一個阻絕式呼叫且將阻止與應用程式的任何互動，由其他新的執行續完成BluetoothServerSocket或是
BluetoothSocket的所有工作是比較合理的，退出阻絕式呼叫，比如accept()方法，從其他執行續呼叫在BluetoothServerSocket的close()方法。
舉例:
以下為伺服器元件及接受連線的執行續:
private class AcceptThread extends Thread {
    private final BluetoothServerSocket mmServerSocket;
 
    public AcceptThread() {
        // Use a temporary object that is later assigned to mmServerSocket,
        // because mmServerSocket is final
        BluetoothServerSocket tmp = null;
        try {
            // MY_UUID is the app's UUID string, also used by the client code
            tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID);
        } catch (IOException e) { }
        mmServerSocket = tmp;
    }
 
    public void run() {
        BluetoothSocket socket = null;
        // Keep listening until exception occurs or a socket is returned
        while (true) {
            try {
                socket = mmServerSocket.accept();
            } catch (IOException e) {
                break;
            }
            // If a connection was accepted
            if (socket != null) {
                // Do work to manage the connection (in a separate thread)
                manageConnectedSocket(socket);
                mmServerSocket.close();
                break;
            }
        }
    }
 
    /** Will cancel the listening socket, and cause the thread to finish */
    public void cancel() {
        try {
            mmServerSocket.close();
        } catch (IOException e) { }
    }
}
此例中，只需一個連入連線，所以只要連線被接受且BluetoothSocket被收購，應用程式就會寄送BluetoothSocket到另一個執行續，關閉BluetoothServerSocket，結束迴圈。
注意當accept()回傳BluetoothSocket，插口已準備好連線，所以無需呼叫connect()方法。
在應用程式中manageConnectedSocket()是一個虛構的方法，啟動執行續來傳輸資料。
通常應該在完成連入的連線工作後關閉BluetoothServerSocket，在此例中，BluetoothSocket被收購，同時close()方法被呼叫，你也許想在你的執行續提供公開方法關閉私有
的BluetoothSocket，在你需要關閉監聽伺服器插口事件上。

b. Connecting as a client
為了與遠端裝置啟動連線(擁有伺服器插口的裝置)，你首先必須獲得代表遠端裝置的BluetoothDevice物件，接著你必須用BluetoothDevice物件收購一個BluetoothSocket，並啟動連線。
以下為基本程式:
利用BluetoothDevice呼叫createRfcommSocketToServerRecord(UUID)取得BluetoothSocket。
此步驟初始化與BluetoothDevice連線的BluetoothSocket，此處傳入的參數UUID必須與開啟BluetoothServerSocket的裝置的UUID相匹配。利用相同UUID是在應用程式的簡單UUID字串應編碼，並由伺服器端與用戶端所引用。
呼叫connect()方法啟動連線。
在呼叫此方法之上，系統執行SDP查找遠端裝置，為了配對UUID。如果查找成功，遠端裝置接受連線，遠端裝置利用連線分享RFCOMM頻道。此方法是阻絕式呼叫，如果任何原因連線失敗、或是connect()時間到了(超過12秒)，它就會丟出意外。
因為connect()是阻絕式呼叫，所以此連線應該在與主執行續分開的執行續執行。
舉例:
以下為一個簡單的例子執行一個新的執行續與啟動藍芽連線。
private class ConnectThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final BluetoothDevice mmDevice;
 
    public ConnectThread(BluetoothDevice device) {
        // Use a temporary object that is later assigned to mmSocket,
        // because mmSocket is final
        BluetoothSocket tmp = null;
        mmDevice = device;
 
        // Get a BluetoothSocket to connect with the given BluetoothDevice
        try {
            // MY_UUID is the app's UUID string, also used by the server code
            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) { }
        mmSocket = tmp;
    }
 
    public void run() {
        // Cancel discovery because it will slow down the connection
        mBluetoothAdapter.cancelDiscovery();
 
        try {
            // Connect the device through the socket. This will block
            // until it succeeds or throws an exception
            mmSocket.connect();
        } catch (IOException connectException) {
            // Unable to connect; close the socket and get out
            try {
                mmSocket.close();
            } catch (IOException closeException) { }
            return;
        }
 
        // Do work to manage the connection (in a separate thread)
        manageConnectedSocket(mmSocket);
    }
 
    /** Will cancel an in-progress connection, and close the socket */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
注意cancelDiscovery()方法呼叫在連線建立之前，你應該總是在連線之前這樣做，無須檢查它是否運行，呼叫它是安全的。
當你使用BluetoothSocket完後，總要呼叫close()方法清除，立即地關閉連接插口且清除所有資源。

6. Managing a Connection
當你已經成功連線兩個或更多裝置，每個裝置都有一個BluetoothSocket。利用BluetoothSocket，輕鬆地通過一般程式傳輸任意數據:
取得InputStream和OutputStream處理通過Socket的傳輸，分別是getInputStream()和getOutputStream()。
read(byte[])和write(byte[])方法讀或寫數據到資訊流中。
首先，你應該使用專用的執行續處理讀與寫的資訊流。這是非常重要的，因為read(byte[])和write(byte[])是阻絕式呼叫，read(byte[])將會組塞直到有東西從資訊流讀取出，write(byte[])不常阻塞，但是如果遠端裝置不快速呼叫read(byte[])方法及中間的緩衝區滿了就會阻塞，所以在執行續中的主迴圈專用來讀取InputStream，執行續中分開的公開方法可以利用來啟動寫入到OutputStream。
舉例
private class ConnectedThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final InputStream mmInStream;
    private final OutputStream mmOutStream;
 
    public ConnectedThread(BluetoothSocket socket) {
        mmSocket = socket;
        InputStream tmpIn = null;
        OutputStream tmpOut = null;
 
        // Get the input and output streams, using temp objects because
        // member streams are final
        try {
            tmpIn = socket.getInputStream();
            tmpOut = socket.getOutputStream();
        } catch (IOException e) { }
 
        mmInStream = tmpIn;
        mmOutStream = tmpOut;
    }
 
    public void run() {
        byte[] buffer = new byte[1024];  // buffer store for the stream
        int bytes; // bytes returned from read()
 
        // Keep listening to the InputStream until an exception occurs
        while (true) {
            try {
                // Read from the InputStream
                bytes = mmInStream.read(buffer);
                // Send the obtained bytes to the UI Activity
                mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                break;
            }
        }
    }
 
    /* Call this from the main Activity to send data to the remote device */
    public void write(byte[] bytes) {
        try {
            mmOutStream.write(bytes);
        } catch (IOException e) { }
    }
 
    /* Call this from the main Activity to shutdown the connection */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
建構式取得必須的資訊流，一旦執行，執行續等待數據通過InputStream到來，當read(byte[])回傳來自資訊流的byte數據，利用父類別的Handler將數據寄送到主Activity，然後回到執行續中繼續等待更多數據從資訊流送來。
傳送出數據從主Activity呼叫執行續的write()方法，傳入byte數據到方法中，此方法在呼叫write(byte[])將數據傳送到遠端裝置。
執行續的cancel()是重要的，以便通過BluetoothSocket，在任何時間關閉連線，此方法應該在使用完藍芽連線後呼叫。


/******************************************************************************/
[Android] bluetooth headset connect sequence
/******************************************************************************/
1. AndroidManifest.xml permission
<user-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<user-permission android:name="android.permission.BLUETOOTH />

2. Get BlueToothAdapter
mBtAdapter = BluetoothAdapter.getDeafultAdapter();

3. Discovery
mBtAdapter.startDiscovery();

4. Device Broadcast
public void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstranceState);

    intentFilter filter = new intentFilter(BluetoothDevice.ACTION_FOUND);
    this.registerReceiver(mReceiver, filter);
    filter = new intentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINSIHSED);
    this.registerReciver(mReceiver, filter);
}

private final BroadcastRecevier mReceiver = new BroadcastReceiver(){
    public void onReceiver(Context context, Intent intent){
        String action = intent.getAction();
        if(BluetoothDevice.ACTION_FOUND.equals(action)) {
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

            if(device.getBondState() != BluetoothDevice.BOND_BONDED){
                mNewDevicesArrayAdater.add(device.getName() + "\n" + device.getAddress());
            }
        }else if(BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)){
            setProgressBarIndeterminateVisibility(false);
            setTitle(R.string.select_device);
            if(mNewDevicesArrayAdapter.getCount() == 0){
                String noDevices = getText(R.string.non_found).toString();
                mNewDevicesArrayAdapter.add(noDevices);
            }
        }
};

5.mAdapter.cacnelDiscovery();
BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
private static final UUID MY_UUID = UUID.fromString("00001108-0000-1000-8000-00805F9B34FB");
mmSocket = device.createRfcommSocketToServiceRecord(MY_UUID);
mmSocket.connect();


/******************************************************************************/
Android 藍牙( Bluetooth)耳機連接分析及實現     ref: http://fecbob.pixnet.net/blog/post/36191385-android-%E8%97%8D%E7%89%99(-bluetooth)%E8%80%B3%E6%A9%9F%E9%80%A3%E6%8E%A5%E5%88%86%E6%9E%90%E5%8F%8A%E5%AF%A6%E7%8F%BE
/******************************************************************************/
分享:       
Android 實現了對Headset 和Handsfree 兩種profile 的支援。其實現核心是BluetoothHeadsetService，在PhoneApp 創建的時候會啟動它。

if (getSystemService(Context.BLUETOOTH_SERVICE) != null) {
    mBtHandsfree = new BluetoothHandsfree(this, phone);
    startService(new Intent(this, BluetoothHeadsetService.class));
} else {
    // Device is not bluetooth capable
    mBtHandsfree = null;
}
BluetoothHeadsetService 通過接收ENABLED_ACTION、BONDING_CREATED_ACTION 、DISABLED_ACTION 和REMOTE_DEVICE_DISCONNECT_REQUESTEDACTION 來改變狀態，它也會監
聽Phone 的狀態變化。
IntentFilter filter = new IntentFilter(BluetoothIntent.BONDING_CREATED_ACTION);
filter.addAction(BluetoothIntent.REMOTE_DEVICE_DISCONNECT_REQUESTED_ACTION);
filter.addAction(BluetoothIntent.ENABLED_ACTION);
filter.addAction(BluetoothIntent.DISABLED_ACTION);
registerReceiver(mBluetoothIntentReceiver, filter);
mPhone.registerForPhoneStateChanged(mStateChangeHandler,PHONE_STATE_CHANGED, null);
BluetoothHeadsetService 收到ENABLED_ACTION時，會先向BlueZ註冊Headset 和Handsfree 兩種profile（通過執行sdptool 來實現的，均作為Audio Gateway），然後讓
BluetoothAudioGateway 接收RFCOMM 連接，讓BluetoothHandsfree 接收SCO連接（這些操作都是為了讓藍牙耳機能主動連上Android）。

if (action.equals(BluetoothIntent.ENABLED_ACTION)) {
    // SDP server may not be ready, so wait 3 seconds before
    // registering records.
    // TODO: Use a different mechanism to register SDP records,
    // that actually ACK』s on success, so that we can retry rather
    // than hardcoding a 3 second guess.
    mHandler.sendMessageDelayed(mHandler.obtainMessage(REGISTER_SDP_RECORDS),3000);
    mAg.start(mIncomingConnectionHandler);
    mBtHandsfree.onBluetoothEnabled();
}
BluetoothHeadsetService 收到DISABLED_ACTION 時，會停止BluetoothAudioGateway 和BluetoothHandsfree。

if (action.equals(BluetoothIntent.DISABLED_ACTION)) {
    mBtHandsfree.onBluetoothDisabled();
    mAg.stop();
}

Android 跟藍牙耳機建立連接有兩種方式。
1. Android 主動跟藍牙耳機連BluetoothSettings 中和藍牙耳機配對上之後， BluetoothHeadsetService 會收到BONDING_CREATED_ACTION，這個時候BluetoothHeadsetService 會主動去和藍牙耳機建立RFCOMM 連接。
if (action.equals(BluetoothIntent.BONDING_CREATED_ACTION)) {
    if (mState == BluetoothHeadset.STATE_DISCONNECTED) {
        // Lets try and initiate an RFCOMM connection
        try {
        mBinder.connectHeadset(address, null);
        } catch (RemoteException e) {}
    }
}
RFCOMM 連接的真正實現是在ConnectionThread 中，它分兩步，第一步先通過SDPClient 查詢藍牙設備時候支援Headset 和Handsfree profile。
// 1) SDP query
SDPClient client = SDPClient.getSDPClient(address);
if (DBG) log(」Connecting to SDP server (」 + address + 「)…」);
if (!client.connectSDPAsync()) {
    Log.e(TAG, 「Failed to start SDP connection to 」 + address);
    mConnectingStatusHandler.obtainMessage(SDP_ERROR).sendToTarget();
    client.disconnectSDP();
    return;
}
if (isInterrupted()) {
    client.disconnectSDP();
    return;
}

if (!client.waitForSDPAsyncConnect(20000)) { // 20 secs
    if (DBG) log(」Failed to make SDP connection to 」 + address);
    mConnectingStatusHandler.obtainMessage(SDP_ERROR).sendToTarget();
    client.disconnectSDP();
    return;
}

if (DBG) log("SDP server connected (" + address + ")");
int headsetChannel = client.isHeadset();
if (DBG) log("headset channel = " + headsetChannel);
int handsfreeChannel = client.isHandsfree();
if (DBG) log("handsfree channel = " + handsfreeChannel);
client.disconnectSDP();

第2步才是去真正建立RFCOMM 連接。
// 2) RFCOMM connect
mHeadset = new HeadsetBase(mBluetooth, address, channel);
if (isInterrupted()) {
    return;
}
int result = mHeadset.waitForAsyncConnect(20000, // 20 secs
mConnectedStatusHandler);
if (DBG) log("Headset RFCOMM connection attempt took" +(System.currentTimeMillis() – timestamp) + "ms");
if (isInterrupted()) {
    return;
}
if (result < 0) {
    Log.e(TAG, "mHeadset.waitForAsyncConnect() error: " + result);
    mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
    return;
} else if (result == 0) {
    Log.e(TAG, "mHeadset.waitForAsyncConnect() error: " + result + "(timeout)");
    mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
    return;
} else {
    if (DBG) log("mHeadset.waitForAsyncConnect() success");
    mConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED).sendToTarget();
}

當 RFCOMM連接成功建立後，BluetoothHeadsetDevice 會收到RFCOMM_CONNECTED消息，它會調用BluetoothHandsfree 來建立SCO 連接，廣播通知Headset狀態變化的
Intent（PhoneApp 和BluetoothSettings 會接收這個Intent）。
case RFCOMM_CONNECTED:
// success
if (DBG) log(」Rfcomm connected」);
if (mConnectThread != null) {
try {
    mConnectThread.join();
} catch (InterruptedException e) {
    Log.w(TAG, "Connect attempt cancelled, ignoring RFCOMM_CONNECTED", e);
    return;
}
    mConnectThread = null;
}
setState(BluetoothHeadset.STATE_CONNECTED,BluetoothHeadset.RESULT_SUCCESS);
mBtHandsfree.connectHeadset(mHeadset, mHeadsetType);
break;
BluetoothHandsfree 會先做一些初始化工作，比如根據是Headset 還是Handsfree 初始化不同的ATParser，並且啟動一個接收執行緒從已建立的RFCOMM上接收藍牙耳機過來的
控制命令（也就是AT 命令），接著判斷如果是在打電話過程中，才去建立SCO 連接來打通資料通道。


/******************************************************************************/
Android ProgressDialog的兩種用法
/******************************************************************************/
ProgressDialog，顧名思義，就是一個進度對話方塊，常用於顯示載入進度、下載進度等。合理使用ProgressDialog能增加用戶體驗，讓用戶知道現在程式所處的狀態。
下面是兩種用法，第一種適合複雜環境，可以自定義風格，添加按鈕等，而第二種只能簡單的顯示一個只有標題和資訊的ProgressDialog
package com.pocketdigi.ProgressDialog;
 
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
 
public class Main extends Activity {
        /** Called when the activity is first created. */
        ProgressDialog pd1, pd2;
        Button b1, b2;
 
        @Override
        public void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main);
                b1 = (Button) findViewById(R.id.b1);
                b2 = (Button) findViewById(R.id.b2);
                b1.setOnClickListener(showPd1);
                b2.setOnClickListener(showPd2);
        }
        OnClickListener showPd1 = new OnClickListener() {
 
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        pd1 = new ProgressDialog(Main.this);
                        pd1.setTitle("PD1標題");
                        pd1.setProgressStyle(ProgressDialog.STYLE_SPINNER);// 轉圈風格
                        // 進度條風格為ProgressDialog.STYLE_HORIZONTAL,使用setMax,setProgress,incrementProgressBy方法設置進度
                        pd1.setMessage("PD1資訊");
                        pd1.setButton("關閉", new DialogInterface.OnClickListener() {
 
                                @Override
                                public void onClick(DialogInterface dialog, int which) {
                                        // TODO Auto-generated method stub
                                        pd1.dismiss();
                                }
 
                        });
                        //可以使用setButton2,setButton3來添加更多按鈕
                        pd1.setCancelable(false);//不可被返回鍵取消對話方塊
                        pd1.show();
                }
 
        };
        OnClickListener showPd2 = new OnClickListener() {
 
                @Override
                public void onClick(View v) {
                        // TODO Auto-generated method stub
                        pd2=ProgressDialog.show(Main.this,"PD2標題","PD2資訊");
                        //使用該方法將不能再設置按鈕，適合顯示簡單的ProgressDialog
                }
 
        };
 
}


/******************************************************************************/
Android Bluetooth 藍牙最簡單的例子 比官方還Simple
/******************************************************************************/
伺服器端和用戶端工程中都必須有這兩個權限申請
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH" />
關於UUID。。。UUID用戶端和服務端一定要一致。UUID不能和其他的一樣。一定要自己去申請一個
請從http://www.uuidgenerator.com上獲取你自己的UUID
這行代碼之前一定要確保藍牙是打開狀態的打開藍牙的代碼（可以用BluetoothAdapter的方法enable()。關閉為disable()）或

        Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(enableIntent, REQUEST_ENABLE_BT);//會打開一個對話方塊詢問是否打開藍牙
     或startActivity(enableIntent)
可被搜索的代碼
            Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
            startActivity(discoverableIntent);
     或startActivityForResult(discoverableIntent)

1.伺服器端：
UUID uuid = uuid.fromString("27648B4D-D854-5674-FA60E4F535E44AF7");
BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
BluetoothServerSocket serverSocket = adapter.listenUsingRfcommWithServiceRecord("MyBluetoothApp", uuid);
BluetoothSocket socket = serverSocket.accept();

2.用戶端
UUID uuid = uuid.fromString("27648B4D-D854-5674-FA60E4F535E44AF7");
BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
BluetoothDevice device = adapter.getRemoteDevice("00:11:22:33:44:55");//伺服器的藍牙地址
BluetoothSocket socket = device.createRfcommSocketToServiceRecord(uuid);
adapter.connect();

3.雙方連接上後，就開始讀寫了
InputStream in = socket.getInputStream();
OutputStream out = socket.getOutputStream();

好了，這是最簡單的。然後再看官方例子就很簡單了。


/******************************************************************************/
Android開發_ListView之動態修改
/******************************************************************************/
關於ListView樣式及內容的動態修改，本文使用了重寫BaseAdapter。

MyAdapter 類：
package com.android.test;
import java.util.ArrayList;
import java.util.Map;
import android.graphics.Color;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;
public class MyAdapter extends BaseAdapter {
    private ListMain main;
    private ArrayList<Map<String, Object>> list;
    public MyAdapter(ListMain main, ArrayList<Map<String, Object>> list) {
        this.main = main;
        this.list = list;
    }
    @Override
    public int getCount() {
        return list.size();
    }
    @Override
    public Object getItem(int position) {
       return list.get(position);
    }
    @Override
    public long getItemId(int position) {
        return position;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        //如果未選擇或list列表為空時直接跳出，避免NullPointException
        if (position < 0 || list.size() <= 0) {
            return null;
        }
        //如果為空重新導入ListView的佈局文件，佈局文件自定義
        if (convertView == null) {
            convertView = LayoutInflater.from(main).inflate(R.layout.list1, null);
        }
        //實例化
        ImageView img = (ImageView)convertView.findViewById(R.id.list1_img_icon);
        TextView tv1 = (TextView)convertView.findViewById(R.id.list1_tv1);
        TextView tv2 = (TextView)convertView.findViewById(R.id.list1_tv2);
        //獲取參數
        Map<String, Object> map = list.get(position);
        tv1.setText((String)map.get("TITLE"));
        tv2.setText((String)map.get("CONTENT"));
        //修改樣式
        if (main.getStatus(position) == ListMain.LIST_SELECT) {
            convertView.setBackgroundColor(Color.parseColor("#003D79"));
            img.setBackgroundResource(R.drawable.ic_settings_personalize);
            tv1.setTextColor(Color.BLUE);
            tv1.setShadowLayer(1, 1, 0.75f, Color.WHITE);
        } else {
            convertView.setBackgroundColor(Color.BLACK);
            img.setBackgroundResource(Integer.valueOf(map.get("IMG").toString()));
            tv1.setTextColor(Color.WHITE);
            tv1.setShadowLayer(1, 1, 0.75f, Color.CYAN);
        }
    return convertView;
    }
}
 

在ListMain中，插入一個ArrayList>
ArrayList<Map<String, Object>> list;
list = new ArrayList<Map<String,Object>>();
for (int i = 0; i < TITLE.length; i++) {
    Map<String, Object> map = new HashMap<String, Object>();
    map.put("TITLE", TITLE[i]);
    map.put("CONTENT", CONTENT[i]);
    map.put("IMG", IMG[i]);
    map.put("STATUS", LIST_NOT);
    list.add(map);}
 
將ListView與Adapter綁定：
adapter = new MyAdapter(this, list);
lv.setAdapter(adapter);

在onItemClick中處理選中事件:
for (int i = 0; i < TITLE.length; i++) {
    list.get(i).put("STATUS", LIST_NOT);
}
list.get(arg2).put("STATUS", LIST_SELECT);
  
adapter.getView(arg2, null, lv);
adapter.notifyDataSetChanged();
 

/******************************************************************************/
Android開發_獲取SD卡和手機存儲空間      ref: http://simpleframework.net/bbs/6148/105609.html
/******************************************************************************/
import java.io.File;
import android.app.Activity;
import android.os.Bundle;
import android.os.Environment;
import android.os.StatFs;
import android.text.format.Formatter;
import android.util.Log;
  
public class Memory extends Activity {
  public static final String TAG = "Memory";
  
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    updateMemoryStatus();
  }
  
  private void updateMemoryStatus() {
    String status = Environment.getExternalStorageState();
    String readOnly = "";
    // 是否只讀
    if (status.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {
      status = Environment.MEDIA_MOUNTED;
      readOnly = getString(R.string.read_only);
    }
    if (status.equals(Environment.MEDIA_MOUNTED)) {
      try {
        File path = Environment.getExternalStorageDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long totalBlocks = stat.getBlockCount();
        long availableBlocks = stat.getAvailableBlocks();
        // SD卡總容量
        String sdSize = formatSize(totalBlocks * blockSize);
        Log.i(TAG, "SD卡總容量: " + sdSize);
        // SD卡剩餘容量
        String sdAvail = formatSize(availableBlocks * blockSize)
            + readOnly;
        Log.i(TAG, "SD卡剩餘容量: " + sdAvail);
      } catch (IllegalArgumentException e) {
        status = Environment.MEDIA_REMOVED;
      }
    }
    File path = Environment.getDataDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSize();
    long availableBlocks = stat.getAvailableBlocks();
    // 手機記憶體剩餘容量
    String memoryAvail = formatSize(availableBlocks * blockSize);
    Log.i(TAG, "手機記憶體剩餘容量: " + memoryAvail);
    long totalBlocks = stat.getBlockCount();
    // 手機記憶體總容量
    String memorySize = formatSize(totalBlocks * blockSize);
    Log.i(TAG, "手機記憶體總容量: " + memorySize);
  }
  
  // 格式化 轉化為.MB格式
  private String formatSize(long size) {
    return Formatter.formatFileSize(this, size);
  }
}


/******************************************************************************/
如何掌握 Thread         from: http://jacky-google-android.blogspot.tw/2010/07/thread.html
/******************************************************************************/
在理想狀況下，程式設計師都希望自己寫出來的程式在執行時，都是反應迅速(小於200ms)。
當然這是理想目標，至少…不要超過 Android 系統所預設的 5 秒，以免產生 ANR 然後被 ActivityManager 殺掉程式。
當然，除了背景的工作外，也不能忽略前景有著更大的事情正在處理。
所以有兩種解決方法：
1. 將較花費時間的運算丟給 Service 去做，等到做完運算後再透過訊息( Notification )提示使用者去處理。
2. 將較花費時間的運算交給 Thread 做運算。
Android 提供功能豐富的背景 Thread，讓設計師能夠安全地與使用者互動。包括 Handler、Runnable 物件及使用 UIThreadUtilities。

徹底瞭解 Handler
要將 Android Thread 做最靈活的應用就是建立一個 Handler 子類別。每個 Activity 只需要一個 Handler 物件，而且不需要額外做任何的註冊方法。
在一個 Activity 中做任何關於 Thread 的工作都交給 Handler 掌控。這點非常重要，因為介面有任何的變動，應該都發生於 Thread。

使用 Handler 溝通或處理方法有兩種選擇：Messages 及 Runnable 物件。
Messages:
若要將 Message 物件傳遞給 Handler，必須呼叫 obtainMessage() 以獲得 Message 物件。
若要發送訊息給 Handler，分為底下幾種方式：
sendMessage()
立即將訊息發送出去
sendMessageAtFrontOfQueue()
將訊息插入佇列的最前端
sendMessageAtTime()
於設定的時間發送訊息，其中的時間為毫秒(千分之一秒)
sendMessageDelayed()
於設定的秒數後發送訊息，其中的時間為毫秒(千分之一秒)
為了要能夠處理訊息，宣告 Handler 時記得實作 handleMessage() 這個方法，如下：
Handler handler=new Handler() {
    @Override
    public void handleMessage(Message msg) {
        bar.incrementProgressBy(5);
    }
};
上面這個範例是每次增加 ProgressBar 的值(5)。
那來動作寫一個程式吧！就寫一個每秒增加 progressBar 的值，讓它衝到100%
Layout 的部份( main.xml )
<!--?xml version="1.0" encoding="utf-8"?--/>
<linearlayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
>
    <progressbar android:id="@+id/progress"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content" />
</linearlayout>

宣告 LinearLayout 中只有一個 ProgressBar 的元件，因為這只是一個簡單的範例，就不複雜化了
主程式的部份( HandlerDemo.java )
package tw.ds0218.handlerdemo;
import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.widget.ProgressBar;
import java.util.concurrent.atomic.AtomicBoolean;

public class HandlerDemo extends Activity {
    ProgressBar bar;

    Handler handler=new Handler() {
        @Override
        public void handleMessage(Message msg) {
            bar.incrementProgressBy(5);
        }
    };

    AtomicBoolean isRunning=new AtomicBoolean(false);

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        setContentView(R.layout.main);
        bar = (ProgressBar)findViewById(R.id.progress);
    }

    public void onStart() {
        super.onStart();
        bar.setProgress(0);
        Thread background=new Thread(new Runnable() {
            public void run() {
                try {
                    for (int i=0;i<20 && isRunning.get();i++) {
                        Thread.sleep(1000);
                        handler.sendMessage(handler.obtainMessage());
                    }
                }
                catch (Throwable t) {
                    // just end the background thread
                }
            }
        });
        isRunning.set(true);
        background.start();
    }

    public void onStop() {
        super.onStop();
        isRunning.set(false);
    }
}
上面的範例，我們實作一個 Activtiy 的類別，然後宣告了 Handler 物件及實作 handleMessage() 的方法，每次增一定的值。
在 onStart()，我們設定一個 Thread，然後設定執行20次，每次睡1秒鐘再執行。然後此時就離開 onStart() 了，這是非常重要的，代表 Thread 成功在背景執行了，然後畫
面中的 ProgressBar 就會每秒更新了。如下圖

Runnables
假如覺得 Message 物件非常的複雜不好用，當然還有 Runnable 這個選擇。只需要透過 post...()的方法即可使用相同的方式運行。網路上範例不少，在此就不多說了。
值得思考一件事。 Handler 支援 post() 及 postDelayed() 增加到佇列來運行 Runnable 物件，對於 View 來說是相同的方法。
也可以跳過 Handler 來簡化程式碼，但相對的，也失去了靈活性和需要繞更遠的路來實現 Android 程式碼，反而增加更多的未知數。
Utilities
然後，還有另一個方法，就是使用 UIThreadUtilities helper 類別，它提供了一組靜態方法協助 UI Thread 的運行。
它也提供了 isUIThread() 做為判斷 Thread 是否正在運行，但看來是有點多餘，因為自己寫的程式一定瞭解頭尾。
但是，如果程式碼中引了某個 Jar 封裝檔，就無法從程式碼中辨別出來，此時 isUIThread() 還是滿好用的。
如果想要比較適當時機才執行，就需要使用 runOnUIThread()。它有點類似使用在 Handler 上的 post()，因為它必須先排在佇列中，再一一執行。
又或者想要確保 Thread 可以立即執行，那就只能處於 Activity、Dialog、View 這三個類別中運行。

注意事項
背景執行的 Thread 固然很好用，也能順利執行在 Android Handler 系統上。但它同時也增加了複雜性，因為連帶影響了記憶體、CPU、電池的效能。
這個重要事項，在許多公開的演講場合中，也常常被提及，底下整理出幾個重點：
1. 背景執行的 Thread 也可能影響到使用者正在操作的界面，所以必須小心使用。並且也可以使用 Android 內建的 java.util.concurrent 封包類別安全傳遞訊息通知 Thread
2. 也可能出現 Activity 被系統關閉，然後背景 Thread 還在執行。像是操作到一半，電話進來，Activity 被強制移到後端，但系統此時資源不足，強行將此 Activity 移
   除了。要小心這類的情況，並通知背景 Thread 適當儲存資料或者中斷執行. 
3. 某一行為強佔使用者的畫面時間，但又遲遲沒有給於任何反應。此時最好的技巧，就是使用 ProgressBar 的旋轉畫面讓使用者瞭解目前處於"等待"中。其實最好的方式，
   還是將效能提升到最高，盡量避免長時間等待的狀況發生
4. 又或者是背景執行的 Thread 發生錯誤。像是利用背景 Thread 去拿取伺服器上的資料，但伺服器當機或無回應，此時應該利用 Notification 來通知使用者發生中斷事件
   ，並中斷背景 Thread 的運行才是正確


/******************************************************************************/
Android程式設計 (十五) 使用SharedPreferences    from: http://nkeegamedev.blogspot.tw/2010/08/android-sharedpreference.html
/******************************************************************************/
偏好設定(SharedPreferences)提供一個簡易的方式來儲存應用程式的設定值，方便下次應用程式被啟動時，載入偏好設定，讓應用程式自動回復到前一次設定值。
此外，也可與同一套件之應用程式共享。
要使用SharedPreferences功能，應用程式需要匯入以下類別。
import android.content.SharedPreferences;

儲存偏好設定
Preference是以name-value pair方式儲存應用程式狀態，通常我們會在應用程式的onPause()方法中進行偏好設定儲存作業。
首先透過getSharedPreferences()方法取得指定偏好設定檔：
public SharedPreferences getSharedPreferences (String name, int mode)
其中name為偏好設定檔名稱；mode則是偏好設定檔作業模式，MODE_PRIVATE (0)表示應用程式專用；MODE_WORLD_WRITEABLE (1)表示可與套件之其它應用程式共用。
接下來就可透過SharedPreferences.Editor編輯介面來更新偏好設定內容。這項作業必須先使用edit()方法取得SharedPreferences.Editor編輯介面，再使用putBoolean()、
putFloat()、putInt()、putLong()及putString()方法來分別寫入布林資料、浮點數資料、整數資料、長整數資料及字串資料到偏好設定檔中。
    public abstract SharedPreferences.Editor putBoolean (String key, boolean value)
    public abstract SharedPreferences.Editor putFloat (String key, float value)
    public abstract SharedPreferences.Editor putInt (String key, int value)
    public abstract SharedPreferences.Editor putLong (String key, long value)
    public abstract SharedPreferences.Editor putString (String key, String value)

在此key表示偏好設定檔中的資料名稱，value則是資料值。有一點要注意，這些偏好設定值並不會立即更新，而是等到執行commit()方法後才會寫回偏好設定檔。
Date date = new Date (System.currentTimeMillis());
protected void onPause() {
    // TODO Auto-generated method stub
    super.onPause();
    SharedPreferences settings = getSharedPreferences ("PREF_DEMO", 0);
    SharedPreferences.Editor PE = settings.edit();
    PE.putString("LAUNCH_DATE", date.toString());
    PE.putInt("LAUNCH_COUNT", count+1);
    PE.commit();
}

讀取偏好設定
要讀取偏好設定內容時，同樣先透過getSharedPreferences()方法取得指定偏好設定檔，之後再使用getBoolean()、getFloat()、getInt()、getLong()及getString()方法來
分別讀取偏好設定中的布林資料、浮點數資料、整數資料、長整數資料及字串資料。
    boolean getBoolean (String key, boolean defValue) 
    float getFloat (String key, float defValue)
    int getInt (String key, int defValue)
    long getLong (String key, long defValue)
    String getString (String key, String defValue)
在此key表示偏好設定檔中的資料名稱，defValue則是資料預設值。下面程式碼在應用程式一開始取回偏好設定值。
  int count=1;
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    SharedPreferences settings = getSharedPreferences("PREF_DEMO", 0);
    String LastDate = settings.getString("LAUNCH_DATE", "2010-01-01");
    count = settings.getInt("LAUNCH_COUNT", 1);
    view_date = (TextView) findViewById (R.id.txtDATE);
    view_count = (TextView) findViewById (R.id.txtCOUNT);
    view_date.setText ("Last launched: " + LastDate );
    view_count.setText ("Launched times: "+ count);
}
 

/******************************************************************************/
Activity 之間通信
/******************************************************************************/
使用 Intent 通信
在 Android 中，不同的 Activity 實例可能運行在一個進程中，也可能運行在不同的進程中。因此我們需要一種特別的機制幫助我們在 Activity 之間傳遞消息。
Android 中通過 Intent 對像來表示一條消息，一個 Intent 對像不僅包含有這個消息的目的地，還可以包含消息的內容，這好比一封 Email，其中不僅應該包含收件地址，還可以包含具體的內容。對於一個 Intent 對像，消息「目的地」是必須的，而內容則是可選項。
在上面的實例中通過 Activity. startActivity(intent)啟動另外一個 Activity 的時候，我們在 Intent 類的構造器中指定了「收件人地址」。
如果我們想要給「收件人」Activity 說點什麼的話，那麼可以通過下面這封「e-mail」來將我們消息傳遞出去：
 Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 創建一個帶「收件人地址」的 email   
 Bundle bundle =new Bundle();   // 創建 email 內容  
 bundle.putBoolean("boolean_key", true);        // 編寫內容  
 bundle.putString("string_key", "string_value");        
 intent.putExtra("key", bundle); // 封裝 email   
 startActivity(intent);// 啟動新的 Activity  
那麼「收件人」該如何收信呢？在 OtherActivity類的 onCreate()或者其它任何地方使用下面的代碼就可以打開這封「e-mail」閱讀其中的資訊：
 Intent intent =getIntent();// 收取 email   
 Bundle bundle =intent.getBundleExtra("key");// 打開 email   
 bundle.getBoolean("boolean_key");// 讀取內容  
 bundle.getString("string_key");  
上面我們通過 bundle對像來傳遞資訊，bundle維護了一個 HashMap<String, Object>對像，將我們的數據存貯在這個 HashMap 中來進行傳遞。
但是像上面這樣的代碼稍顯複雜，因為 Intent 內部為我們準備好了一個 bundle，所以我們也可以使用這種更為簡便的方法：
 Intent intent =new Intent(EX06.this,OtherActivity.class);   
 intent.putExtra("boolean_key", true);   
 intent.putExtra("string_key", "string_value");   
 startActivity(intent);  
接收：
 Intent intent=getIntent();   
 intent.getBooleanExtra("boolean_key",false);   
 intent.getStringExtra("string_key");  

使用 SharedPreferences
SharedPreferences 使用 xml 格式為 Android 應用提供一種永久的數據存貯方式。
對於一個 Android 應用，它存貯在文件系統的/data/ data/your_app_package_name/shared_prefs/目錄下，可以被處在同一個應用中的所有 Activity 訪問。
Android 提供了相關的 API 來處理這些數據而不需要程式員直接操作這些文件或者考慮數據同步問題。
// 寫入 SharedPreferences   
SharedPreferences preferences = getSharedPreferences("name", MODE_PRIVATE);   
Editor editor = preferences.edit();   
editor.putBoolean("boolean_key", true);   
editor.putString("string_key", "string_value");   
editor.commit();            
// 讀取 SharedPreferences   
SharedPreferences preferences = getSharedPreferences("name", MODE_PRIVATE);   
preferences.getBoolean("boolean_key", false);   
preferences.getString("string_key", "default_value");  

其它方式
Android 提供了包括 SharedPreferences 在內的很多種數據存貯方式，比如 SQLite，文件等，程式員可以通過這些 API 實現 Activity 之間的數據交換。
如果必要，我們還可以使用 IPC 方式。


/******************************************************************************/
一些關於 Activity 的技巧
/******************************************************************************/
鎖定 Activity 運行時的螢幕方向
Android 內置了方向感應器的支援。在 G1 中，Android 會根據 G1 所處的方向自動在豎屏和橫屏間切換。
但是有時我們的應用程式僅能在橫屏 / 豎屏時運行，比如某些遊戲，此時我們需要鎖定該 Activity 運行時的螢幕方向，
<activity >節點的android:screenOrientation屬性可以完成該項任務，示例代碼如下：
 <activity android:name=".EX01"  
           android:label="@string/app_name"   
           android:screenOrientation="portrait">// 豎屏 , 值為 landscape 時為橫屏 …………  
 </activity>  

全屏的 Activity
要使一個 Activity 全屏運行，可以在其 onCreate()方法中添加如下代碼實現：
 // 設置全屏模式  
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);   
 // 去除標題欄  
 requestWindowFeature(Window.FEATURE_NO_TITLE);  

在 Activity 的 Title 中加入進度條
為了更友好的用戶體驗，在處理一些需要花費較長時間的任務時可以使用一個進度條來提示用戶「不要著急，我們正在努力的完成你交給的任務」。如下圖：
在 Activity 的標題欄中顯示進度條不失為一個好辦法，下面是實現代碼：
 // 不明確進度條  
 requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);   
 setContentView(R.layout.main);   
 setProgressBarIndeterminateVisibility(true);    

 // 明確進度條  
 requestWindowFeature(Window.FEATURE_PROGRESS);   
 setContentView(R.layout.main);   
 setProgress(5000);  


/******************************************************************************/
Near Field Communications (NFC)
/******************************************************************************/
Android 2.3加入了NFC(近場通訊)的支援。官網developer.android.com的英文介紹如下：
Near Field Communications (NFC)
Android 2.3 includes an NFC stack and framework API that lets developers read NDEF tags that are discovered as a user touches an NFC-enabled device to tag elements embedded in stickers, smart posters, and even other devices.
The platform provides the underlying NFC services that work with the device hardware to discover tags when they come into range. On discovering a tag, the platform notifies applications by broadcasting an Intent, appending the tag's NDEF messages to the Intent as extras. Applications can create Intent filters to recognize and handle targeted tags and messages. For example, after receiving a tag by Intent, applications extract the NDEF messages, store them, alert the user, or handle them in other ways.
The NFC API is available in the android.nfc package. The key classes are:
NfcAdapter, which represents the NFC hardware on the device.
NdefMessage, which represents an NDEF data message, the standard format in which "records" carrying data are transmitted between devices and tags. 
   Applications can receive these messages from ACTION_TAG_DISCOVERED Intents.
NdefRecord, delivered in an NdefMessage, which describes the type of data being shared and carries the data itself.
NFC communication relies on wireless technology in the device hardware, so support for the platform's NFC features on specific devices is determined by 
their manufacturers. To determine the NFC support on the current device, applications can call isEnabled() to query the NfcAdapter. 
The NFC API is always present, however, regardless of underlying hardware support.
To use the NFC API, applications must request permission from the user by declaring <uses-permission android:name="android.permission.NFC"> in their 
manifest files.
Additionally, developers can request filtering on Android Market, such that their applications are not discoverable to users whose devices do not support 
NFC. To request filtering, add <uses-feature android:name="android.hardware.nfc" android:required="true"> to the application's manifest.

NFC的應用場景有很多，但Android 2.3目前API只提供了"電子標籤閱讀器"的功能。相信隨著Android的版本升級，後續會增加很多應用場景和 API。
功能是少一點，但從無到有的第一步總是不容易的。從架構上看，至少有以下幾部分的改動：
Android Framework層，為應用開發增加了相關API（即英文中的framework API）。
協定層，增加NFC的協定棧（即英文中的NFC Stack）。
硬體適配層，為硬體生產商提供適配介面，此層應該與NFC硬體的 Linux驅動通訊（實現方式待驗證）。
工作流程是當支援NFC功能的手機或其他電子終端（後面簡稱手機）在用戶開啟NFC功能的時候，如果手機內置的NFC掃瞄器（相當於類NfcAdapter的功能）掃瞄到電子標籤後，
就會向相關用戶程式發送ACTION_TAG_DISCOVERED的Intent，Itent的 extras架構中會包含NDEF（NFC Data Exchange Format）消息。如何處理此NDEF消息，就是用戶程式的事
情了。
NFC的API在android.nfc的包中提供，這個包主要提供三個大類，其中：NfcAdapter描述的就是手機中的NFC硬體，Android 2.3中可以暫時理解為電子標籤掃瞄器。電子標籤和
掃瞄器中的消息通過NdefMessage來表示，這個類很簡單，只是封裝了NdefRecord。每個NdefMessage中可以包含多個NdefRecord，通過類NdefMessage的方法getRecords()可以
查詢到消息的所有NdefRecord。NdefRecord才是資訊的真正載體，正確理解這個類是理解NFC技術的一個重點。
NFC的技術規範[url=link.php?url=http://www.nfc-forum.org%2Fspecs%2Fspec_list%2F]http://www.nfc-forum.org/specs/spec_list/[/url]是理解這個類不可或缺的資料。
應用程式的編程思路是：
1.通過android.nfc.NfcAdapter.getDefaultAdapter() 取得手機的objNfcAdapter
2.通過objNfcAdapter.isEnabled()查詢該手機是否支援NFC
3.如果手機支援NFC，就申請接收ACTION_TAG_DISCOVERED 的Intent
4.如果接收到ACTION_TAG_DISCOVERED，就提取NdefMessage，並在此基礎上進而提取 NdefRecord，整個是一個消息解析過程


/******************************************************************************/
【Android AppWidget開發流程】   from: http://www.cnblogs.com/jfttcjl/archive/2011/11/09/2242015.html
/******************************************************************************/
Android AppWidget開發不同於普通的android應用，因為AppWidget是運行在別的進程中的程式。其使用RemoteViews更新UI。
一旦系統發生變更，很容易引起AppWidget的更新。其支援的元件有限，事件類型也很少。所以一般用於更新週期較長，事件比較簡單的用於桌面顯示的元件。
其開發流暢相對來說還是比較簡單的。大致分為:
1:編寫佈局文件
2:編寫Provider配置文件和Manifest配置文件
3:編寫業務邏輯　　
對於第一步需要瞭解一下AppWidget支援的元件類型，對於桌面應用而言，其所支援的元件類型有限，原因是AppWIdget是現實在另外一個進程中的，其使用RemoteViews更新資
訊。而RemoteViews支援的佈局樣式和元件類型有以下幾種:
RrameLayout,LinearLayout,RelativeLayout
AnalogClock ,Button ,Chronometer ,ImageButton ,ImageView ,ProgressBar ,TextView
關於AppWidget的佈局以及在桌面上如何劃分給AppWIdget以佈局的可以參考網上的一些資料，這裡不再累贅。
按照我如下流程你就可以建立一個AppWidget
1：建立android項目，在res下建立一個xml文件夾，用於存放appWidget的provider配置文件。

2：在xml文件夾下新建widget_config.xml,更改其內容為:
1 <appwidget-provider
2 xmlns:android="http://schemas.android.com/apk/res/android"
3     android:minWidth="300dp"
4     android:minHeight="72dp"
5     android:updatePeriodMillis="0"
6     android:initialLayout="@layout/widget_ui"
7 >
8 </appwidget-provider>

3：在layout文件夾下建立一個佈局文件,正如上文提到的widget_ui.xml,更改其內容如下:
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent"
    android:orientation="vertical">
    <ProgressBar android:id="@+id/widget_ProgressBar"
        style="?android:attr/progressBarStyleHorizontal" android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

    <LinearLayout android:id="@+id/linearLayout1"
        android:layout_width="match_parent" android:layout_height="wrap_content">
        <Button android:id="@+id/widget_BT_Up" android:layout_width="wrap_content"
            android:layout_height="wrap_content" android:layout_weight="1"
            android:text="Value++"/>
        <Button android:id="@+id/widget_BT_Down" android:layout_width="wrap_content"
            android:layout_height="wrap_content" android:text="Value--"
            android:layout_weight="1"/>
    </LinearLayout>
</LinearLayout>

4：編寫Manifest文件，更改內容為:
 1 <?xml version="1.0" encoding="utf-8"?>
 2 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
 3     package="com.jftt.cjl.widget"
 4     android:versionCode="1"
 5     android:versionName="1.0">
 6 
 7     <uses-sdk android:minSdkVersion="10"/>
 8 
 9     <application
10 android:icon="@drawable/ic_launcher"
11         android:label="@string/app_name">
12         <!-- Dash Widget -->
13         <receiver android:name=".MyWidgetProvider" android:label="myWIdget"
14             android:icon="@drawable/ic_launcher">
15             <intent-filter>
16                 <action android:name="android.appwidget.action.APPWIDGET_UPDATE"/>
17                 <action android:name="zyf.test.widget.UP"/>
18                 <action android:name="zyf.test.widget.DOWN"/>
19             </intent-filter>
20             <meta-data android:name="android.appwidget.provider"
21                 android:resource="@xml/widget_config"/>
22         </receiver>
23     </application>
24 
25 </manifest>
到此為止，我們的配置文件告一段落，下面看看代碼吧：

5:新建一個java類 MyWidgetProvider 繼承自AppWidgetProvider
  1 package com.jftt.cjl.widget;
  2 
  3 import android.app.PendingIntent;
  4 import android.appwidget.AppWidgetManager;
  5 import android.appwidget.AppWidgetProvider;
  6 import android.content.ComponentName;
  7 import android.content.Context;
  8 import android.content.Intent;
  9 import android.media.AudioManager;
 10 import android.util.Log;
 11 import android.widget.RemoteViews;
 12 
 13 public class MyWidgetProvider extends AppWidgetProvider {
 14     public static int Tag;
 15     public int max;
 16     public int current;
 17 
 18     @Override
 19     public void onEnabled(Context context) {
 20         // TODO Auto-generated method stub
 21 
 22         super.onEnabled(context);
 23     }
 24 
 25     @Override
 26     public void onReceive(Context context, Intent intent) {
 27         // TODO Auto-generated method stub
 28         super.onReceive(context, intent);
 29 
 30         ComponentName thisWidget = new ComponentName(context,
 31                 MyWidgetProvider.class);
 32         RemoteViews views = new RemoteViews(context.getPackageName(),
 33                 R.layout.widget_ui);
 34         AppWidgetManager appmanager = AppWidgetManager.getInstance(context);
 35         Log.d("UPUP", intent.getAction());
 36         auc(context, 0);
 37         views.setProgressBar(R.id.widget_ProgressBar, max, current, false);
 38         appmanager.updateAppWidget(thisWidget, views);
 39         Tag = current;
 40         if (intent.getAction().equals("zyf.test.widget.UP")) {
 41 
 42             Tag += 1;
 43             Log.d("tagdd", Integer.toString(Tag));
 44 
 45             if (Tag > max) {
 46                 Tag = max;
 47             }
 48             auc(context, 1);
 49             views.setProgressBar(R.id.widget_ProgressBar, max, Tag, false);
 50             appmanager.updateAppWidget(thisWidget, views);
 51         }
 52         if (intent.getAction().equals("zyf.test.widget.DOWN")) {
 53             Tag -= 1;
 54             if (Tag < 0) {
 55                 Tag = 0;
 56             }
 57             auc(context, -1);
 58             views.setProgressBar(R.id.widget_ProgressBar, max, Tag, false);
 59             appmanager.updateAppWidget(thisWidget, views);
 60         }
 61     }
 62 
 63     @Override
 64     public void onUpdate(Context context, AppWidgetManager appWidgetManager,
 65             int[] appWidgetIds) {
 66         // TODO Auto-generated method stub
 67         final int N = appWidgetIds.length;
 68         auc(context, 0);
 69         Log.d("UPUP", "2222222");
 70         // Perform this loop procedure for each App Widget that belongs to this
 71 // provider
 72         for (int i = 0; i < N; i++) {
 73             int appWidgetId = appWidgetIds[i];
 74             RemoteViews views = new RemoteViews(context.getPackageName(),
 75                     R.layout.widget_ui);
 76             Intent UPintent = new Intent("zyf.test.widget.UP");
 77             Intent DOWNintent = new Intent("zyf.test.widget.DOWN");
 78             // 實例化兩個帶有Action 的Intent
 79             PendingIntent pendingIntentUp = PendingIntent.getBroadcast(context,
 80                     0, UPintent, 0);
 81             PendingIntent pendingIntentDown = PendingIntent.getBroadcast(
 82                     context, 0, DOWNintent, 0);
 83             // 實例化兩個以Intent 來構造的PendingIntent
 84             views.setOnClickPendingIntent(R.id.widget_BT_Up, pendingIntentUp);
 85             views.setOnClickPendingIntent(R.id.widget_BT_Down,
 86                     pendingIntentDown);
 87             // 給View 上的兩個按鈕綁定事件，這裡是廣播消息的發送
 88             appWidgetManager.updateAppWidget(appWidgetId, views);
 89         }
 90     }
 91 
 92     public void auc(Context context, int i) {
 93         // TODO Auto-generated method stub
 94 // ---開始音量處理,i=0 僅查詢,i=其他的進行操作
 95         AudioManager am = null;
 96         am = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
 97         max = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
 98         current = am.getStreamVolume(AudioManager.STREAM_MUSIC);
 99         Log.d("MUSIC", "max : " + max + "current : " + current);
100         current = current + i;
101         am.setStreamVolume(AudioManager.STREAM_MUSIC, current, 0);
102     }
103 }
這樣我們的AppWIdget的創建就完成了，可以試試看在桌面上長按，選擇Widget，選擇我們開發的桌面Widget，顯示出來看看效果吧


/******************************************************************************/
android中各種顏色在drawable.xml的值
/******************************************************************************/
原文：http://www.cppblog.com/DoubleW/articles/147478.html
res->values->colors.xml
<?xml version="1.0" encoding="utf-8"?>  
<resources>  
    <drawable name="white">#FFFFFF</drawable>  
    <!-- 白色 -->  
    <drawable name="black">#000000</drawable>  
    <!-- 黑色 -->  
    <drawable name="ivory">#FFFFF0</drawable>  
    <!-- 象牙色 -->  
    <drawable name="lightyellow">#FFFFE0</drawable>  
    <!-- 亮黃色 -->  
    <drawable name="yellow">#FFFF00</drawable>  
    <!-- 黃色 -->  
    <drawable name="snow">#FFFAFA</drawable>  
    <!-- 雪白色 -->  
    <drawable name="floralwhite">#FFFAF0</drawable>  
    <!-- 花白色 -->  
    <drawable name="lemonchiffon">#FFFACD</drawable>  
    <!-- 檸檬綢色 -->  
    <drawable name="cornsilk">#FFF8DC</drawable>  
    <!-- 米綢色 -->  
    <drawable name="seashell">#FFF5EE</drawable>  
    <!-- 海貝色 -->  
    <drawable name="lavenderblush">#FFF0F5</drawable>  
    <!-- 淡紫紅 -->  
    <drawable name="papayawhip">#FFEFD5</drawable>  
    <!-- 番木色 -->  
    <drawable name="blanchedalmond">#FFEBCD</drawable>  
    <!-- 白杏色 -->  
    <drawable name="mistyrose">#FFE4E1</drawable>  
    <!-- 淺玫瑰色 -->  
    <drawable name="bisque">#FFE4C4</drawable>  
    <!-- 桔黃色 -->  
    <drawable name="moccasin">#FFE4B5</drawable>  
    <!-- 鹿皮色 -->  
    <drawable name="navajowhite">#FFDEAD</drawable>  
    <!-- 納瓦白 -->  
    <drawable name="peachpuff">#FFDAB9</drawable>  
    <!-- 桃色 -->  
    <drawable name="gold">#FFD700</drawable>  
    <!-- 金色 -->  
    <drawable name="pink">#FFC0CB</drawable>  
    <!-- 粉紅色 -->  
    <drawable name="lightpink">#FFB6C1</drawable>  
    <!-- 亮粉紅色 -->  
    <drawable name="orange">#FFA500</drawable>  
    <!-- 橙色 -->  
    <drawable name="lightsalmon">#FFA07A</drawable>  
    <!-- 亮肉色 -->  
    <drawable name="darkorange">#FF8C00</drawable>  
    <!-- 暗桔黃色 -->  
    <drawable name="coral">#FF7F50</drawable>  
    <!-- 珊瑚色 -->  
    <drawable name="hotpink">#FF69B4</drawable>  
    <!-- 熱粉紅色 -->  
    <drawable name="tomato">#FF6347</drawable>  
    <!-- 西紅柿色 -->  
    <drawable name="orangered">#FF4500</drawable>  
    <!-- 紅橙色 -->  
    <drawable name="deeppink">#FF1493</drawable>  
    <!-- 深粉紅色 -->  
    <drawable name="fuchsia">#FF00FF</drawable>  
    <!-- 紫紅色 -->  
    <drawable name="magenta">#FF00FF</drawable>  
    <!-- 紅紫色 -->  
    <drawable name="red">#FF0000</drawable>  
    <!-- 紅色 -->  
    <drawable name="oldlace">#FDF5E6</drawable>  
    <!-- 老花色 -->  
    <drawable name="lightgoldenrodyellow">#FAFAD2</drawable>  
    <!-- 亮金黃色 -->  
    <drawable name="linen">#FAF0E6</drawable>  
    <!-- 亞麻色 -->  
    <drawable name="antiquewhite">#FAEBD7</drawable>  
    <!-- 古董白 -->  
    <drawable name="salmon">#FA8072</drawable>  
    <!-- 鮮肉色 -->  
    <drawable name="ghostwhite">#F8F8FF</drawable>  
    <!-- 幽靈白 -->  
    <drawable name="mintcream">#F5FFFA</drawable>  
    <!-- 薄荷色 -->  
    <drawable name="whitesmoke">#F5F5F5</drawable>  
    <!-- 煙白色 -->  
    <drawable name="beige">#F5F5DC</drawable>  
    <!-- 米色 -->  
    <drawable name="wheat">#F5DEB3</drawable>  
    <!-- 淺黃色 -->  
    <drawable name="sandybrown">#F4A460</drawable>  
    <!-- 沙褐色 -->  
    <drawable name="azure">#F0FFFF</drawable>  
    <!-- 天藍色 -->  
    <drawable name="honeydew">#F0FFF0</drawable>  
    <!-- 蜜色 -->  
    <drawable name="aliceblue">#F0F8FF</drawable>  
    <!-- 艾利斯蘭 -->  
    <drawable name="khaki">#F0E68C</drawable>  
    <!-- 黃褐色 -->  
    <drawable name="lightcoral">#F08080</drawable>  
    <!-- 亮珊瑚色 -->  
    <drawable name="palegoldenrod">#EEE8AA</drawable>  
    <!-- 蒼麒麟色 -->  
    <drawable name="violet">#EE82EE</drawable>  
    <!-- 紫羅蘭色 -->  
    <drawable name="darksalmon">#E9967A</drawable>  
    <!-- 暗肉色 -->  
    <drawable name="lavender">#E6E6FA</drawable>  
    <!-- 淡紫色 -->  
    <drawable name="lightcyan">#E0FFFF</drawable>  
    <!-- 亮青色 -->  
    <drawable name="burlywood">#DEB887</drawable>  
    <!-- 實木色 -->  
    <drawable name="plum">#DDA0DD</drawable>  
    <!-- 洋李色 -->  
    <drawable name="gainsboro">#DCDCDC</drawable>  
    <!-- 淡灰色 -->  
    <drawable name="crimson">#DC143C</drawable>  
    <!-- 暗深紅色 -->  
    <drawable name="palevioletred">#DB7093</drawable>  
    <!-- 蒼紫羅蘭色 -->  
    <drawable name="goldenrod">#DAA520</drawable>  
    <!-- 金麒麟色 -->  
    <drawable name="orchid">#DA70D6</drawable>  
    <!-- 淡紫色 -->  
    <drawable name="thistle">#D8BFD8</drawable>  
    <!-- 薊色 -->  
    <drawable name="lightgray">#D3D3D3</drawable>  
    <!-- 亮灰色 -->  
    <drawable name="lightgrey">#D3D3D3</drawable>  
    <!-- 亮灰色 -->  
    <drawable name="tan">#D2B48C</drawable>  
    <!-- 茶色 -->  
    <drawable name="chocolate">#D2691E</drawable>  
    <!-- 巧可力色 -->  
    <drawable name="peru">#CD853F</drawable>  
    <!-- 秘魯色 -->  
    <drawable name="indianred">#CD5C5C</drawable>  
    <!-- 印第安紅 -->  
    <drawable name="mediumvioletred">#C71585</drawable>  
    <!-- 中紫羅蘭色 -->  
    <drawable name="silver">#C0C0C0</drawable>  
    <!-- 銀色 -->  
    <drawable name="darkkhaki">#BDB76B</drawable>  
    <!-- 暗黃褐色 -->  
    <drawable name="rosybrown">#BC8F8F</drawable>  
    <!-- 褐玫瑰紅 -->  
    <drawable name="mediumorchid">#BA55D3</drawable>  
    <!-- 中粉紫色 -->  
    <drawable name="darkgoldenrod">#B8860B</drawable>  
    <!-- 暗金黃色 -->  
    <drawable name="firebrick">#B22222</drawable>  
    <!-- 火磚色 -->  
    <drawable name="powderblue">#B0E0E6</drawable>  
    <!-- 粉藍色 -->  
    <drawable name="lightsteelblue">#B0C4DE</drawable>  
    <!-- 亮鋼蘭色 -->  
    <drawable name="paleturquoise">#AFEEEE</drawable>  
    <!-- 蒼寶石綠 -->  
    <drawable name="greenyellow">#ADFF2F</drawable>  
    <!-- 黃綠色 -->  
    <drawable name="lightblue">#ADD8E6</drawable>  
    <!-- 亮藍色 -->  
    <drawable name="darkgray">#A9A9A9</drawable>  
    <!-- 暗灰色 -->  
    <drawable name="darkgrey">#A9A9A9</drawable>  
    <!-- 暗灰色 -->  
    <drawable name="brown">#A52A2A</drawable>  
    <!-- 褐色 -->  
    <drawable name="sienna">#A0522D</drawable>  
    <!-- 赭色 -->  
    <drawable name="darkorchid">#9932CC</drawable>  
    <!-- 暗紫色 -->  
    <drawable name="palegreen">#98FB98</drawable>  
    <!-- 蒼綠色 -->  
    <drawable name="darkviolet">#9400D3</drawable>  
    <!-- 暗紫羅蘭色 -->  
    <drawable name="mediumpurple">#9370DB</drawable>  
    <!-- 中紫色 -->  
    <drawable name="lightgreen">#90EE90</drawable>  
    <!-- 亮綠色 -->  
    <drawable name="darkseagreen">#8FBC8F</drawable>  
    <!-- 暗海蘭色 -->  
    <drawable name="saddlebrown">#8B4513</drawable>  
    <!-- 重褐色 -->  
    <drawable name="darkmagenta">#8B008B</drawable>  
    <!-- 暗洋紅 -->  
    <drawable name="darkred">#8B0000</drawable>  
    <!-- 暗紅色 -->  
    <drawable name="blueviolet">#8A2BE2</drawable>  
    <!-- 紫羅蘭藍色 -->  
    <drawable name="lightskyblue">#87CEFA</drawable>  
    <!-- 亮天藍色 -->  
    <drawable name="skyblue">#87CEEB</drawable>  
    <!-- 天藍色 -->  
    <drawable name="gray">#808080</drawable>  
    <!-- 灰色 -->  
    <drawable name="grey">#808080</drawable>  
    <!-- 灰色 -->  
    <drawable name="olive">#808000</drawable>  
    <!-- 橄欖色 -->  
    <drawable name="purple">#800080</drawable>  
    <!-- 紫色 -->  
    <drawable name="maroon">#800000</drawable>  
    <!-- 粟色 -->  
    <drawable name="aquamarine">#7FFFD4</drawable>  
    <!-- 碧綠色 -->  
    <drawable name="chartreuse">#7FFF00</drawable>  
    <!-- 黃綠色 -->  
    <drawable name="lawngreen">#7CFC00</drawable>  
    <!-- 草綠色 -->  
    <drawable name="mediumslateblue">#7B68EE</drawable>  
    <!-- 中暗藍色 -->  
    <drawable name="lightslategray">#778899</drawable>  
    <!-- 亮藍灰 -->  
    <drawable name="lightslategrey">#778899</drawable>  
    <!-- 亮藍灰 -->  
    <drawable name="slategray">#708090</drawable>  
    <!-- 灰石色 -->  
    <drawable name="slategrey">#708090</drawable>  
    <!-- 灰石色 -->  
    <drawable name="olivedrab">#6B8E23</drawable>  
    <!-- 深綠褐色 -->  
    <drawable name="slateblue">#6A5ACD</drawable>  
    <!-- 石藍色 -->  
    <drawable name="dimgray">#696969</drawable>  
    <!-- 暗灰色 -->  
    <drawable name="dimgrey">#696969</drawable>  
    <!-- 暗灰色 -->  
    <drawable name="mediumaquamarine">#66CDAA</drawable>  
    <!-- 中綠色 -->  
    <drawable name="cornflowerblue">#6495ED</drawable>  
    <!-- 菊蘭色 -->  
    <drawable name="cadetblue">#5F9EA0</drawable>  
    <!-- 軍蘭色 -->  
    <drawable name="darkolivegreen">#556B2F</drawable>  
    <!-- 暗橄欖綠 -->  
    <drawable name="indigo">#4B0082</drawable>  
    <!-- 靛青色 -->  
    <drawable name="mediumturquoise">#48D1CC</drawable>  
    <!-- 中綠寶石 -->  
    <drawable name="darkslateblue">#483D8B</drawable>  
    <!-- 暗灰藍色 -->  
    <drawable name="steelblue">#4682B4</drawable>  
    <!-- 鋼蘭色 -->  
    <drawable name="royalblue">#4169E1</drawable>  
    <!-- 皇家藍 -->  
    <drawable name="turquoise">#40E0D0</drawable>  
    <!-- 青綠色 -->  
    <drawable name="mediumseagreen">#3CB371</drawable>  
    <!-- 中海藍 -->  
    <drawable name="limegreen">#32CD32</drawable>  
    <!-- 橙綠色 -->  
    <drawable name="darkslategray">#2F4F4F</drawable>  
    <!-- 暗瓦灰色 -->  
    <drawable name="darkslategrey">#2F4F4F</drawable>  
    <!-- 暗瓦灰色 -->  
    <drawable name="seagreen">#2E8B57</drawable>  
    <!-- 海綠色 -->  
    <drawable name="forestgreen">#228B22</drawable>  
    <!-- 森林綠 -->  
    <drawable name="lightseagreen">#20B2AA</drawable>  
    <!-- 亮海藍色 -->  
    <drawable name="dodgerblue">#1E90FF</drawable>  
    <!-- 閃蘭色 -->  
    <drawable name="midnightblue">#191970</drawable>  
    <!-- 中灰蘭色 -->  
    <drawable name="aqua">#00FFFF</drawable>  
    <!-- 淺綠色 -->  
    <drawable name="cyan">#00FFFF</drawable>  
    <!-- 青色 -->  
    <drawable name="springgreen">#00FF7F</drawable>  
    <!-- 春綠色 -->  
    <drawable name="lime">#00FF00</drawable>  
    <!-- 酸橙色 -->  
    <drawable name="mediumspringgreen">#00FA9A</drawable>  
    <!-- 中春綠色 -->  
    <drawable name="darkturquoise">#00CED1</drawable>  
    <!-- 暗寶石綠 -->  
    <drawable name="deepskyblue">#00BFFF</drawable>  
    <!-- 深天藍色 -->  
    <drawable name="darkcyan">#008B8B</drawable>  
    <!-- 暗青色 -->  
    <drawable name="teal">#008080</drawable>  
    <!-- 水鴨色 -->  
    <drawable name="green">#008000</drawable>  
    <!-- 綠色 -->  
    <drawable name="darkgreen">#006400</drawable>  
    <!-- 暗綠色 -->  
    <drawable name="blue">#0000FF</drawable>  
    <!-- 藍色 -->  
    <drawable name="mediumblue">#0000CD</drawable>  
    <!-- 中蘭色 -->  
    <drawable name="darkblue">#00008B</drawable>  
    <!-- 暗藍色 -->  
    <drawable name="navy">#000080</drawable>  
    <!-- 海軍色 -->
    
  
/******************************************************************************/
Android 藍牙( Bluetooth)耳機連接分析及實現
/******************************************************************************/
在SystemService啟動的時候，會生成一個BluetoothDeviceService的實例。
    // Skip Bluetooth if we have an emulator kernel
    // TODO: Use a more reliable check to see if the produce should
    // support Bluetooth - see bug 988521
    if(SystemProperties.get("ro.kernel.qeum").equals("1")) {
        Log.i(TAG, "Registering null Bluetooth Service (emulator)");
        ServiceManager.addService(Context.BLUETOOTH_SERVICE, null);
    } else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
        Log.i(TAG, "Registering null Bluetooth Service (factory test)");
        ServiceManager.addService(Context.BLUETOOTH_SERVICE, null);
    } else {
        Log.i(TAG, "Starting Bluetooth Service.");
        bluetooth = new BluetoothDeviceService(context);
        bluetooth.init();
        ServiceManager.addService(Context.BLUETOOTH_SERVICE, bluetooth);

        int bluetoothOn = Settings.System.getInt(mContentResolver,
                          Setting.System.BLUETOOTH_ON, 0);
        if(bluetoothOn > 0) {
            bluetooth.enable(null);
        }
    }
BluetoothDeviceService會生成一個BluetoothEventLoop實例，它們兩者均通過DBUS來和BlueZ通信。BluetoothDeviceService是通過DBUS向BlueZ發送命令，而命令的
返回結果則是由BlueZ也會通過DBUS向BluetoothEventLoop發送一些事件通知。BluetoothEventLoop和外部的接口是通過預先定義的Intent，初始的時候藍芽是沒有使能
的，要通過BluetoothSettings或者WirelessSettings來打開藍芽設備，然後通過BluetoothSettings去查找附近的其他藍芽設備，找到後可以建立RFCOMM連接和配對。

藍芽耳機            
Android 實現了對Headset 和Handsfree 兩種profile 的支援。其實現核心是BluetoothHeadsetService，在PhoneApp 創建的時候會啟動它。
 if (getSystemService(Context.BLUETOOTH_SERVICE) != null) {
  mBtHandsfree = new BluetoothHandsfree(this, phone);
  startService(new Intent(this, BluetoothHeadsetService.class));
 } else {
  // Device is not bluetooth capable
  mBtHandsfree = null;
 }

BluetoothHeadsetService 通過接收ENABLED_ACTION、BONDING_CREATED_ACTION 、DISABLED_ACTION 和REMOTE_DEVICE_DISCONNECT_REQUESTEDACTION 來改變狀態，它也會監
聽Phone 的狀態變化。
IntentFilter filter = new IntentFilter(BluetoothIntent.BONDING_CREATED_ACTION);
filter.addAction(BluetoothIntent.REMOTE_DEVICE_DISCONNECT_REQUESTED_ACTION);
filter.addAction(BluetoothIntent.ENABLED_ACTION);
filter.addAction(BluetoothIntent.DISABLED_ACTION);
registerReceiver(mBluetoothIntentReceiver, filter);
mPhone.registerForPhoneStateChanged(mStateChangeHandler,PHONE_STATE_CHANGED, null);
BluetoothHeadsetService 收到ENABLED_ACTION時，會先向BlueZ註冊Headset 和Handsfree 兩種profile（通過執行sdptool 來實現的，均作為Audio Gateway），然後讓
BluetoothAudioGateway 接收RFCOMM 連接，讓BluetoothHandsfree 接收SCO連接（這些操作都是為了讓藍牙耳機能主動連上Android）。
 if (action.equals(BluetoothIntent.ENABLED_ACTION)) {
 // SDP server may not be ready, so wait 3 seconds before
 // registering records.
 // TODO: Use a different mechanism to register SDP records,
 // that actually ACK』s on success, so that we can retry rather
 // than hardcoding a 3 second guess.
  mHandler.sendMessageDelayed(mHandler.obtainMessage(REGISTER_SDP_RECORDS),3000);
  mAg.start(mIncomingConnectionHandler);
  mBtHandsfree.onBluetoothEnabled();
 }
 BluetoothHeadsetService 收到DISABLED_ACTION 時，會停止BluetoothAudioGateway 和BluetoothHandsfree。
 if (action.equals(BluetoothIntent.DISABLED_ACTION)) {
  mBtHandsfree.onBluetoothDisabled();
  mAg.stop();
 }
Android 跟藍牙耳機建立連接有兩種方式。
1. Android 主動跟藍牙耳機連
BluetoothSettings 中和藍牙耳機配對上之後， BluetoothHeadsetService 會收到BONDING_CREATED_ACTION，這個時候BluetoothHeadsetService
 會主動去和藍牙耳機建立RFCOMM 連接。
 if (action.equals(BluetoothIntent.BONDING_CREATED_ACTION)) {
  if (mState == BluetoothHeadset.STATE_DISCONNECTED) {
  // Lets try and initiate an RFCOMM connection
   try {
    mBinder.connectHeadset(address, null);
   } catch (RemoteException e) {}
  }
 }
RFCOMM 連接的真正實現是在ConnectionThread 中，它分兩步，第一步先通過SDPClient 查詢藍牙設備時候支援Headset 和Handsfree profile。
 // 1) SDP query
 SDPClient client = SDPClient.getSDPClient(address);
 if (DBG) log(」Connecting to SDP server (」 + address + 「)…」);
 if (!client.connectSDPAsync()) {
  Log.e(TAG, 「Failed to start SDP connection to 」 + address);
  mConnectingStatusHandler.obtainMessage(SDP_ERROR).sendToTarget();
  client.disconnectSDP();
  return;
 }
 if (isInterrupted()) {
  client.disconnectSDP();
  return;
 }
 if (!client.waitForSDPAsyncConnect(20000)) { // 20 secs
  if (DBG) log(」Failed to make SDP connection to 」 + address);
  mConnectingStatusHandler.obtainMessage(SDP_ERROR).sendToTarget();
  client.disconnectSDP();
  return;
 }
 if (DBG) log(」SDP server connected (」 + address + 「)」);
 int headsetChannel = client.isHeadset();
 if (DBG) log(」headset channel = 」 + headsetChannel);
 int handsfreeChannel = client.isHandsfree();
 if (DBG) log(」handsfree channel = 」 + handsfreeChannel);
 client.disconnectSDP();
 
第2步才是去真正建立RFCOMM 連接。
// 2) RFCOMM connect
 mHeadset = new HeadsetBase(mBluetooth, address, channel);
 if (isInterrupted()) {
  return;
 }
 int result = mHeadset.waitForAsyncConnect(20000, // 20 secs
 mConnectedStatusHandler);
 if (DBG) log(」Headset RFCOMM connection attempt took 」 +(System.currentTimeMillis() – timestamp) + 」 ms」);
 if (isInterrupted()) {
  return;
 }
 if (result < 0) {
  Log.e(TAG, 「mHeadset.waitForAsyncConnect() error: 」 + result);
  mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
  return;
 } else if (result == 0) {
  Log.e(TAG, 「mHeadset.waitForAsyncConnect() error: 」 + result +」(timeout)」);
  mConnectingStatusHandler.obtainMessage(RFCOMM_ERROR).sendToTarget();
  return;
 } else {
  if (DBG) log(」mHeadset.waitForAsyncConnect() success」);
  mConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED).sendToTarget();
 }
當RFCOMM連接成功建立後，BluetoothHeadsetDevice 會收到RFCOMM_CONNECTED消息，它會調用BluetoothHandsfree 來建立SCO 連接，廣播通知Headset狀態變化的Intent（PhoneApp 和BluetoothSettings 會接收這個Intent）。
 case RFCOMM_CONNECTED:
 // success
 if (DBG) log(」Rfcomm connected」);
 if (mConnectThread != null) {
  try {
   mConnectThread.join();
  } catch (InterruptedException e) {
   Log.w(TAG, 「Connect attempt cancelled, ignoring
   RFCOMM_CONNECTED」, e);
   return;
  }
  mConnectThread = null;
 }
 setState(BluetoothHeadset.STATE_CONNECTED,BluetoothHeadset.RESULT_SUCCESS);
 mBtHandsfree.connectHeadset(mHeadset, mHeadsetType);
 break;
 
BluetoothHandsfree 會先做一些初始化工作，比如根據是Headset 還是Handsfree 初始化不同的ATParser，並且啟動一個接收線程從已建立的RFCOMM上接收藍牙耳機過來的控制命令（也就是AT 命令），接著判斷如果是在打電話過程中，才去建立SCO 連接來打通數據通道。
 
 /* package */
 void connectHeadset(HeadsetBase headset, int headsetType) {
  mHeadset = headset;
  mHeadsetType = headsetType;
  if (mHeadsetType == TYPE_HEADSET) {
   initializeHeadsetAtParser();
  } else {
   initializeHandsfreeAtParser();
  }
  headset.startEventThread();
  configAudioParameters();
  if (inDebug()) {
   startDebug();
  }
  if (isIncallAudio()) {
   audioOn();
  }
 }
 
建立SCO 連接是通過SCOSocket 實現的
 /** Request to establish SCO (audio) connection to bluetooth
 * headset/handsfree, if one is connected. Does not block.
 * Returns false if the user has requested audio off, or if there
 * is some other immediate problem that will prevent BT audio.
 */
 /* package */
 synchronized boolean audioOn() {
  mOutgoingSco = createScoSocket();
  if (!mOutgoingSco.connect(mHeadset.getAddress())) {
   mOutgoingSco = null;
  }
  return true;
 }
當SCO 連接成功建立後，BluetoothHandsfree 會收到SCO_CONNECTED 消息，它就會去調用AudioManager 的setBluetoothScoOn函數，從而通知音頻系統有個藍牙耳機可用了。
到此，Android 完成了和藍牙耳機的全部連接。
 case SCO_CONNECTED:
 if (msg.arg1 == ScoSocket.STATE_CONNECTED && isHeadsetConnected()&&mConnectedSco == null) {
  if (DBG) log(」Routing audio for outgoing SCO conection」);
  mConnectedSco = (ScoSocket)msg.obj;
  mAudioManager.setBluetoothScoOn(true);
 } else if (msg.arg1 == ScoSocket.STATE_CONNECTED) {
  if (DBG) log(」Rejecting new connected outgoing SCO socket」);
  ((ScoSocket)msg.obj).close();
  mOutgoingSco.close();
 }
 mOutgoingSco = null;
 break;
 
2. 藍牙耳機主動跟Android連
首先BluetoothAudioGateway 會在一個線程中收到來自藍牙耳機的RFCOMM 連接，然後發送消息給BluetoothHeadsetService。
 mConnectingHeadsetRfcommChannel = -1;
 mConnectingHandsfreeRfcommChannel = -1;
 if(waitForHandsfreeConnectNative(SELECT_WAIT_TIMEOUT) == false) {
  if (mTimeoutRemainingMs > 0) {
   try {
    Log.i(tag, 「select thread timed out, but 」 +
    mTimeoutRemainingMs + 「ms of
    waiting remain.」);
    Thread.sleep(mTimeoutRemainingMs);
   } catch (InterruptedException e) {
    Log.i(tag, 「select thread was interrupted (2),
    exiting」);
    mInterrupted = true;
   }
  }
 }
 
BluetoothHeadsetService 會根據當前的狀態來處理消息，分3 種情況，第一是當前狀態是非連接狀態，會發送RFCOMM_CONNECTED 消息，後續處理請參見前面的分析。
 case BluetoothHeadset.STATE_DISCONNECTED:
 // headset connecting us, lets join
 setState(BluetoothHeadset.STATE_CONNECTING);
 mHeadsetAddress = info.mAddress;
 mHeadset = new HeadsetBase(mBluetooth, mHeadsetAddress,info.mSocketFd,info.mRfcommChan,mConnectedStatusHandler);
 mHeadsetType = type;
 mConnectingStatusHandler.obtainMessage(RFCOMM_CONNECTED).sendToTarget();
 break;
如果當前是正在連接狀態， 則先停掉已經存在的ConnectThread，並直接調用BluetoothHandsfree 去建立SCO 連接。
 case BluetoothHeadset.STATE_CONNECTING:
 // If we are here, we are in danger of a race condition
 // incoming rfcomm connection, but we are also attempting an
 // outgoing connection. Lets try and interrupt the outgoing
 // connection.
 mConnectThread.interrupt();
 // Now continue with new connection, including calling callback
 mHeadset = new HeadsetBase(mBluetooth,mHeadsetAddress,info.mSocketFd,info.mRfcommChan,mConnectedStatusHandler);
 mHeadsetType = type;
 setState(BluetoothHeadset.STATE_CONNECTED,BluetoothHeadset.RESULT_SUCCESS);
 mBtHandsfree.connectHeadset(mHeadset,mHeadsetType);
 // Make sure that old outgoing connect thread is dead.
 break;
 
如果當前是已連接的狀態，這種情況是一種錯誤case，所以直接斷掉所有連接。
 case BluetoothHeadset.STATE_CONNECTED:
 if (DBG) log(」Already connected to 」 + mHeadsetAddress + 「,disconnecting」 +info.mAddress);
 mBluetooth.disconnectRemoteDeviceAcl(info.mAddress);
 break;
藍牙耳機也可能會主動發起SCO 連接， BluetoothHandsfree 會接收到一個SCO_ACCEPTED消息，它會去調用AudioManager 的setBluetoothScoOn 函數，從而通知音頻系統有個藍牙耳機可用了。到此，藍牙耳機完成了和Android 的全部連接。
 
 case SCO_ACCEPTED:
 if (msg.arg1 == ScoSocket.STATE_CONNECTED) {
  if (isHeadsetConnected() && mAudioPossible && mConnectedSco ==null) {
   Log.i(TAG, 「Routing audio for incoming SCO connection」);
   mConnectedSco = (ScoSocket)msg.obj;
   mAudioManager.setBluetoothScoOn(true);
  } else {
   Log.i(TAG, 「Rejecting incoming SCO connection」);
   ((ScoSocket)msg.obj).close();
  }
 } // else error trying to accept, try again
 mIncomingSco = createScoSocket();
 mIncomingSco.accept();
 break;


/******************************************************************************/
Android 上成功實現了藍牙的一些Profile   ref: http://www.oschina.net/question/163910_27105
/******************************************************************************/
前段時間做藍牙方面的開發，Google的Android只實現了Handset/Handfree和A2DP/AVRCP等Profile，而其 它常用的Profile如HID/DUN/SPP/OPP/FTP/PAN等卻沒有實現，並且
Google方面關於何時實現也沒有一個時間表。
前段時間我實現了HID/DUN/SPP三個Profile，下一步實現OPP/FTP等Profile。具體的開發其實也簡單，我是參照A2DP的代碼進行的相關Profile的實現。
Android的Handset/Handfree的實現方式和A2DP/AVRCP的方式有很大的不同，Handset/Handfree是直接 在bluez的RFCOMM Socket上開發的，沒有利用bluez的audio plugin，而
A2DP/AVRCP是在bluez的audio plugin基礎上開發的，所以大大降低了實現的難度。其實bluez的audio plugin上也有Handset/Handfree的實現，但不知道為什麼Google沒有用它，而要在RFCOMM Socket上自己實現一個，這使得Handset/Handfree的實現顯得比較複雜。
HID要用到bluez的input plugin，Android已經把它編譯進去了，在system/lib/bluez-plugin/input.so下，與input.so一起的還 有audio.so庫，那是供A2DP/AVRCP用的。參照frameworks/base/core/jni /android_server_BluetoothA2dpService.cpp，自己寫一個HID用的的.cpp文件，其中跟A2DP一樣利用 DBUS調用input.so庫的CreateDevice/Connect/Disconnect等函數，具體源碼在external/bluez /utils/input/manager.c和external/bluez/utils/input/device.c中。完了之後，參照 frameworks/base/core/java/android/server/BluetoothA2dpService.java和 frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java及 frameworks/base/core/java/android/bluetooth/IBluetoothA2dp.aidl，自己分別寫兩個 JAVA類及AIDL介面，餘下的就是在packages/apps/Settings/src/com/android/settings /bluetooth目錄下的各個文件的修改了，比較省事的方法是搜一下A2DP，只要是A2DP要修改的地方照葫蘆畫瓢添加修改就是了。
DUN/SPP要用到bluez的serial plugin，因Android沒有編譯進去，所以要在external/bluez/utils/serial目錄下寫一個Android.mk，把它 編譯進去，生成system/lib/bluez-plugin/serial.so庫，其它的跟HID類似。

Bluetooth FAQ on Android
URL: http://sites.google.com/a/android.com/opensource/projects/bluetooth-faq
This FAQ refers to the Android Open Source codebase, and is written for platform developers with root access on devices such as the Androd Developer Phone.
Q. How do I compile Android with Bluetooth support enabled?
A. Add this to your BoardConfig.mk:
BOARD_HAVE_BLUETOOTH := true

Q. Does the emulator support Bluetooth?
A. Sorry, not at this time. This would make a nice project if someone wants to take this on.

Q. Bluetooth doesn』t work on my device. How should I debug Bluetooth?
A. First step – read the logs (adb logcat)! In particular look for ERROR or WARNING level messages regarding Bluetooth.
Andoird uses Bluez, which comes with some very useful debugging tools. Here are some examples, in the rough order I use to debug BT.
hciconfig -a # print BT chipset address and features. Useful to check if you can communicate with your BT chipset.
hcidump -XVt # print live HCI UART traffic.
hcitool scan # scan for local devices. Useful to check if RX/TX works.
l2ping ADDRESS # ping another BT device. Useful to check if RX/TX works.
sdptool records ADDRESS # request the SDP records of another BT device.

Q. Where are the logs for the Bluetooth deamons hcid and hciattach?
A. Like all Android system daemons, the STDOUT and STDERR are sent to /dev/null by default. If you want to view these logs you can run the daemons under logwrapper which redirects there output to logcat. Edit init.rc and init.PLATFORM.rc to run these daemons under logwrapper.

Q. I compiled my own system.img for the Android Developer Phone, and hciconfig -a works, but hcitool scan does not. Whats going on?
A. You probably need to install the firmware for the Bluetooth chipset. Unfortunately this firmware is not yet in the open source codebase. However you can adb pull and then adb push it from a stock T-Mobile G1. The location is.
/etc/firmware/brf6300.bin

Q. What Bluetooth Core version does Android support?
A. Bluetooth 2.0 + EDR.

Q. What is the architecture of Bluetooth in Android?
A. We are based on Bluez version 3.36. The diagram below shows our 1.0 layout:

Q. When will Java Bluetooth API』s be released in an SDK?
A. We are not ready to announce a release target for Bluetooth API』s. We do understand there is demand for a Bluetooth API, and it is a top priority for the Android Bluetooth team.

Q. What is needed for Bluetooth 2.1 and Simple Pairing support?
A. We need to move to a Bluez 4.x version.

Profile Support
Q. What is the status of Headset and Handsfree?
A. Android 1.0 is qualified for both HFP and HSP (in the AG role) profiles. We are gladly taking bug fixes on any remaining issues. The one significant feature we lack is eSCO support.

Q. What is the status of A2DP and AVRCP?
A. A2DP and AVRCP work is ongoing for the 『cupcake』 release. We are using the Bluez audio plugin and Bluez SBC codec, with a custom audio path designed for the Android Audio sub-system. Qualificiation is not yet complete.

Q. What is the status of HID?
A. Some very early work is in cupcake – Bluez has an HID plugin which we compile:
external/bluez/utils/input/Android.mk
You can interact directly with this plugin using dbus-send and dbus-monitor. With a little study of the Bluez HID plugin API and some luck and you should be able to connect and use a HID keyboard or mouse. A lot of work remains to be done before we could officially claim HID is supported by the platform. For example we need to plumb the plugin API up in the Android Java framework. And the Android framework needs better support for HID input methods – new keymaps and mouse support. We do not yet have a release targetted for official HID support.

Q. What is the status for tethering – DUN and PAN.
A. Similar to HID, some very early work is in cupcake. Bluez has DUN and PAN daemons which we compile.
external/bluez/utils/dun/Android.mk
external/bluez/utils/pan/Android.mk
BNEP support is compiled into the kernel with cupcake. With a little experimentation running these daemons (dund or pand) and using pppd or iptables you can test tethering support. A lot of integration work remains before we could officially claim that DUN or PAN is supported by the platform. Like HID, we would need to plumb the DBUS API』s to these daemons up into the Android Java framework, and add code to setup the network paths via pppd and/or iptables. We do not yet have a release targetted for official DUN or PAN support.

分類: Android, bluetooth 標籤: bluetooth
android1.0藍牙問題淺談1
2010年3月31日 zooyoo 沒有評論
cupcake和donut中bluez用的是3.35， eclair中用的是4.47

以下轉自：http://blog.sina.com.cn/s/blog_5dd76ed10100bqav.html
前段時間，研究android藍牙，有些困惑，在android開發者論壇發帖請教，結果沒人回復，無奈只好自己研究了一番。自問自答，希望對有相同困惑的朋友有所幫助，共同提高了，呵呵！
1/ android1.0平台嵌入的BlueZ stack是否支援A2DP？ 根據代碼分析，其實用的bluez是3.35版本。
BlueZ stack是開源社區提供的一套協定棧，其本身的功能是相當豐富的。其主要分為兩部分：內核部分嵌在linux內核中，從linux2.4.6版本之後就 已經內嵌了bluez，之前的版本需要自己打補丁。內核部分主要在兩個文件夾下driver和net。還有一部分是用戶部分，主要包括lib和 utills工具集，從代碼中就可以看到A2DP/AVRCP/HSP等profile都是支援的。當然了，bluez雖然強大，但是並不支援obex協 議及之上的FTP/OPP/BIP/SP等profile， 我想這主要是考慮到OBEX的廣泛性，OBEX不僅是藍牙文件傳輸的基礎協定，也是IrDA的 基礎。所以，OBEX也有一個專門的開源協定棧，即OpenOBEX，如果需要支援FTP等profile，只需要將OpenOBEX及之上的 OpenFTp等移植近來即可。

2/Android1.0對bluez stack做了什麼工作？如果bluez已經支援了A2DP，那麼google為什麼不支援？
眾所周知，Android平台是用JAVA寫的，那麼在App FRAME和linux用戶空間之間需要JNI來實現兩部分之間的通信。BLUEZ內核部分在linux內核中，用戶部分（utils）在linux用戶 空間。android做的工作就是首先用C++對bluez封裝了一層FRAME，實現為COM介面的形式。然後在JNI之上，APP FRAME層用JAVA封裝了一層介面，用來調用COM介面。然後上層應用APPLICATION是用FRAME中的JAVA類介面。由於android 只是封裝了HSP/HFP，所以他並不支援A2DP/AVRCP等profile。

3/如果需要在android1.0平台上支援a2dp等協定，我該怎麼辦？都有什麼解決方案

A2DP解決方案如下：
1）自己封裝兩層介面，模仿HSP的做法
2）跟蹤google的藍牙策略。
分析：
由於google已經將A2DP的支援提上了日程，並聲稱在09年第一季度就會支援A2DP/AVRCP，所以如果我從現在開始自己封裝，鑒於人力/技術 等因素，很可能我還沒做完，google就已經支援了，而且我做完之後的代碼也不能作為開源代碼提供給android，所以工作白做。得不償失。
而且，由於bluez開源組織聲稱在即將推出的bluez4.x版本之後會對協定棧架構進行較大調整，產生後向相容性問題。而google考慮到 android平台作為一個開源平台，其api穩定性是必須考慮的問題，所以其必然會採用4x版本（這也是google在android1.0 remove 藍牙API的原因之一）。這樣，自己開發的意義更是不復存在。

FTP/OPP解決方案：
1）移植OpenOBEX及之上的OpenFTP等。
分析：
由於google似乎並沒有公佈其支援FTP的schedule，所以如果要支援文件傳輸這一藍牙最常用功能的話，我想只有自己想辦法了。~~

分類: Android, bluetooth 標籤: bluetooth
ARM平台上藍牙協定棧Bluez的移植使用和配置(轉)
2010年3月30日 zooyoo 沒有評論
作者：劉旭暉 Raymond轉載請註明出處

Email：colorant@163.com
BLOG：http://blog.csdn.net/colorant/
主頁：http://rgbbones.googlepages.com/
Bluez作為當前最成熟的開源藍牙協定棧，在Linux的各大發行版中已經得到了廣泛的應用。在桌面環境下，使用Bluez應該已經沒有太大的問 題，本文的主要目的是介紹在嵌入式平台上，搭建和配置Bluez的各個Profile運行所需做的工作，討論可能遇到的問題，介紹一些工具的使用和工作原 理。因為本人的能力和測試時間有限，可能下文中有些理解、分析不一定準確，歡迎聯繫指正。
1         相關說明
1.1        網站資源
Bluez的官方網址：http://www.bluez.org/ 這裡提供最新的源碼下載，最近伺服器崩潰了一次，有些東西沒了。。。。
Bluez的Wiki：http://wiki.bluez.org/wiki/ 這裡提供Bluez相關的Howto等文檔資源
相關郵件列表：
https://lists.sourceforge.net/lists/listinfo/bluez-users 關於如何使用和配置Bluez，多數是在討論PC環境下的問題。。。。
https://lists.sourceforge.net/lists/listinfo/bluez-devel Bluez開發者活動的地方，有什麼Bug之類的懷疑，還有編程介面之類的問題，就發到這裡吧。

1.2        工作環境
個人感覺，使用Bluez最大的問題就是文檔的欠缺，除了Wiki上的有限資料以外，很難找到其它有用的文檔。
由於Bluez的代碼實現更新變化得很快，網上的許多文檔介紹的都是早期版本的使用，再有的文章多數是基於成熟的Linux發行版，來討論藍牙設備的配置和使用，對於嵌入系統開發，自己編譯，搭建和配置相關環境的文章很少。此外和具體藍牙晶片相關的資料也很難找到。
這裡我不打算也沒有能力寫一個完整的指南，只能基於前段時間在自己的板子上所做的工作，總結一下相關的步驟和所遇到的各類問題以及這期間所掌握的各種相關知識。希望能給有類似開發需求的朋友一些有益的幫助，下面是這篇文章所基於的工作環境：
?       硬體平台：基於ARM的嵌入式板子
?       藍牙晶片：CSR BC4 ROM 版本晶片，不帶eeprom
?       軟體環境：Linux 2.6.21 ，自製文件系統
?       Bluez版本：bluez-libs 3.22  bluez-utils 3.22

2         編譯
2.1        內核
相信多數人使用的都是2.6的內核了，在2.6的內核中要支援Bluez，只要你的內核版本不是太舊，無需打Patch，直接配置好就OK了，內核 裡面的代碼相對比較穩定了。當然，Bluez對一些Bluetooth協定棧新特性的支援，還是需要更新kernel代碼的。你應該確認你使用的 kernel版本是否以及包含了對應的支援。
內核的配置，基本上把 networking下 — Bluetooth subsystem support 裡的以下幾項全部選上即可：
L2CAP protocol support
SCO links support
RFCOMM protocol support
RFCOMM TTY support
BNEP protocol support
HIDP protocol support
此外，在Bluetooth device drivers裡選上你所需要支援的Bluetooth設備。我使用的CSR的chip是我們直接build在板子上，通過串口和cpu通訊的，晶片默認使用BCSP作為通訊協定，所以我選擇了：
HCI UART driver
BCSP protocol support
如果你是通過usb介面使用藍牙適配器，需要選擇
HCI USB driver

2.2        Bluez Lib / Utils
Bluez Lib的編譯比較簡單，而Bluez-Utils所依賴的庫就比較多了，大體包括 dbus alsa hal gstreamer openobex xml等等，仔細觀察./configure 的輸出，將所需要的包先安裝或者build好。
值得注意的一點是：
如果你需要打開所有的功能模組的支援，需要在 ./configure 參數中添加 –enable-all  –enable-audio –enable-input –enable-network –enable-serial 等，在3.22版本中 –enable-all 居然不包括 audio等相關模組的service的編譯，不知道是否是因為還保留了daemon和service等不同方案的緣故。不過，這至少與他的 configure –help 對於 –enable-all 的描述是不符合的。

3         藍牙硬體初始化及基礎服務啟動
如果在PC環境下，使用Ubuntu，調用 /etc/init.d/bluetooth start 應該就能完成這一步的工作了。下面敘述一下在我的嵌入式環境下，如何手動完成這一步驟。
3.1        何謂硬體初始化
硬體初始化，指的是配置藍牙晶片，將其置於一個能夠正常通訊的狀態。
對於CSR的晶片來說，就是通過設置PSKEY，設置其晶振頻率，UART波特率等等一些關鍵參數。 如果使用的是USB形式的適配器，因為其EEPROM存儲了相關的默認參數，這一步很可能不需要做，而我使用的是不帶EEPROM的ROM版本晶片，如何 正確完成初始化工作著實讓我折騰了一陣。
對於其它晶片，沒有太多研究，不過，據我有限的瞭解，TI的晶片在hciattach時也需要完成一些額外的初始化工作，其它如ST的晶片則可能需要下載firmware。
3.2        硬體初始化步驟
通常藍牙晶片的初始化和協定綁定可以通過 hciattach 來完成（通過配置bluez的啟動腳本，可以不需要使用hciattach，標準發行版應該都是不用hciattach，如何配置，還沒有研究 。。。 8 ）
Hciattach 需要的參數主要包括 TTY節點，設備類型，波特率等。多數類型的設備的初始化工作，在選擇了正確的設備類型參數後，都由hciattach在init_uart函數中調用具體的初始化函數所完成。
很遺憾的是，因為要重新設置晶振頻率和波特率，並同步BCSP協定，這種方式好像處理不了我所使用的晶片（不排除我沒有找到正確的解決方案的可能 性），我最終的解決辦法是在hciattach之前，使用Bluez-utils裡的BCCMD工具先完成這些PSKEY的設置工作。
具體命令是：
bccmd -t bcsp -d /dev/ttyS1 psload -r csr.psr
在這時，由於HCI介面還沒有啟動，所以只能使用BCSP協定來進行通訊，我的設備是暴露在ttyS1下，你的可能不一樣，-r參數指明在psload完成 PSKEY的批量加載操作之後，對晶片進行Warmreset，否則這些參數的修改不會起作用。
Csr.psr的內容取決與你的晶片，我的大致如下：
// PSKEY_ANA_FREQ
&01fe = 9C40 // 相當於40M的晶振
// PSKEY_UART_BAUD_RATE
&01be = 0EBF // 921600的波特率
// PSKEY_UART_SEQ_WINSIZE
&0407 = 0006
// BDADDR
&0001 = 1122 3344 5566 7788
。。。
這裡有個問題，你會發現，通過bccmd -t bcsp psset 命令理論上應該是可以單步設置每一個PSKEY的，但是從我實踐看來，單步的操作在兩次對bccmd的調用過程中，上一次對PSKEY的修改，都會在下一 次調用之前被復位，從代碼上看估計和BCSP協定的同步過程有關。

3.2.1          關於PSKEY的獲取
如何獲得正確的完整的PSKEY參數，大概會有幾個途徑：
?       通過CSR的網站下載boot_strap包，這是CSR自己的BCHS協定棧所使用的初始化代碼，在裡面找到你所需要的pskey值。
?       下載CSR的bluesuite工具，裡面包含了一個叫pstool的工具，可以用它來讀寫CSR的Casira開發板或其它BT設備的PSKEY設置，試驗並找出你能用的參數。
?       找CSR或模組廠商支援 8 ）
不過，基本上來說，如果只是要讓晶片通過串口能夠和Bluez協定棧正常通訊上，只需要設置PSKEY_ANA_FREQ 和 PSKEY_UART_BAUD_RATE 這兩個PSKEY就可以了。

3.3        Daemon進程的啟動
早先的版本裡，Bluez的Daemon很多，但是最近的版本，很多daemon都轉為service的形式來做了，3.22 裡面包括了以下這幾個Service，其它profile貌似還保留著daemon的形式。
bluetoothd-service-serial
bluetoothd-service-network
bluetoothd-service-audio
bluetoothd-service-input
這幾個Service的啟動依賴於hcid的啟動以及相關的配置文件
主要配置文件位於：/etc/bluetooth/
此外，通常還需要啟動SDP來提供服務查詢，另外，Bluez本身還依賴於Dbus daemon的運行。
所以，整體上來說，我的手動啟動Bluez的全過程如下：（其中內核代碼是以模組形式編譯的）
insmod bluetooth.ko
insmod hci_uart.ko
insmod l2cap.ko
insmod rfcomm.ko
insmod sco.ko
insmod hidp.ko
/etc/rc2.d/S20dbus start
bccmd -t bcsp -d /dev/ttyS1 psload -r csr.psr
hciattach -s 921600 /dev/ttyS1 bcsp 921600
hciconfig hci0 up
sdpd
hcid –d

4         Paring配對
4.1        Passkey_agent
在正常使用一個藍牙設備前，通常都需要對該設備進行配對綁定的操作。
Bluez的配對機制貌似也修改了幾次，2.x版本中通過pin_helper來處理pin code的應答，3.22版本裡使用的配對機制，其API是基於Dbus來實現的，需要向dbus註冊一個agent，PC的發行版通常都會有一些基於各 種圖形庫的passkey_agent，對於嵌入式系統，這部分代碼可以想像，應該是要按照相應的API自己實現一個，為了測試，我直接使用了 bluez-utils/daemon 目錄下的passkey-agent
這是一個命令行下的可以使用預先設定的pin code進行配對的程式
為了使用它，我的文件系統裡 /etc/Bluetooth/hcid.conf 中 option一節類似如下 ：
# HCId options
options {
# Automatically initialize new devices
autoinit yes;
# Security Manager mode
#   none – Security manager disabled
#   auto – Use local PIN for incoming connections
#   user – Always ask user for a PIN
#
security user;
# Pairing mode
pairing multi;
# Do the same as 「hciconfig hci0 down」 when SetMode(「off」)
# is called.
offmode devdown;
# Default PIN code for incoming connections
passkey 「1234〞;
}

4.2        關於自動配對和請求的發起
配對的發起，這裡主要是從請求的發起者是誰的角度來說。
通常可能不需要關心配對請求是由本地還是由遠端發起的，使用passkey_agent都能夠正確處理。
不過如果在hcid.conf中將 Security Manager mode 設置為 auto，則Bluez會將passkey後面的字串作為默認的Pin code，自動答覆遠端發起的配對請求。這是在沒有使用passkey_agent的情況下的一種配對方式。
在這種情況下，Bluez可以處理遠端的配對請求，但是對於本地發起的配對請求，將無法正確處理，我沒有仔細的分析原因，或許是代碼特意設計成這種 工作方式。所以在無法明確知道誰將會主動先發起配對請求的情況下，使用Atuo模式，可能就會出現有些時候設備能綁定有些時候不能綁定的現象。
通常如果是由本地設備搜索發現的新設備，配對綁定的操作應該也是由本地發起。
另外可以觀察到，對遠端一個非PC類的藍牙設備，如藍牙耳機，如果上次綁定過，在耳機啟動時會主動發起連接請求，如果本地的link key丟失了，也就會再走一次綁定的流程，這種情況下配對請求就是由遠端設備發起的。

5         A2DP
A2DP藍牙立體聲應該是藍牙最常見的Profile之一。
2.x版本的Bluez，對A2DP的支援是通過BTSCO來實現的，3.22的版本通過bluetoothd-service-audio來支援。
對Bluez A2DP profile的支援，還依賴於Alsa或Gstreamer。
5.1        配置
測試A2DP的時候，我使用的是aplay，同時在相關的配置文件裡面寫死了藍牙耳機的地址
主要的配置文件包括：
/etc/asound.conf ：
pcm.bluetooth{
type bluetooth
device 00:02:5B:00:C1:A0
profile 「hifi」
}
/etc/bluetooth/audio.conf ：
[General]
# disable=Sink
SCORouting=PCM

[Headset]
DisableHFP=true

[A2DP]
SourceCount=2
配置好這些以後，使用 aplay -D bluetooth sample.wav 進行測試。
值得注意的是，使用Aplay打開藍牙設備進行播放，需要有如下兩個Alsa的plugin：
/usr/lib/alsa-lib/libasound_module_pcm_bluetooth.so
/usr/lib/alsa-lib/libasound_module_ctl_bluetooth.so
這兩個so文件可以在bluez-utils 裡面找到。需要注意他們和libasound 的版本匹配。

5.2        問題
在測試中發現，如果連接的耳機是由PC上的藍牙適配器提供的AV耳機服務，那麼配對可以完成，但是連接會失敗，真正的耳機則沒有這個問題，不知道是 否是因為以上的方法還存在缺陷？嘗試使用由DBUS發起命令的形式來連接PC的AV耳機服務，也是一樣的問題。是否連接PC模擬的AV耳機服務，首先要切 換設備的role？
沒有測試Ctl介面
如何動態選擇不同的耳機，而不是寫死在腳本裡？（這個想來估計是要自己基於Alsa的API編程處理，aplay無法直接完成測試）
播放大文件會出現under run錯誤，需要測試是由與波特率設置不夠高造成，還是SBC編碼效率不夠，還是這個版本裡存在的bug。

6         DUN的使用
Dun profile運行於rfcomm之上，主要是通過藍牙介面暴露一個Modem的介面，用於提供撥號上網服務。
在這裡所討論的不是提供撥號上網服務本身，而是使用外部設備所提供的這個服務，進行網路連接。
6.1        系統配置
通常為了使用DUN，或者任何一個其它類型的Modem，我們會通過PPP協定來撥號和建立網路連接。
首先需要內核的支援，可以簡單的把 device drivers -> Network device support 下面的PPP相關的內容全部選上。
其次，要編譯應用層的PPP包，我的測試是基於ppp-2.4.4
主要的兩個ppp配置文件：
/etc/ppp/peers/gprs：
/dev/rfcomm0
115200
defaultroute
usepeerdns
nodetach
noauth
local
debug
connect 「/usr/sbin/chat -v -f /etc/ppp/chat-gprs」
/etc/ppp/chat-gprs：
TIMEOUT 10
ABORT 『BUSY』
ABORT 『NO ANSWER』
ABORT 『ERROR』
「」 『ATZ』
SAY 『Init….\n』
OK 『AT+CGDCONT=1,」IP」,」CMWAP」『
ABORT 『NO CARRIER』
SAY 『Dialing….\n』
OK 『ATD*99***1#』
CONNECT 」
前面一個配置文件基本就是那樣了，後面一個，這兩句要根據你的SIM卡的實際情況來處理：
OK 『AT+CGDCONT=1,」IP」,」CMWAP」『
OK 『ATD*99***1#』
這裡我設置的是使用中國移動的CMWAP。
此外，使用CMWAP還需要設置你的瀏覽器的代理伺服器：10.0.0.172 連接埠9201

6.2        連接步驟
首先是要查找提供dun服務的設備，將服務提供在哪個channel通道上。這可以通過sdptool來查看，在我的設備上查詢的結果是在channel 1上：
~ # ./sdptool browse 00:08:C6:77:A0:6C
Browsing 00:08:C6:77:A0:6C …
Service Name: Dial-upnetworking
Service RecHandle: 0×10000
Service Class ID List:
「Dialup Networking」 (0×1103)
「Generic Networking」 (0×1201)
Protocol Descriptor List:
「L2CAP」 (0×0100)
「RFCOMM」 (0×0003)
Channel: 1
Profile Descriptor List:
「Dialup Networking」 (0×1103)
Version: 0×0100
其次，如果rfcomm所需設備節點不存在，將其創建：
mknod -m 666 /dev/rfcomm0 c 216 0
然後就是撥號了，如果該設備之前沒有綁定，這過程中會自動發起綁定操作：
pppd debug dump call gprs &
完成以後就可以看到 ppp0這樣一個網路介面了。
~ # ifconfig
ppp0      Link encap:Point-to-Point Protocol
inet addr:10.154.76.82  P-t-P:192.200.1.21  Mask:255.255.255.255
UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
RX packets:4 errors:0 dropped:0 overruns:0 frame:0
TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:3
RX bytes:64 (64.0 B)  TX bytes:101 (101.0 B)

7         Bluez相關的各種tools的使用
在這一段折騰Bluez的時間裡，越來越發現Bluez相關的許多工具做得還是挺好用的，主要在Bluez-utils/tools 目錄下。只是有一點讓我很遺憾，除了man以外很難找到更多的幫助文檔，而man文檔本身對一些功能的描述也不是很詳細。
其中有些選項，如果你不瞭解藍牙協定棧，或者沒有查閱過相關藍牙晶片的一些文檔，很難搞明白是什麼意思，甚至有些選項的具體參數值的設定，如果不讀源碼你都無從得知有哪些備選值。。。。
能力有限，下面所寫的只是我所用過的有限的幾個工具的一些使用經驗，希望能有所幫助。

7.1        Bccmd
Bccmd是用來和CSR的晶片進行BCCMD（Bluecore command protocol）通訊的一個工具。BCCMD並非藍牙協定棧的標準，而是CSR晶片的專屬協定
Bccmd的調用格式為：bccmd [-t <transport>] [-d <device>] <command> [<args>]
Tansport類型包括 HCI USB BCSP H4等，常用的估計就是HCI和BCSP兩種。需要注意一下他們的使用場合：
HCI是一個抽像的標準的藍牙通訊介面，在基於HCI協定調用BCCMD時，需要在Bluez已經建立好hci介面的基礎上使用。
BCSP（Bluecore Serial Protocol）是CSR自己制定的傳輸層協定，主要目的是用來加強在沒有使用CTS、RTS進行流量控制的情況下進行可靠的數據傳輸的能力。其概念是 相對H3 , H4而言，（ 具體分析，請參考下面雜項一章中相應的小節 ）
BCCMD的主要用途就是用來讀寫pskey，這裡以 psset 這個command來介紹一下格式：
Psset 格式如下： psset [-r] [-s <stores>] <key> <value>
其它都好理解，關鍵是-s參數之後跟的store具體的含義。這個參數可以是數值也可以是字串
查詢CSR的BCCMD相關的文檔，可以找到具體的含義如下：
0×0000 Default
0×0008 psram
0×0001 psi
0×0002 psf
0×0004 psrom
0×0003 psi then psf
0×0007 psi, psf then psrom
0×0009 psram then psi
0x000b psram, psi then psf
0x000f psram, psi, psf then psrom
CSR的藍牙晶片中，PSKEY可能存儲在 rom flash eeprom ram等介質裡，這裡的數值指明了psset/get命令操作PSKEY時所針對的存儲介質及其優先順序，通常我們會用 –s 0×0 或 –s 「default」 來使用該命令，0×0的含義與0xf一樣。
值得注意的是，哪個參數是有效的，還取決於哪一類的存儲介質實際存在於藍牙晶片中，此外，只讀類的介質對寫操作類的命令也是無效的。
基本上來說，所修改的都是位於psram中的pskey，此外，pskey修改以後要起作用，還要一併使用 –r參數，或直接用warmreset命令將藍牙晶片進行warm reset。
7.2        Hciattach
Hciattach主要用來初始化藍牙設備，它的命令格式如下：
hciattach [-n] [-p] [-b] [-t timeout] [-s initial_speed] <tty> <type | id> [speed] [flow|noflow] [bdaddr]
其中最重要的參數就是 type和speed，type決定了要初始化的設備的型號，可以使用 hciattach –l 來列出所支援的設備型號。
並不是所有的參數對所有的設備都是適用的，有些設備會忽略一些參數設置，例如：查看hciattach的代碼就可以看到，多數設備都忽略bdaddr參數。
Hciattach命令內部的工作步驟是：首先打開制定的tty設備，然後做一些通用的設置，如flow等，然後設置波特率為 initial_speed，然後根據type調用各自的初始化代碼，最後將波特率重新設置為speed。所以調用hciattach時，要根據你的實際 情況，設置好initial_speed和speed。
對於type BCSP來說，它的初始化代碼只做了一件事，就是完成BCSP協定的同步操作，它並不對藍牙晶片做任何的pskey的設置。同步操作的具體流程和規範可以參考CSR的相關文檔： BCSP Link Establishment Protocol
7.3        其它
下面幾個，使用了，但是沒有太多研究
7.3.1          Hcidump
Hcidump不在bluez-utils包裡，而是在單獨的hcidump包裡。主要用來分析捕獲和分析HCI數據包，如果使用bluez過程中 出了什麼問題，用hcidump往往可以發現一些出錯的線索，原因。 參數很多，基本上hcidump –X –V 就可以幫你獲得詳細的經過格式解析的數據包。
7.3.2          Hcitool
主要用hcitool來scan遠端的設備，顯示設備地址，名稱等。
例如：Hcitool scan， hcitool inq
7.3.3          Sdptool
主要用來瀏覽遠端設備SDP服務，或者管理本地的SDPD維護的數據庫。
常用的應該就是查找遠端設備的服務了
例如：
sdptool browse 00:02:72:B0:00:26 瀏覽地址為00:02:72:B0:00:26的設備所提供的服務
sdptool search 0×1112 00:02:72:B0:00:26 查找地址為00:02:72:B0:00:26的設備上的Headset Audio Gateway服務。
./sdptool search 0×1112 00:02:72:B0:00:26
Class 0×1112
Inquiring …
Searching for 0×1112 on 00:02:72:B0:00:26 …
Service Name: Headset Audio Gateway
Service RecHandle: 0x1001d
Service Class ID List:
「Headset Audio Gateway」 (0×1112)
「Generic Audio」 (0×1203)
。。。
7.3.4          Hciconfig
這個就不用多說了，格式上很類似於ifconfig，用來設置HCI設備的參數
例如
hciconfig hci0 up 啟動hci0介面
hciconfig hci0 iscan 使能位於hci0介面的藍牙晶片的inquery scan模式（使得設備能被其它藍牙設備發現）

8         雜項
8.1        使用Dbus-send進行測試
由於Bluez使用dbus進行進程間通訊，所以我們可以使用dbus-send命令直接發送命令進行一些查詢，試驗的工作。
Bluez每個Daemon或service所支援的Dbus介面API描述文本，可以在各自的目錄下找到，例如Audio的API寫在 audio/audio-api.txt中。
以Audio為例，可以參考 http://wiki.bluez.org/wiki/HOWTO/AudioDevices 中的描述
8.2        HCI、H4、USB、BCSP 之間的關係
個人理解，嚴格的說HCI和其它幾種protocol並不是可以對比的同一層次的東西。
HCI protocol 並不考慮在實際傳輸載體以及其中的糾錯等問題，只是一個抽像的傳輸層或叫做介面。USB，H3，H4等才是具體的transport layer（此外還有SD Transport layer）。HCI數據包需要附著在這些具體的Transport Layer的協定包中。
以BCSP為例，4種類型的HCI數據包各自使用了一個BCSP通道，做為這些通道的payload封裝在BCSP的協定包裡，需要通過TTY的 lldsic層走一次，並由hci_uart模組做相應的封裝工作。而BCSP還通過其它通道支援其它的一些自定的Protocol。BCSP作為一個具 體的傳輸層協定，還支援了校驗，同步等功能。
H4機制類似，SD和USB transport好像區別比較大一點。具體可以參考 Bluetooth Specification Volume 4.
8.3        BCSP數據包結構
HCI數據包的結構，在bluetooth的spec裡面有詳細定義，不過，CSR自己的BCSP，BCCMD等一系列協定，又添加了一堆的東西， 其中，HCI數據包是作為BCSP的payload，而BCCMD又是作為HCI的payload，所以測試過程中，發覺要分析清楚bluez通過 kernel最後到底往藍牙晶片的串口發送了什麼數據，特別是想要自己手工構建一串數據，著實要看上一堆spec，拼湊起來才能完成。
要具體學習分析一串命令，最好的辦法，我能想到的就是修改bccmd的代碼，將它傳給串口的每一個字串都列印出來，這樣對照這spec看，事半功倍。
例如下面這條，是使用我修改後的bccmd指令。所做的操作是讀取串口波特率的pskey：
./bccmd.dbg -t bcsp -d /dev/ttyS1 psget -s 0×0 0x01be
cmd : 00 fc 13 c2 00 00 09 00 01 00 03 70 00 00 be 01 01 00 00 00 00 00
c0 d1 65 01 c8 00 fc 13 c2 00 00 09 00 01 00 03 70 00 00 be 01 01 00 00 00 00 69 a6 c0
在這裡 HCI的數據包是第一行，具體解釋一下：
頭4個位元組是HCI Head，其中
00 fc ：整體代表這是一個製造商自定義的命令。
13 ：HCI命令長度為0×13。
C2 ：包的內容是唯一的一個BCCMD數據包。
後面是BCCMD的Head
00 00 ：這是一個GetReq命令
09 00 ：BCCMD的命令9個word長度，及18位元組
01 00 ：seqno， 包的順序標記 包1
03 70 ：varid 7003， 表示這是對PSKEY的操作
00 00 ：狀態標誌
再下來是BCCMD的payload
be 01 ：0x01be 波特率PSKEY的index
01 00 ：該PSKEY的長度為1
00 00 ：strore 為 00
00 00 ：該PSKEY的值，這裡是發送讀命令，所以填0
第二行的數據是將HCI包封裝在了BCSP數據包裡：
前面部分：c0 d1 65 01 c8 ：
C0 ：是BCSP數據包的分割符
D1 ：類型為可靠鏈接數據流，有CRC校驗
65 01 ：channel 5 （ HCI CMD ）， 長度為0×16
C8 ：包頭的校驗
後面部分：69 a6 c0：
69 a6 ：整個BCSP包的CRC校驗
C0 ：分隔符號
其它命令類似的分析可得。
如果只是希望看到HCI命令本身，也可以用hcidump來看。這是上面的讀pskey操作通過HCI介面操作的dump：
< HCI Command: Vendor (0x3f|0×0000) plen 19
BCCMD: Get req: len 9 seqno 1 varid 0×7003 status 0
PSKEY: key 0x01be len 1 stores 0×0000
UART_BAUDRATE: value 0 (0×0000)
8.4        Hid / Serial / HF / OBEX
這幾個比較常用的profile，還沒測試哪。。。。。。誰給我買個藍牙滑鼠玩玩？！
8.5        總的遺留問題
整體上，PC上實現的自動識別，自動啟動服務的一整套腳本，還沒有仔細研究。
分類: bluetooth 標籤: bluetooth, bluez
Android Bluetooth Class summary
2010年3月24日 zooyoo 沒有評論
Setting app related
BluetoothSettings is the Settings screen for Bluetooth configuration and connection management.
BluetoothDevicePreference is the preference type used to display each remote Bluetooth device in the Bluetooth Settings screen.
BluetoothDiscoverableEnabler is a helper to manage the 「Discoverable」 checkbox. It sets/unsets discoverability and keeps track of how much time until the the discoverability is automatically turned off.
BluetoothEnabler is a helper to manage the Bluetooth on/off checkbox preference. It is turns on/off Bluetooth and ensures the summary of the preference reflects the current state.
BluetoothEventRedirector receives broadcasts and callbacks from the Bluetooth API and dispatches the event on the UI thread to the right class in the Settings.
BluetoothNamePreference is the preference type for editing the device』s Bluetooth name. It asks the user for a name, and persists it via the Bluetooth API.
BluetoothPinDialog asks the user to enter a PIN for pairing with a remote Bluetooth device. It is an activity that appears as a dialog.
BluetoothPinRequest is a receiver for any Bluetooth pairing PIN request. It checks if the Bluetooth Settings is currently visible and brings up the PIN entry dialog. Otherwise it puts a Notification in the status bar, which can be clicked to bring up the PIN entry dialog.
ConnectSpecificProfilesActivity presents the user with all of the profiles for a particular device, and allows him to choose which should be connected (or disconnected).
LocalBluetoothDevice represents a remote Bluetooth device. It contains attributes of the device (such as the address, name, RSSI, etc.) and functionality that can be performed on the device (connect, pair, disconnect, etc.).
LocalBluetoothDeviceManager manages the set of remote Bluetooth devices.
LocalBluetoothManager provides a simplified interface on top of a subset of the Bluetooth API.
LocalBluetoothProfileManager is an abstract class defining the basic functionality related to a profile.
SettingsBtStatus is a helper class that contains constants for various status codes.
Framework realted
tCommandHandler is handler interface for AtParser.
AtCommandResult represent the final response to an AT command line, and also  intermediate responses to a single command within a chained AT command line.
AtParser object accepts a new command line to parse via its process() method. It breaks each command line into one or more commands. Each command is parsed for name, type, and (optional) arguments, and an appropriate external handler method is called through the AtCommandHandler interface.
BluetoothCmeError: Constants for extended AT error codes specified by the Handsfree profile.
BluetoothAtPhonebook is helper for managing phonebook presentation over AT commands
BluetoothA2dp is a proxy object for controlling the Bluetooth A2DP Service via IPC. Currently this class provides methods to connect to A2DP audio sinks.
BluetoothA2dpService
BluetoothAudioGateway listen』s for incoming RFCOMM connection for the headset / handsfree service.  This class is planned for deletion, in favor of a generic Rfcomm class.
BluetoothClass is static helper methods and constants to decode the device class bit vector returned by the Bluetooth API.
BluetoothDevice manages the local Bluetooth device. Scan for devices, create bondings, power up and down the adapter.
BluetoothDeviceService
BluetoothError: constant error codes
BluetoothEventLoop
BluetoothHeadset is public API for controlling the Bluetooth Headset Service. This includes both Bluetooth Headset and Handsfree (v1.5) profiles. The Headset service will  attempt a handsfree connection first, and fall back to headset.
BluetoothHandsfree: Bluetooth headset manager for the Phone app.
BluetoothHeadsetService extends Service, provides Bluetooth Headset and Handsfree profile, as a service in the Phone application.
BluetoothIntent contains constant intens for bluetooth.
Database is A low-level API to the Service Discovery Protocol (SDP) Database.
HeadsetBase is the base RFCOMM (service) connection for a headset or handsfree device.
RfcommSocket implements an API to the Bluetooth RFCOMM layer. An RFCOMM socket  is similar to a normal socket in that it takes an address and a port number. The difference is of course that the address is a Bluetooth-device address, and the port number is an RFCOMM channel.
ScoSocket: Simple SCO Socket. Currently in Android, there is no support for sending data over a SCO socket – this is managed by the hardware link to the Bluetooth Chip. This class is instead intended for management of the SCO socket lifetime,  and is tailored for use with the headset / handsfree profiles.
文章轉自： http://blog.csdn.net/haojunming/article/details/6693922


/******************************************************************************/
Android bluetooth connect
/******************************************************************************/
package com.ea.test; 

import java.io.IOException; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.util.UUID; 
import android.app.Activity; 
import android.bluetooth.BluetoothAdapter; 
import android.bluetooth.BluetoothDevice; 
import android.bluetooth.BluetoothServerSocket; 
import android.bluetooth.BluetoothSocket; 
import android.content.Intent; 
import android.os.Bundle; 
import android.util.Log; 
import android.view.View; 
import android.view.View.OnClickListener; 
import android.widget.Button; 

public class Bluetooth_one extends Activity { 
    // Debugging
    private static final String TAG = "BluetoothChatService";
    private static final boolean D = true;
    protected static final int REQUEST_ENABLE_BT = 0;
    private Button open = null;
    private Button find = null;
    private Button conn = null;
    private Button trans = null;
    private BluetoothAdapter mBluetoothAdapter=null;
    private int mState;

    // Constants that indicate the current connection state
    public static final int STATE_NONE = 0; // we're doing nothing
    public static final int STATE_LISTEN = 1; // now listening for incoming connections
    public static final int STATE_CONNECTING = 2; // now initiating an outgoing connection
    public static final int STATE_CONNECTED = 3; // now connected to a remote device
    // Unique UUID for this application
    private static final UUID MY_UUID = UUID.fromString("fa87c0d0-afac-11de-8a39-0800200c9a66");
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        open = (Button) findViewById(R.id.open);
        find = (Button) findViewById(R.id.find);
        conn = (Button) findViewById(R.id.conn);
        trans = (Button) findViewById(R.id.trans);
        addLisenner();
    }

    public void addLisenner() {
        open.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub
                mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                if (mBluetoothAdapter == null) {
                    // Device does not support Bluetooth
                    showDialog(R.string.no_support);
                } else {
                    if (!mBluetoothAdapter.isEnabled()) {
                        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                        startActivityForResult(enableBtIntent,REQUEST_ENABLE_BT);
                    }else{

                    }
                }
            }
        });

        find.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                // TODO Auto-generated method stub
                new AcceptThread().start();
            }
        });

        conn.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub
                BluetoothDevice device=mBluetoothAdapter.getRemoteDevice("00:80:37:21:18:81");
                new ConnectThread(device).start();
            }
        });
    }

    /**
    * This thread runs while listening for incoming connections. It behaves
    * like a server-side client. It runs until a connection is accepted
    * (or until cancelled).
    */
    private class AcceptThread extends Thread {
        // The local server socket
        private final BluetoothServerSocket mmServerSocket;

        public AcceptThread() {
            BluetoothServerSocket tmp = null;

            // Create a new listening server socket
            try {
                tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord("ddd", MY_UUID);
            } catch (IOException e) {
                Log.e(TAG, "listen() failed", e);
            }
            mmServerSocket = tmp;
        }

        public void run() {
            if (D) Log.d(TAG, "BEGIN mAcceptThread" + this);
            setName("AcceptThread");
            BluetoothSocket socket = null;

            // Listen to the server socket if we're not connected
            while (mState != STATE_CONNECTED) {
                try {
                    // This is a blocking call and will only return on a
                    // successful connection or an exception
                    socket = mmServerSocket.accept();
                } catch (IOException e) {
                    Log.e(TAG, "accept() failed", e);
                    break;
                }

                // If a connection was accepted
                if (socket != null) {
                    synchronized (Bluetooth_one.this) {
                        switch (mState) {
                            case STATE_LISTEN:
                            case STATE_CONNECTING:
                            // Situation normal. Start the connected thread.
                            // connected(socket, socket.getRemoteDevice());
                            break;
                        case STATE_NONE:
                        case STATE_CONNECTED:
                            // Either not ready or already connected. Terminate new socket.
                            try {
                                socket.close();
                            } catch (IOException e) {
                                Log.e(TAG, "Could not close unwanted socket", e);
                            }
                            break;
                        }
                    }
                }
            }
            if (D) Log.i(TAG, "END mAcceptThread");
        }

        public void cancel() {
            if (D) Log.d(TAG, "cancel " + this);
            try {
                mmServerSocket.close();
            } catch (IOException e) {
                Log.e(TAG, "close() of server failed", e);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        // TODO Auto-generated method stub
        super.onActivityResult(requestCode, resultCode, data);
        if (REQUEST_ENABLE_BT == requestCode) {
            if (resultCode == RESULT_OK) {
                // user open bluetooth
                // mBluetoothAdapter.startDiscovery();
            } else {
                // user not open bluetooth
            }
        }
    }

    private class ConnectedThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;

        public ConnectedThread(BluetoothSocket socket) {
            mmSocket = socket;
            InputStream tmpIn = null;
            OutputStream tmpOut = null;

            // Get the input and output streams, using temp objects because
            // member streams are final
            try {
                tmpIn = socket.getInputStream();
                tmpOut = socket.getOutputStream();
            } catch (IOException e) { }

            mmInStream = tmpIn;
            mmOutStream = tmpOut;
        }

        public void run() {
            byte[] buffer = new byte[1024]; // buffer store for the stream
            int bytes; // bytes returned from read()

            // Keep listening to the InputStream until an exception occurs
            while (true) {
                try {
                    // Read from the InputStream
                    bytes = mmInStream.read(buffer);
                    // Send the obtained bytes to the UI Activity
                    // mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer) .sendToTarget();
                } catch (IOException e) {
                    break;
                }
            }
        }

        /* Call this from the main Activity to send data to the remote device */
        public void write(byte[] bytes) {
            try {
                mmOutStream.write(bytes);
            } catch (IOException e) { }
        }

        /* Call this from the main Activity to shutdown the connection */
        public void cancel() {
            try {
            mmSocket.close();
            } catch (IOException e) { }
        }
    }

    private class ConnectThread extends Thread {
       private final BluetoothSocket mmSocket;
       private final BluetoothDevice mmDevice;

       public ConnectThread(BluetoothDevice device) {
           // Use a temporary object that is later assigned to mmSocket,
           // because mmSocket is final
           BluetoothSocket tmp = null;
           mmDevice = device;

           // Get a BluetoothSocket to connect with the given BluetoothDevice
           try {
               // MY_UUID is the app's UUID string, also used by the server code
               tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
           } catch (IOException e) {
               e.printStackTrace();
           }
           mmSocket = tmp;
       }

       public void run() {
           // Cancel discovery because it will slow down the connection
           // mAdapter.cancelDiscovery();

           try {
               // Connect the device through the socket. This will block
               // until it succeeds or throws an exception

               mmSocket.connect();
           } catch (IOException connectException) {
               // Unable to connect; close the socket and get out
               connectException.printStackTrace();
               try {
                   mmSocket.close();
               } catch (IOException closeException) { }
                   return;
           }

           // Do work to manage the connection (in a separate thread)
           // manageConnectedSocket(mmSocket);
       }

       /** Will cancel an in-progress connection, and close the socket */
       public void cancel() {
           try {
               mmSocket.close();
           } catch (IOException e) { }
       }
    }
}


/******************************************************************************/
Android A2DP(轉載)
/******************************************************************************/
分享:       
最近移植Android，當Android能夠在設備上面運行之後，首先想到的是讓音訊設備跑起來。「沒有聲音，再好的戲也出不來」。本文簡單介紹一下Android音訊適配層。
這個世界音訊設備千變萬化，Android也不可能為每種設備都提供支援。Android定義了一個框架，這個框架來適配底層的音訊設備。該適配層的定義位於：
hardware/libhardware_legacy/include/hardware_legacy/AudioHardwareInterface.h要想視頻底層的音訊設備必須要繼承該檔中定義的AudioStreamOut，AudioStreamIn，AudioHardwareInterface等類，並實現createAudioHardware函數。

下麵我們看一下Android創建音訊設備的代碼，代碼位於：
frameworks/base/libs/audioflinger/AudioHardwareInterface.cpp該檔有如下代碼：
AudioHardwareInterface* AudioHardwareInterface::create() { 
    /* 
     * FIXME: This code needs to instantiate the correct audio device 
     * interface. For now - we use compile-time switches. 
    */ 
    AudioHardwareInterface* hw = 0;
    char value[PROPERTY_VALUE_MAX]; 

    #ifdef 
    GENERIC_AUDIO hw = new AudioHardwareGeneric();
    #else 
    // if running in emulation - use the emulator driver 
    if (property_get("ro.kernel.qemu", value, 0)) {
        LOGD("Running in emulation - using generic audio driver");
        hw = new AudioHardwareGeneric();
    } else { LOGV("Creating Vendor Specific AudioHardware");
        hw = createAudioHardware();
    }
    #endif 

    if (hw->initCheck() != NO_ERROR) { 
        LOGW("Using stubbed audio hardware. No sound will be produced.");
        delete hw;
        hw = new AudioHardwareStub();
    }

    #ifdef 
    WITH_A2DP hw = new A2dpAudioInterface(hw);
    #endif 

    #ifdef 
    ENABLE_AUDIO_DUMP 
    // This code adds a record of buffers in a file to write calls made by AudioFlinger. 
    // It replaces the current AudioHardwareInterface object by an intermediate one which 
    // will record buffers in a file (after sending them to hardware) for testing purpose. 
    // This feature is enabled by defining symbol ENABLE_AUDIO_DUMP. 
    // The output file is set with setParameters("test_cmd_file_name=<name>"). Pause are not recorded in the file. 
    LOGV("opening PCM dump interface"); 
    hw = new AudioDumpInterface(hw);
    // replace interface 
    #endif 
    return hw;
}
從代碼中我們可以看出如果定義了GENERIC_AUDIO的宏，則會創建AudioHardwareGeneric，如果是模擬器的話，AudioHardwareGeneric會不能初始化，
進而創建AudioHardwareStub。這兩個類都是Audio設備的適配層，是Android預設提供的。模擬器都是用AudioHardwareStub，不會有聲音輸出。
設備都是用AudioHardwareGeneric，因為預設GENERIC_AUDIO是設置的。
一般我們只關心AudioHardwareGeneric實現，誰會去給模擬器去調試聲音呢，反正我沒這個閒心。首先說明一下這個音訊適配層是Android自帶的，可以保證你的音訊設備正常
運行，但是不能發揮設備的最佳性能。通過後面的描述你將會瞭解。
AudioHardwareGeneric的定義位於：
frameworks/base/libs/audioflinger/AudioHardwareGeneric.cpp查看源碼你會發現這個適配層需要實現設備/dev/eac，並且該設備只輸出44.1khz取樣速率的音訊資料給
/dev/eac設備，如果不是44.1khz的取樣速率的資料，AudioHardwareGeneric會經過Resample過程把它轉換成44.1kHZ的音訊資料，然後再輸出給音訊設備。
44.1kHZ音訊資料是最普遍的音訊取樣速率，大部分Mp3都是以這個取樣速率壓縮的，所以選擇這個取樣速率做為預設取樣速率還是有一定的合理性的。
AudioHardwareGeneric是軟體實現Resample過程是，效率會比較低。很多音訊設備支援不同取樣速率的資料，可以理解成硬體實現Resample過程。
通過上面的描述我們可以知道這個通用音訊適配層只是讓你的設備可以用而已，不能發揮設備的性能優勢，如果你的設備對音訊品質有更高的要求，必須要自己實現音訊適配
層。谷歌只能保證你的音訊可以播放，但是不能保證效率（他也沒有辦法保證效率）。


/******************************************************************************/
Android How to handle in the correct way Bluetooth connection events?
/******************************************************************************/
UPDATE: I'm rewriting the whole question because I received the final answer directly from google.

Which was the problem?
I'm developing a music player app and I want to allow my users to manage (with settings) some events about wired/bluetooth headset connect/disconnect:

pause when a wired headset is unplugged
pause when a bt headset is unplugged
resume when a bt headset is plugged
resume when a wired headset is plugged
So I created a service that in its onCreate bind it self to receive intent with special actions.

This is the code:
if ( UIUtils.isBeforeHoneycomb() ) {
            commandFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
        } else {
            commandFilter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
            commandFilter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
        }

        registerReceiver(mHeadsetBTReceiver, commandFilter);
UIUtils.isBeforeHoneycomb() is an utility method that tell me if the device is before honeycomb or not because BluetoothHeadset.
ACTION_CONNECTION_STATE_CHANGED and BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED are API Level 11
I've some problem on the event "resume when a bt headset (or general device that handle audio stream) is plugged. Let me talk a bit about my approch.

Let's split out logic in different situations:
Android device with API Level 11 and BT device that support A2DP Profile
In this case everything works like a charm and I receive the event listening to the intent with action BluetoothA2dp.
ACTION_CONNECTION_STATE_CHANGED (API LVL 11)
Android device with API Level 11 and BT device that not support A2DP Profile but support Bluetooth.Headset Profile
In this case I listen to the intent with action BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED and I'll start playing music only when the extra field 
BluetoothProfile.EXTRA_STATE of the intent is equals to BluetoothProfile.STATE_CONNECTED
In this case I found a bug / problem and I don't know how to handle it. Infact if I start to play music when the connection state is equals to 
BluetoothProfile.STATE_CONNECTED it starts to play the sound from the smartphone speakers. After a few seconds (4/5) it route the music stream to the 
bluetooth headset.
My actual dirty trick that let everything works fine is to delay the music play event when the bluetooth device is connect in this way:
new Handler().postDelayed( postPlayRunnable, 4000);
But I don't really like it because it seems really dirty. Android is amazing sending and receiving intent/events so my question is: 
isn't there a correct way to catch the correct time as in A2DP scenario when the smartphone is really connected to the bt device? 
Or maybe another intent/action that tell me when the audio stream is routed correctly to the bt headset.
Android device before API Level 11 and BT device (this doesn't metter if the device support A2DP or Bluetooth.Headset profile because we're below api lvl 11)
In this case the only thing I can do is to listen and receive the intent with action BluetoothDevice.ACTION_ACL_CONNECTED And also in this scenario I'm facing the same problem. When I receive that intent (and I know that we're connected becuase it's the only possible state for this intent) the smartphone is not "really connected" to the bt device because if I start playing the music the sound will be played from the smartphone speaker and only after a few seconds (5/6, much longer than the previous case) the audio stream is routed to the bt headset correctly.
As before I've managed this issue post delaying the music play event.

CONCLUSION AND CODE:
Well I was right :D That is the right way to do that thing with the postDelayed. This is the answer directly from Google:

Hello Emanuele,
I took a look at how Bluetooth is handled in Google apps.
Basically, the playback service registers a BroadcastReceiver for both 
BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED and AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. 
When BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED is received, then a 5-second timer is started. 
When AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED is received, then the timer is canceled and audio is routed to the headset. 
(The receiver uses AudioManager.EXTRA_SCO_AUDIO_STATE to tell whether Bluetooth is starting or stopping.) 
If it is not received, then after 5 seconds, the service assumes it missed the callback and routes audio to the headset anyway.
So your approach is actually very much like what Google does.
To conclude this is my actual way to handle wired/bt headset connection:

This is the code of our BroadcastReceiver mHeadsetBTReceiver
private BroadcastReceiver mHeadsetBTReceiver = new BroadcastReceiver() { 
    @Override public void onReceive(Context context, Intent intent) { 
    String action = intent.getAction();
    if ( action.equals(Intent.ACTION_HEADSET_PLUG) ) {
        final int state = intent.getIntExtra("state", 0);
        //check state and play/pause   
    } else if ( action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED) ) {
        int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        if ( !isPlaying() && state ==  BluetoothProfile.STATE_CONNECTED ) {
            //It's tricky. As explained I don't know why but with BluetoothHeadset when it says it's connected
            //it starts playing music on the phone speakers and then, after 1/2secs it sends music stream
            //to the bluetooth headset so I've to postdelay it
            new Handler().postDelayed( postPlayRunnable, 4000);
        }
        if ( (state ==  BluetoothProfile.STATE_DISCONNECTING || state ==  BluetoothProfile.STATE_DISCONNECTED) ) {
            pause();
        }
    } else if ( action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED) ) {
        mSupportA2DP = true;
        int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        if ( !isPlaying() && state ==  BluetoothProfile.STATE_CONNECTED  )
            play();
        if ( (state ==  BluetoothProfile.STATE_DISCONNECTING || state ==  BluetoothProfile.STATE_DISCONNECTED) ) {
            pause();
        }
    } else if ( action.equals(BluetoothDevice.ACTION_ACL_CONNECTED) ) {
        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        final int deviceClass = device.getBluetoothClass().getDeviceClass();             
        if (deviceClass == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE ||
            deviceClass == BluetoothClass.Device.AUDIO_VIDEO_HEADPHONES ||
            deviceClass == BluetoothClass.Device.AUDIO_VIDEO_HIFI_AUDIO ||
            deviceClass == BluetoothClass.Device.AUDIO_VIDEO_LOUDSPEAKER ||
            deviceClass == BluetoothClass.Device.AUDIO_VIDEO_PORTABLE_AUDIO ||
            deviceClass == BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET) {
                new Handler().postDelayed( postPlayRunnable, 7700);
        }
    }

} };


/******************************************************************************/
Android 藍牙啟動過程    from: http://biancheng.dnbcw.info/linux/413347.html
/******************************************************************************/
藍牙設置種常用的Intent，下面是在bluetoothsettings.java 中註冊藍牙Intent的函數：
private boolean initBluetoothAPI() {
 mIntentFilter =
//  跟遠端藍牙設備連接上時返回來的intent
new IntentFilter(BluetoothIntent.REMOTE_DEVICE_CONNECTED_ACTION);
//  跟遠端藍牙設備斷開時返回來的intent 
mIntentFilter.addAction(BluetoothIntent.REMOTE_DEVICE_DISCONNECTED_ACTION);
//  跟遠端的藍牙設備配對上時收到的intent，不過前提是對方主動發起的配對才能收到這個intent
mIntentFilter.addAction(BluetoothIntent.BONDING_CREATED_ACTION);
//  本地藍牙設備可用時收到的Intent
mIntentFilter.addAction(BluetoothIntent.ENABLED_ACTION);
//  本地藍牙設備不可用時收到的Intent
mIntentFilter.addAction(BluetoothIntent.DISABLED_ACTION);
//  掃瞄到遠端設備時收到的intent   
mIntentFilter.addAction(BluetoothIntent.REMOTE_DEVICE_FOUND_ACTION);
//   遠端藍牙設備消失時收到的intent        
mIntentFilter.addAction(BluetoothIntent.REMOTE_DEVICE_DISAPPEARED_ACTION);
 //   遠端藍牙設備名稱更換時收到的intent，因為剛發現設備的時候還沒有獲取它的名稱
mIntentFilter.addAction(BluetoothIntent.REMOTE_NAME_UPDATED_ACTION);
//  當有遠端設備發起配對請求時收到的intent
mIntentFilter.addAction(BluetoothIntent.PAIRING_REQUEST_ACTION);
//  藍牙耳機狀態改變時候到的intent
mIntentFilter.addAction(BluetoothIntent.HEADSET_STATE_CHANGED_ACTION);
// 掃瞄設備結束
mIntentFilter.addAction(BluetoothIntent.DISCOVERY_COMPLETED_ACTION);
//  掃瞄開始
mIntentFilter.addAction(BluetoothIntent.DISCOVERY_STARTED_ACTION);
//  藍牙設備模式改變，表示本地藍牙設備是否可以被查找
mIntentFilter.addAction(BluetoothIntent.MODE_CHANGED_ACTION);
//   有耳機插入
mIntentFilter.addAction(Intent.ACTION_HEADSET_PLUG);
 
啟動藍牙
在啟動藍牙的時候，要注意的地方是不能正常啟動藍牙的情況，因為正常啟動的時候會返回BluetoothIntent.ENABLED_ACTION 這個Intent，當時當啟動出現異常的時候是沒有
Intent返回的，android使用回調函數來解決這個問題。下面是在bluetoothdeviceservice.java 裡面enable（(IBluetoothDeviceCallback callback） 的過程：
public synchronized boolean enable(IBluetoothDeviceCallback callback) {
        checkPermissionBluetoothAdmin();
        Log.d(TAG,"start enable! ");
        // Airplane mode can prevent Bluetooth radio from being turned on.
        if (mIsAirplaneSensitive && isAirplaneModeOn()) {
            return false;
        }
        if (mIsEnabled) {
            return false;
        }
        if (mEnableThread != null && mEnableThread.isAlive()) {
            return false;
        }
   //   主要的啟動過程是放在一個新起的線程裡面，但是不管能不能啟動
   //    仍然返回了true
        mEnableThread = new EnableThread(callback);
        mEnableThread.start();
      //  
        return true;
 
        }
  
    private EnableThread mEnableThread;
    private class EnableThread extends Thread {
        private final IBluetoothDeviceCallback mEnableCallback;
        public EnableThread(IBluetoothDeviceCallback callback) {
            mEnableCallback = callback;
        }
        public void run() {
            boolean res = enableNative();
            if (res) {
                mEventLoop.start();
            }
 
            if (mEnableCallback != null) {
                try {
                
                    // 通過回調函數來表明是否正常啟動藍牙設備
                    mEnableCallback.onEnableResult(res ?
                                                   BluetoothDevice.RESULT_SUCCESS :
                                                   BluetoothDevice.RESULT_FAILURE);
                } catch (RemoteException e) {}
            }
 
            if (res) {
                mIsEnabled = true;
                mIsDiscovering = false;
 
                Intent intent = new Intent(BluetoothIntent.ENABLED_ACTION);
                mContext.sendBroadcast(intent);
                }
            }else{
                mIsEnabled = false;
                mIsDiscovering = false;
            }
            mEnableThread = null;
        }
}
  
//  這個回調函數將被作為參數傳進bluetoothservice 裡面的enable（IBluetoothDeviceCallback callback）
static class DeviceCallback extends IBluetoothDeviceCallback.Stub {
        Handler messageHandler;
        public void setHandler(Handler handler) {
            synchronized (this) {
                messageHandler = handler;
            }
  
        public void onEnableResult(int result) {
            switch(result) {
  //  啟動不成功的時候執行
                  case BluetoothDevice.RESULT_FAILURE:
                      messageHandler.sendMessage(messageHandler.obtainMessage(EVENT_FAILED_BT_ENABLE,0));
                      break;
            }
        }
      
//   配對完成時執行
public void onCreateBondingResult(String address, int result) {
            synchronized (this) {
                if (messageHandler != null) {
                    if (result == BluetoothDevice.RESULT_FAILURE) {
                        messageHandler.sendMessage(messageHandler.obtainMessage(
                                HANDLE_PAIRING_FAILED, address));
                    } else {
                        messageHandler.sendMessage(messageHandler.obtainMessage(
                                HANDLE_PAIRING_PASSED, address));
                    }
                }
            }
        } 
    };
關閉過程
    public synchronized boolean disable() {
        checkPermissionBluetoothAdmin();
         if (mEnableThread != null && mEnableThread.isAlive()) {
            return false;
        }
        if (!mIsEnabled) {
            return true;
        }
        if(!disableNative()){
            Log.d(TAG,"disableNative false ");
          return false;
        }
        mEventLoop.stop();
        mIsEnabled = false;
        mIsDiscovering = false;
        Intent intent = new Intent(BluetoothIntent.DISABLED_ACTION);
        mContext.sendBroadcast(intent);
        return true;
    }

配對過程
    private void doPair(Preference pref, String address) {
        pref.setEnabled(false);
        pref.setSummary(STR_PAIRING);
        if (mPinEdit != null){
              String strPIN = mPinEdit.getText().toString();
             
              mBluetooth.writePinCode(address, strPIN);
              mBluetooth.createBonding(address, sDeviceCallback);
        }        
    }

android啟動藍牙的過程  
=========================Kernel Space=========================
1. Board power init
MACHINE_START 
init_machine = comet_init
bt_power_init
bluetooth_power
2. HCI device/connection manager, socket init
bt_init()
bt_sysfs_init
sock_register
hci_sock_init
3. HCI UART init( UART LINE DISCIPLINE)
hci_uart_init(open/close/read/write/ioctl,poll...)
h4_init
hci_uart_register_proto
4. Bluetooth Sleep Module,/proc/bluetooth
bluesleep_init()
platform_driver_register(&bluesleep_driver)
5. BT Power switch, RF kill
bluetooth_power_init()
bt_power_probe
6. L2CAP init
l2cap_init()
proto_register(&l2cap_proto, 0)
bt_sock_register(BTPROTO_L2CAP , &l2cap_sock_family_ops)
hci_register_proto(&l2cap_hci_proto)
class_create_file(bt_class, &class_attr_l2cap)
7. SCO init
sco_init()
proto_register(&sco_proto, 0)
bt_sock_register(BTPROTO_SCO , &sco_sock_family_ops)
hci_register_proto(&sco_hci_proto)
class_create_file(bt_class, &class_attr_sco)
8. RFCOMM Init
rfcomm_init()
hci_register_cb(&rfcomm_cb)
kthread_run(rfcomm_run, NULL, "krfcommd")
class_create_file(bt_class, &class_attr_rfcomm_dlc)
rfcomm_init_sockets
rfcomm_init_ttys()
9. BNEP Init
bnep_init()
bnep_sock_init()
10. thread running
rfcomm_run
rfcomm_l2sock_create
l2cap_sock_create: sock 
l2cap_sock_init: sk 
l2cap_sock_bind: sk 
l2cap_sock_listen: sk 
rfcomm_session_add: session
=========================命令行方式啟動BT============================== 
1.echo 1 > /sys/class/rfkill/rfkill0/state
*Bluetooth power switch: 1[bluetooth_power(), board_qsc8x50.c]
2. hci_qcomm_init -vvv -e
*hci_qcomm_init-d /dev/ttyHS0 -s 3200000 -i 115200 -r 19200000 (open HSUART COM port and initializeBTS402x )
3. hciattach /dev/ttyHS0 qualcomm 3000000 (HCI LINE DISCIPLINE)
hciattach/dev/ttyHS0 any 200 flow (attach serial device via UART HCI to BlueZstack )
=============user space===================
main()
init_uart()
ioctl(fd, HCIUARTSETPROTO, u->proto) 
==============kernel space=================
hci_uart_tty_ioctl()
hci_uart_set_proto()
open()[h4_open()]
hci_uart_register_dev()
hci_register_dev()
hci_register_sysfs()
4. hciconfig hci0 up(open and initialize HCI device) [hdev->name == hci0]
==========user space====================
ctl=socket(AF_BLUETOOTH , SOCK_RAW , BTPROTO_HCI ))
ioctl(ctl, HCIGETDEVINFO, (void *) &di)
hci_open_dev(di.dev_id)->bind(dd, (struct sockaddr *) &a, sizeof(a))
cmd_up
ioctl(ctl, HCIDEVUP, hdev)
==========kernel space================
hci_sock_ioctl
hci_dev_open
hci_dev_get
hdev->open [ hci_uart_open(hci_ldisc) ]
_hci_request(hdev, hci_init_req, 0,msecs_to_jiffies(HCI_INIT_TIMEOUT ))
hci_init_req
hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES , 0, NULL);
......................
===========CMD Flow============================
hci_cmd_task: hci0 cmd 1
hci_send_frame: hci0 type 1 len 3
hci_sock_dev_event: hdev hci0 event 7
hci_send_to_sock: hdev (null) len 8
hci_uart_send_frame: hci0: type 1 len 3
h4_enqueue: hu c658f6c0 skb c662d340
hci_uart_tx_wakeup:
hci_uart_tty_wakeup:
hci_uart_tx_wakeup:
===========Event Flow===========================
h4_recv: hu c658f6c0 count 15 rx_state 0 rx_count 0
h4_recv: Event packet
h4_recv: Event header: evt 0x0e plen 12
h4_check_data_len: len 12 room 1046
h4_recv: Complete data
hci_rx_task: hci0
hci_cc_read_local_features: hci0 status 0x0
hci_cc_read_local_features: hci0 features 0xfffe8ffe9bff598
========================================BT TOOLS=======================================
hciattatch
hciconfig
hciconfig - HCI device configuration utility
Usage:
hciconfig
hciconfig [-a] hciX [command]
Commands:
up Open and initialize HCI device
down Close HCI device
reset Reset HCI device
rstat Reset statistic counters
auth Enable Authentication
noauth Disable Authentication
encrypt Enable Encryption
noencrypt Disable Encryption
piscan Enable Page and Inquiry scan
noscan Disable scan
iscan Enable Inquiry scan
pscan Enable Page scan
ptype [type] Get/Set default packet type
lm [mode] Get/Set default link mode
lp [policy] Get/Set default link policy
name [name] Get/Set local name
class [class] Get/Set class of device
voice [voice] Get/Set voice setting
iac [iac] Get/Set inquiry access code
inqtpl [level] Get/Set inquiry transmit power level
inqmode [mode] Get/Set inquiry mode
inqdata [data] Get/Set inquiry data
inqtype [type] Get/Set inquiry scan type
inqparms [win:int] Get/Set inquiry scan window and interval
pageparms [win:int] Get/Set page scan window and interval
pageto [to] Get/Set page timeout
afhmode [mode] Get/Set AFH mode
sspmode [mode] Get/Set Simple Pairing Mode
aclmtu Set ACL MTU and number of packets
scomtu Set SCO MTU and number of packets
putkey Store link key on the device
delkey Delete link key from the device
oobdata Display local OOB data
commands Display supported commands
features Display device features
version Display version information
revision Display revision information
bttest
hcitool cmd
hcitool scan
hcidump
hcidump -B -w /data/test.cfa [Log HCI packets as FTS btsnoopformat]
hcidump -XVt [Print HCI packets that can be readable with timestamps and payloads]
sdptool
sdptool add -channel=10 HFAG (add HFAG service records to be supported)
sdptool del [record_handle] (remove service from local SDP)
sdptool browse local [Browse all local service records]
l2ping [Run L2CAPping-to-peer device]
========================================android 腳本執行過程===============================
2. init.rc
3. init.qcom.rc
4. init.qcom.bt.sh


/******************************************************************************/
Android: AlarmManager 鬧鐘用法
/******************************************************************************/
Alarm Manager元件用來排程，當時間到時系統會廣播註冊指定的Intent啟動目標程式，就算目標程式並未在執行中也一樣。若是裝置在睡眠中，則依參數而定，註冊的鬧鐘會保留或喚醒裝置。當系統關閉並rebooted時，會清除鬧鐘的設定。當廣播接受端執行onReceive() 時，Alarm Manager會保持CPU清醒直到處理結束。裝置有可能一旦執行完onReceive()時，立刻進入昏睡(睡眠不足:)，所以不要在onReceive()中呼叫非同步動作的函數。若一定要作時，請自行處理wake lock policy(鎖定清醒)。
ELAPSED_REALTIME 使用 elapsedRealtime() 計時；從系統啟動後至目前的時間(包含睡覺時間)
ELAPSED_REALTIME_WAKEUP 同上，並喚醒裝置
RTC 使用 currentTimeMillis() 牆壁時鐘UTC格式
RTC_WAKEUP  同上，並喚醒裝置

Intent intent=new Intent (getBaseContext(),CallAlarm.class);
PendingIntent sender=PendingIntent.getBroadcast(getBaseContext(),0,intent,0);
AlarmManager am ;
am = (AlarmManager)getSystemService(ALARM_SERVICE);
long cl = SystemClock.elapsedRealtime();
//連續式
am.setRepeating(AlarmManager.ELAPSED_REALTIME, cl, 5*1000, sender) ;
//單次 am.set(AlarmManager.ELAPSED_REALTIME, cl + 5*1000, sender);
public class CallAlarm extends BroadcastReceiver{
 @Override public void onReceive(Context arg0, Intent arg1) {
  int n =arg1.getIntExtra(Intent.EXTRA_ALARM_COUNT,0);
 Toast.makeText(arg0,"ALARM RECEIVE="+n,Toast.LENGTH_SHORT).show();
 }
}

接收器程式記得在AndroidManifest.xml中註冊，
<receiver android:name=".CallAlarm" android:process=":remote" />


/******************************************************************************/
藍牙通訊開發記錄        from: http://fecbob.pixnet.net/blog/post/38317669
/******************************************************************************/
Bluetooth
The Android platform includes support for the Bluetooth network stack, which allows a device to wirelessly exchange data with other Bluetooth devices. The application framework provides access to the Bluetooth functionality through the Android Bluetooth APIs. These APIs let applications wirelessly connect to other Bluetooth devices, enabling point-to-point and multipoint wireless features.
Android平臺包含技持藍牙網路，它允許一個設備與另一個設備進無線資料傳輸。這個程式框架提供了API訪問藍牙的函數。讓這些程式無線去連接藍牙設備，應用與點對點和多個點無線特徵.
Using the Bluetooth APIs, an Android application can perform the following:

.Scan for other Bluetooth devices 掃瞄其它藍牙設備
.Query the local Bluetooth adapter for paired Bluetooth devices 查詢本地的藍牙配接器去配對設備
.Establish RFCOMM channels 建立RFCOMM通道

.Connect to other devices through service discovery 通過服務發現連接到其它設備
.Transfer data to and from other devices 傳輸資料
.Manage multiple connections 管理多個連接

The Basics
This document describes how to use the Android Bluetooth APIs to accomplish the four major tasks necessary to communicate using Bluetooth: setting up Bluetooth, finding devices that are either paired or available in the local area, connecting devices, and transferring data between devices.
這個文檔用於描述如何去使用Android 藍牙API去完成自四個主要的任務。1、設置藍牙 2、發現本地可用設備或已配對設備 3、連接設備 4、傳輸資料

BluetoothAdapter
Represents the local Bluetooth adapter (Bluetooth radio). The BluetoothAdapter is the entry-point for all Bluetooth interaction. Using this, you can discover other Bluetooth devices, query a list of bonded (paired) devices, instantiate a BluetoothDevice using a known MAC address, and create a BluetoothServerSocket to listen for communications from other devices.
這個類主要是代表本機的藍牙配接器。藍牙配接器是所有藍牙設備資料交換的入口。使用這個類你可以發現其它藍牙設備，查詢已配對設備清單，已知MAC（硬體位址）具現化一個設備物件，創建一個BluetoothServerSocket 物件去監聽來自其它藍牙設備的連接。

BluetoothDevice
Represents a remote Bluetooth device. Use this to request a connection with a remote device through a BluetoothSocket or query information about the device such as its name, address, class, and bonding state.
代表一個遠端藍牙設備。用這個類通過一個 BlueSocket(相當於TCP/IP裡面的Socket) 可去請求一個與遠端設備的連接，或者可以查詢以下資訊：設備名稱、硬體位址、類及連接狀態。

BluetoothSocket
Represents the interface for a Bluetooth socket (similar to a TCP Socket). This is the connection point that allows an application to exchange data with another Bluetooth device via InputStream and OutputStream.
代表BluetoothSocket的介面（類似於TCPSocket）.這是一個連接點，它允許程式通過輸入輸出流進行資料交換

BluetoothServerSocket
Represents an open server socket that listens for incoming requests (similar to a TCP ServerSocket). In order to connect two Android devices, one device must open a server socket with this class. When a remote Bluetooth device makes a connection request to the this device, the BluetoothServerSocket will return a connected BluetoothSocket when the connection is accepted.
代表一個開放的服務Socket去監聽進來的請求（類似於一個TCP ServerSocket）.為了連接兩個Android設備，一個設備必須打開一個ServerSocket的服務。當一個遠端的藍牙設備發一個連接請求與這個打開ServerSocket設備，如果接受請求將返回 BluetoothServerSocket 將返回一個 BluetoothSocke t的實例。

BluetoothClass
Describes the general characteristics and capabilities of a Bluetooth device. This is a read-only set of properties that define the device's major and minor device classes and its services. However, this does not reliably describe all Bluetooth profiles and services supported by the device, but is useful as a hint to the device type.
描述一個通用的藍牙設備。這是一個定義了設備主要功能、次要功能和它的服務的唯讀屬性集合。但是這並不影響描述藍牙的概況和服務。

BluetoothProfile
An interface that represents a Bluetooth profile. A Bluetooth profile is a wireless interface specification for Bluetooth-based communication between devices. An example is the Hands-Free profile. For more discussion of profiles, see Working with Profiles
一個介面：它代表了一個藍牙的簡介。一個藍牙簡介是一個基於兩個藍牙設備通信的無線介面說明。

BluetoothHeadset
Provides support for Bluetooth headsets to be used with mobile phones. This includes both Bluetooth Headset and Hands-Free (v1.5) profiles.
提供一個藍牙耳機的支援。

BluetoothA2dp
Defines how high quality audio can be streamed from one device to another over a Bluetooth connection. "A2DP" stands for Advanced Audio Distribution Profile.

BluetoothProfile.ServiceListener
An interface that notifies BluetoothProfile IPC clients when they have been connected to or disconnected from the service (that is, the internal service that runs a particular profile).
in order to use Bluetooth features in your application, you need to declare at least one of two Bluetooth permissions: BLUETOOTH and BLUETOOTH_ADMIN .
為了在你的程式裡能使用藍牙特性，你需要聲明至少一個或兩個藍牙Permissions-------------->BLUETHOOTH and BLUETOOTH_ADMIN

You must request the BLUETOOTH_ADMIN permission in order to initiate device discovery or manipulate Bluetooth settings. 為了具現化一個device 搜索 或者操控藍牙設置，就得有BLUETHOOTH_ADMIN 這個 Permission.
You must request the BLUETOOTH permission in order to perform any Bluetooth communication, such as requesting a connection, accepting a connection, and transferring data. 為了執行藍牙通信比如：請求一個連接、接受一個連接及傳輸資料，就得有 BLUETOOTH 這個 Permission.
例如 ：
<manifest ... > <uses-permission android:name="android.permission.BLUETOOTH" /> ...</manifest>

Setting Up Bluetooth
If Bluetooth is not supported, then you should gracefully disable any Bluetooth features. If Bluetooth is supported, but disabled, then you can request that the user enable Bluetooth without leaving your application. This setup is accomplished in two steps, using the BluetoothAdapter.
如果你的機器不支援藍牙，這個時候就不用再考慮藍牙這個問題了。如果你的機器支援藍牙但是不能用，這個時候你可請求使用藍牙。你無需離開程式，通過使用BluetoothAdapter這個類兩步就搞定了。
1、Get the BluetoothAdapter 獲得藍牙配接器
The BluetoothAdapter is required for any and all Bluetooth activity. To get the BluetoothAdapter, call the static getDefaultAdapter() method. This returns a BluetoothAdapter that represents the device's own Bluetooth adapter (the Bluetooth radio). There's one Bluetooth adapter for the entire system, and your application can interact with it using this object. If getDefaultAdapter() returns null, then the device does not support Bluetooth and your story ends here.
對於任務Bluetooth activity都是必須的。通過靜態方法 getDefaultAdapter() 方法就可以得到一個你自己設備的藍牙配接器。整個系統有一個藍牙配接器就可以用這個物件進行溝通。
For example:
// Get local Bluetooth adapter 得到本機的藍牙配接器
mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
// If the adapter is null, then Bluetooth is not supported 如果為空，就是不支援藍牙設備
if (mBluetoothAdapter == null) {
Toast.makeText(this, "Bluetooth is not available", Toast.LENGTH_LONG).show();
finish();
return;
}

2、Enable Bluetooth 使用藍牙
Next, you need to ensure that Bluetooth is enabled. Call isEnabled() to check whether Bluetooth is currently enable. If this method returns false, then Bluetooth is disabled. To request that Bluetooth be enabled, call startActivityForResult() with the ACTION_REQUEST_ENABLE action Intent. This will issue a request to enable Bluetooth through the system settings (without stopping your application).
接下來，你需要確定藍牙是可以用的。使用isEnabled() 方法去檢查當前藍牙設備是否可用，如果這個方法返回 false 藍牙不可用。去請求開啟藍牙設備。To request that Bluetooth be enabled.通過系統發出一個請求去開啟藍牙（不用停止你的的應用程式）
for example:
//開始顯示在屏目上，可以onStop()重新回到onStart() 可以參看Activity的生命週期
@Override
protected void onStart() {
super.onStart();
if(D) Log.e(TAG, "++ 開始藍牙設備 (ON START) ++");
if(!mBluetoothAdapter.isEnabled()){
Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
startActivityForResult(enableIntent,REQUEST_ENABLE_BT);
}else {
if(mChatService == null) setupChat();
}
}


/******************************************************************************/
ndroid藍牙主動發起配對實例              from: http://wiley.iteye.com/blog/1179417
/******************************************************************************/
androidbluetoothbound 
Java代碼
 
package cn.madfinger.core;  
  
import java.io.IOException;  
import java.lang.reflect.Method;  
import java.util.ArrayList;  
import java.util.List;  
import java.util.UUID;  
  
import android.app.Activity;  
import android.bluetooth.BluetoothAdapter;  
import android.bluetooth.BluetoothDevice;  
import android.bluetooth.BluetoothSocket;  
import android.content.BroadcastReceiver;  
import android.content.Context;  
import android.content.Intent;  
import android.content.IntentFilter;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.View;  
import android.widget.AdapterView;  
import android.widget.ArrayAdapter;  
import android.widget.Button;  
import android.widget.ListView;  
import android.widget.Toast;  
import android.widget.ToggleButton;  
  
public class BlueToothTestActivity extends Activity {  
    //該UUID表示串口服務  
    //請參考文章<a href="http://wiley.iteye.com/blog/1179417">http://wiley.iteye.com/blog/1179417</a>  
    static final String SPP_UUID = "00001101-0000-1000-8000-00805F9B34FB";  
    Button btnSearch, btnDis, btnExit;  
    ToggleButton tbtnSwitch;  
    ListView lvBTDevices;  
    ArrayAdapter<String> adtDevices;  
    List<String> lstDevices = new ArrayList<String>();  
    BluetoothAdapter btAdapt;  
    public static BluetoothSocket btSocket;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        // Button 設置  
        btnSearch = (Button) this.findViewById(R.id.btnSearch);  
        btnSearch.setOnClickListener(new ClickEvent());  
        btnExit = (Button) this.findViewById(R.id.btnExit);  
        btnExit.setOnClickListener(new ClickEvent());  
        btnDis = (Button) this.findViewById(R.id.btnDis);  
        btnDis.setOnClickListener(new ClickEvent());  
  
        // ToogleButton設置  
        tbtnSwitch = (ToggleButton) this.findViewById(R.id.tbtnSwitch);  
        tbtnSwitch.setOnClickListener(new ClickEvent());  
  
        // ListView及其數據源 適配器  
        lvBTDevices = (ListView) this.findViewById(R.id.lvDevices);  
        adtDevices = new ArrayAdapter<String>(this,  
                android.R.layout.simple_list_item_1, lstDevices);  
        lvBTDevices.setAdapter(adtDevices);  
        lvBTDevices.setOnItemClickListener(new ItemClickEvent());  
  
        btAdapt = BluetoothAdapter.getDefaultAdapter();// 初始化本機藍牙功能  
  
        // ========================================================  
        // modified by wiley  
        /* 
         * if (btAdapt.getState() == BluetoothAdapter.STATE_OFF)// 讀取藍牙狀態並顯示 
         * tbtnSwitch.setChecked(false); else if (btAdapt.getState() == 
         * BluetoothAdapter.STATE_ON) tbtnSwitch.setChecked(true); 
         */  
        if (btAdapt.isEnabled()) {  
            tbtnSwitch.setChecked(false);  
        } else {  
            tbtnSwitch.setChecked(true);  
        }  
        // ============================================================  
        // 註冊Receiver來獲取藍牙設備相關的結果  
        IntentFilter intent = new IntentFilter();  
        intent.addAction(BluetoothDevice.ACTION_FOUND);// 用BroadcastReceiver來取得搜索結果  
        intent.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  
        intent.addAction(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);  
        intent.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);  
        registerReceiver(searchDevices, intent);  
    }  
  
    private BroadcastReceiver searchDevices = new BroadcastReceiver() {  
  
        public void onReceive(Context context, Intent intent) {  
            String action = intent.getAction();  
            Bundle b = intent.getExtras();  
            Object[] lstName = b.keySet().toArray();  
  
            // 顯示所有收到的消息及其細節  
            for (int i = 0; i < lstName.length; i++) {  
                String keyName = lstName[i].toString();  
                Log.e(keyName, String.valueOf(b.get(keyName)));  
            }  
            BluetoothDevice device = null;  
            // 搜索設備時，取得設備的MAC地址  
            if (BluetoothDevice.ACTION_FOUND.equals(action)) {  
                device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  
                if (device.getBondState() == BluetoothDevice.BOND_NONE) {  
                    String str = "未配對|" + device.getName() + "|"  
                            + device.getAddress();  
                    if (lstDevices.indexOf(str) == -1)// 防止重複添加  
                        lstDevices.add(str); // 獲取設備名稱和mac地址  
                    adtDevices.notifyDataSetChanged();  
                }  
            }else if(BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)){  
                device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  
                switch (device.getBondState()) {  
                case BluetoothDevice.BOND_BONDING:  
                    Log.d("BlueToothTestActivity", "正在配對......");  
                    break;  
                case BluetoothDevice.BOND_BONDED:  
                    Log.d("BlueToothTestActivity", "完成配對");  
                    connect(device);//連接設備  
                    break;  
                case BluetoothDevice.BOND_NONE:  
                    Log.d("BlueToothTestActivity", "取消配對");  
                default:  
                    break;  
                }  
            }  
              
        }  
    };  
  
    @Override  
    protected void onDestroy() {  
        this.unregisterReceiver(searchDevices);  
        super.onDestroy();  
        android.os.Process.killProcess(android.os.Process.myPid());  
    }  
  
    class ItemClickEvent implements AdapterView.OnItemClickListener {  
  
        @Override  
        public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,  
                long arg3) {  
            if(btAdapt.isDiscovering())btAdapt.cancelDiscovery();  
            String str = lstDevices.get(arg2);  
            String[] values = str.split("\\|");  
            String address = values[2];  
            Log.e("address", values[2]);  
            BluetoothDevice btDev = btAdapt.getRemoteDevice(address);  
            try {  
                Boolean returnValue = false;  
                if (btDev.getBondState() == BluetoothDevice.BOND_NONE) {  
                    //利用反射方法調用BluetoothDevice.createBond(BluetoothDevice remoteDevice);  
                    Method createBondMethod = BluetoothDevice.class  
                            .getMethod("createBond");  
                    Log.d("BlueToothTestActivity", "開始配對");  
                    returnValue = (Boolean) createBondMethod.invoke(btDev);  
                      
                }else if(btDev.getBondState() == BluetoothDevice.BOND_BONDED){  
                    connect(btDev);  
                }  
            } catch (Exception e) {  
                e.printStackTrace();  
            }  
  
        }  
  
    }  
      
    private void connect(BluetoothDevice btDev) {  
        UUID uuid = UUID.fromString(SPP_UUID);  
        try {  
            btSocket = btDev.createRfcommSocketToServiceRecord(uuid);  
            Log.d("BlueToothTestActivity", "開始連接...");  
            btSocket.connect();  
        } catch (IOException e) {  
            // TODO Auto-generated catch block  
            e.printStackTrace();  
        }  
    }  
  
    class ClickEvent implements View.OnClickListener {  
        @Override  
        public void onClick(View v) {  
            if (v == btnSearch)// 搜索藍牙設備，在BroadcastReceiver顯示結果  
            {  
                if (btAdapt.getState() == BluetoothAdapter.STATE_OFF) {// 如果藍牙還沒開啟  
                    Toast.makeText(BlueToothTestActivity.this, "請先打開藍牙", 1000)  
                            .show();  
                    return;  
                }  
                if (btAdapt.isDiscovering())  
                    btAdapt.cancelDiscovery();  
                lstDevices.clear();  
                Object[] lstDevice = btAdapt.getBondedDevices().toArray();  
                for (int i = 0; i < lstDevice.length; i++) {  
                    BluetoothDevice device = (BluetoothDevice) lstDevice[i];  
                    String str = "已配對|" + device.getName() + "|"  
                            + device.getAddress();  
                    lstDevices.add(str); // 獲取設備名稱和mac地址  
                    adtDevices.notifyDataSetChanged();  
                }  
                setTitle("本機藍牙地址：" + btAdapt.getAddress());  
                btAdapt.startDiscovery();  
            } else if (v == tbtnSwitch) {// 本機藍牙啟動/關閉  
                if (tbtnSwitch.isChecked() == false)  
                    btAdapt.enable();  
  
                else if (tbtnSwitch.isChecked() == true)  
                    btAdapt.disable();  
            } else if (v == btnDis)// 本機可以被搜索  
            {  
                Intent discoverableIntent = new Intent(  
                        BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);  
                discoverableIntent.putExtra(  
                        BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);  
                startActivity(discoverableIntent);  
            } else if (v == btnExit) {  
                try {  
                    if (btSocket != null)  
                        btSocket.close();  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
                BlueToothTestActivity.this.finish();  
            }  
        }  
  
    }  
}  


/******************************************************************************/
Android 中文API （70） —— BluetoothDevice[藍牙]       ref: http://www.cnblogs.com/over140/archive/2010/12/21/1912482.html
/******************************************************************************/
前言
　　本章內容是 android.bluetooth.BluetoothDevice，為Android藍牙部分的章節翻譯。藍牙設備類，代表了藍牙通訊國足中的遠端設備。版本為 Android 2.3 r1，翻譯來自中山大學的"Android Club SYSU"，歡迎訪問他們的WIKI：http://www.android-wiki.net，再次感謝"Android Club SYSU"！期待你一起參與Android中文API的翻譯，聯繫我 over140@gmail.com。
聲明
　　歡迎轉載，但請保留文章原始出處:)
　　　　Android Club SYSU：http://www.android-wiki.net
　　　　博客園：http://www.cnblogs.com/
　　　　Android中文翻譯組：http://code.taobao.org/project/view/404/

正文
一、結構
public static class BluetoothDevice extends Object implements Parcelable
java.lang.Object
android.bluetooth.BluetoothDevice
二、概述
　　代表一個遠端藍牙設備。讓你創建一個帶有各自設備的BluetoothDevice或者查詢其皆如名稱、地址、類和連接狀態等資訊。
　　對於藍牙硬體地址而言，這個類僅僅是一個瘦包裝器。這個類的對象是不可改變的。這個類上的操作會使用這個用來創建BluetoothDevice類的BluetoothAdapter類執行在遠端藍牙硬體上。
　　為了獲得BluetoothDevice,類，使用BluetoothAdapter.getRemoteDevice(String)方法去創建一個表示 已知MAC地址的設備（用戶可以通過帶有BluetoothAdapter類來完成對設備的查找）或者從一個通過 BluetoothAdapter.getBondedDevices()得到返回值的有聯繫的設備集合來得到該設備。
　　注意：需要BLUETOOTH權限
　　參見
　　　　　　BluetoothAdapter
　　　　　　BluetoothSocket
三、常量
String ACTION_ACL_CONNECTED  
廣播活動：指明一個與遠端設備建立的低級別（ACL）連接。
總是包含EXTRA_DEVICE附加域
ACL連接通過Android藍牙棧自動進行管理
需要BLUETOOTH權限接收
     常量值: "android.bluetooth.device.action.ACL_CONNECTED"

String ACTION_ACL_DISCONNECTED     
廣播活動：指明一個來自於遠端設備的低級別（ACL）連接的斷開
總是包含EXTRA_DEVICE附加域
ACL連接通過Android藍牙棧自動進行管理
需要BLUETOOTH權限接收
常量值: "android.bluetooth.device.action.ACL_DISCONNECTED"

String ACTION_ACL_DISCONNECT_REQUESTED    
廣播活動：指明一個為遠端設備提出的低級別（ACL）的斷開連接請求，並即將斷開連接。
對於友好的斷開連接，該常量是有作用的。應用程式可以用它作為暗示去馬上中斷對遠端設備的高級別的連接（RFCOMM,L2CAP,或者其它連接）。
總是包含EXTRA_DEVICE附加域
需要BLUETOOTH權限接收
常量值: "android.bluetooth.device.action.ACL_DISCONNECT_REQUESTED"

String ACTION_BOND_STATE_CHANGED        
廣播活動：指明一個遠端設備的連接狀態的改變。比如，當一個設備已經被匹配。
總是包含EXTRA_DEVICE, EXTRA_BOND_STATE和 EXTRA_PREVIOUS_BOND_STATE.這些附加域。
需要BLUETOOTH權限接收
常量值: "android.bluetooth.device.action.BOND_STATE_CHANGED"

String ACTION_CLASS_CHANGED   
廣播活動：一個已經改變的遠端設備的藍牙類。
總是包含EXTRA_DEVICE和EXTRA_BOND_STATE這些附加域。
需要BLUETOOTH權限接收
 參見
     ERROR(BluetoothClass} /{@link BluetoothClass})
 常量值: "android.bluetooth.device.action.CLASS_CHANGED"

String ACTION_FOUND    
廣播活動：發現遠端設備
當一個遠端設備在查找過程中被發現時，發送該常量值。
總是包含EXTRA_DEVICE和EXTRA_CLASS這些附加域。如果可用的話，也可包含EXTRA_NAME和/或EXTRA_RSSI這些附加域。
需要BLUETOOTH權限接收
常量值: "android.bluetooth.device.action.FOUND"

String ACTION_NAME_CHANGED  
廣播活動：指明一個遠端設備的暱稱第一次找到，或者自從最後一次找到該暱稱開始已經改變。
總是包含EXTRA_DEVICE和EXTRA_NAME這些附加域
需要BLUETOOTH權限接收
常量值: "android.bluetooth.device.action.NAME_CHANGED"
 
int        BOND_BONDED    
指明遠端設備已經匹配。
一個共享的連接鍵為了遠端設備而存在於本地，因而設備間的通訊可以被認證和加密。
和遠端設備的匹配並不意味著設備間已經成功連接。它只意味著匹配過程已經在稍早之前完成，並且連接鍵已經存儲在本地，準備在下次連接的時候使用。
常量值: 12 (0x0000000c)
 
int        BOND_BONDING  
指明和遠端設備的匹配正在進行中
常量值: 11 (0x0000000b)
 
int        BOND_NONE          
指明遠端設備未被匹配。
不存在為了遠端設備而已經共享的連接鍵，因而設備間的通訊（如果完全被允許）不可被認證和加密。
     常量值: 10 (0x0000000a)
 
Creator<BluetoothDevice>         CREATOR        
 
int        ERROR   
該 類的錯誤標誌值. 標記該類的錯誤值。確保和該類中的任意其它整數常量不相等。它為需要一個標記錯誤值的函數提供了便利。例如： Intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)
常量值: -2147483648 (0x80000000)
 
String EXTRA_BOND_STATE     
作為一個ACTION_BOND_STATE_CHANGED的整型附加域。包含了遠端設備的匹配狀態。
可能值有: BOND_NONE, BOND_BONDING, BOND_BONDED.
常量值: "android.bluetooth.device.extra.BOND_STATE"
 
String EXTRA_CLASS         
作為一個ACTION_FOUND和ACTION_CLASS_CHANGED的Parcelabe BluetoothClass附加域。
常量值: "android.bluetooth.device.extra.CLASS"
 
String EXTRA_DEVICE      
每次通過該類進行廣播時，作為Parcelable BluetoothDevice的附加域。它包含了該常量適用的BluetoothDevice類。
常量值: "android.bluetooth.device.extra.DEVICE"
 
String EXTRA_NAME        
作為ACTION_NAME_CHANGED和ACTION_FOUND的字串附加域。它包含了這個藍牙暱稱。
常量值: "android.bluetooth.device.extra.NAME"
 
String EXTRA_PREVIOUS_BOND_STATE  
作為ACTION_BOND_STATE_CHANGED的整型附加域。包含了遠端設備以前的匹配狀態。
可能值有: BOND_NONE, BOND_BONDING, BOND_BONDED.
常量值: "android.bluetooth.device.extra.PREVIOUS_BOND_STATE"
 
String EXTRA_RSSI   
作為ACTION_FOUND的可選短整型附加域。包含了被藍牙硬體通知的遠端設備的RSSI(Receive Signal Strength Indication，接收信號強度指示)值。
常量值: "android.bluetooth.device.extra.RSSI"


四、公共方法　　
 　　public BluetoothSocketcreateRfcommSocketToServiceRecord (UUID uuid)
     該方法是為了使用帶有listenUsingRfcommWithServiceRecord(String, UUID)方法來進行對等的藍牙應用而設計的。
     使用connect()初始化這個外界連接。它也將執行一個已給與UUID的SDP查找，從而確定連接到哪個通道上。
     遠端設備將被認證，在這個連接埠上的通訊會被加密。
     提示：如果你正試圖連接藍牙串口，那麼使用眾所周知的SPP UUID 00001101-0000-1000-8000-00805F9B34FB。但是你如果正試圖連接Android設備那麼請你生成你自己的專有UUID。
     需要BLUETOOTH權限。
              參數
                       uuid 查詢RFCOMM通道的服務記錄UUID
              返回值
                       一個準備好外界連接的RFCOMM藍牙服務連接埠
              異常
                       IOException     出現錯誤，比如藍牙模組不可用，或者許可無效。
 
     public int describeContents ()
描述了包含在Parcelable's marshalled representation中的特殊對象的種類。
     返回值
一個指示被Parcelabel所排列的特殊對像類型集合的位屏蔽。
 
     public boolean equals (Object o)
比較帶有特定目標的常量。如果他們相等則標示出來。 為了保證其相等，o必須代表相同的對象，該對像作為這個使用類依賴比較的常量。通常約定，該比較既需要可複製、相等和可傳遞。另外，沒有對象引用的時候null等於null。
默認實現是返回ture，僅當this == o。如果你想實現你自己的equals方法，參見Writing a correct equals method。
當且僅當o是一個作為接收器（使用==操作符來做比較）的精確相同的對象是，這個對象的實現才返回true值。子類通常實現equals(Object)方法，這樣它才會重視這兩個對象的類型和狀態。
通常約定，對於equals(Object)和hashCode() 方法，如果equals對於任意兩個對像返回真值，那麼hashCode()必須對這些對像返回相同的紙。這意味著對象的子類通常都覆蓋或者都不覆蓋這兩個方法。
參數
o 需要對比常量的對象
返回值
如果指定的對象和該對像相等則返回true，否則返回false。
 
public String getAddress ()
返回該藍牙設備的硬體地址
例如： "00:11:22:AA:BB:CC".
返回值
字串類型的藍牙硬體地址
 
     public BluetoothClass getBluetoothClass ()
獲取遠端設備的藍牙類
需要BLUETOOTH權限。
返回值
藍牙類對像出錯時返回空值
 
public int getBondState ()
獲取遠端設備的連接狀態。
連接狀態的可能值有: BOND_NONE, BOND_BONDING, BOND_BONDED.
需要BLUETOOTH權限。
返回值
     連接狀態。
 
     public String getName ()
獲取遠端設備的藍牙暱稱。
當執行設備掃瞄的時候，本地適配器將自動尋找遠端名稱。該方法只返回來自存儲器中該設備的名稱。
需要BLUETOOTH權限。
返回值
藍牙暱稱，如果出現問題則返回null。
 
     public int hashCode ()
返回該對象的一個整型哈希值. 通常約定，如果equals對於任意兩個對像返回真值，那麼hashCode()必須對這些對像返回相同的值。這意味著對象的子類通常都覆蓋或者都不覆蓋這兩個方法。
注意：除非同等對比資訊發生改變，否則哈希碼不隨時間改變而改變。
如果你想要實現你自己的哈希碼方法，參見Writing a correct hashCode method。
返回值
該對象的哈希值
 
     public String toString ()
返回該藍牙設備的字串表達式。
這是一個藍牙硬體地址，例如"00:11:22:AA:BB:CC".然而，如果用戶明確需要藍牙硬體地址以防以後toString()表達式會改變的話，用戶總是需要使用getAddress()方法。
返回值
該藍牙設備的字串表達式。
 
     public void writeToParcel (Parcel out, int flags)
將類的數據寫入外部提供的Parcel中
參數
out  對像需要被寫入的Parcel
　　　　　　   flags  和對像需要如何被寫入有關的附加標誌。可能是0，或者可能是


/******************************************************************************/
Android提高第十三篇之探秘藍牙隱藏API    from: http://blog.csdn.net/hellogv/article/details/6042091
/******************************************************************************/
上次講解Android的藍牙基本用法，這次講得深入些，探討下藍牙方面的隱藏API。用過Android系統設置(Setting)的人都知道藍牙搜索之後可以建立配對和解除配對，但是這
兩項功能的函數沒有在SDK中給出，那麼如何去使用這兩項功能呢？本文利用JAVA的反射機制去調用這兩項功能對應的函數：createBond和removeBond，具體的發掘和實現步驟
如下：
1.使用Git工具下載platform/packages/apps/Settings.git，在Setting源碼中查找關於建立配對和解除配對的API，知道這兩個API的宿主(BluetoothDevice)；
2.使用反射機制對BluetoothDevice枚舉其所有方法和常量，看看是否存在:
 
[java] view plaincopyprint?
static public void printAllInform(Class clsShow) {  
    try {  
        // 取得所有方法  
        Method[] hideMethod = clsShow.getMethods();  
        int i = 0;  
        for (; i < hideMethod.length; i++) {  
            Log.e("method name", hideMethod[i].getName());  
        }  
        // 取得所有常量  
        Field[] allFields = clsShow.getFields();  
        for (i = 0; i < allFields.length; i++) {  
            Log.e("Field name", allFields[i].getName());  
        }  
    } catch (SecurityException e) {  
        // throw new RuntimeException(e.getMessage());  
        e.printStackTrace();  
    } catch (IllegalArgumentException e) {  
        // throw new RuntimeException(e.getMessage());  
        e.printStackTrace();  
    } catch (Exception e) {  
        // TODO Auto-generated catch block  
        e.printStackTrace();  
    }  
}  
  
結果如下：
11-29 09:19:12.012: method name(452): cancelBondProcess
11-29 09:19:12.020: method name(452): cancelPairingUserInput
11-29 09:19:12.020: method name(452): createBond
11-29 09:19:12.020: method name(452): createInsecureRfcommSocket
11-29 09:19:12.027: method name(452): createRfcommSocket
11-29 09:19:12.027: method name(452): createRfcommSocketToServiceRecord
11-29 09:19:12.027: method name(452): createScoSocket
11-29 09:19:12.027: method name(452): describeContents
11-29 09:19:12.035: method name(452): equals
11-29 09:19:12.035: method name(452): fetchUuidsWithSdp
11-29 09:19:12.035: method name(452): getAddress
11-29 09:19:12.035: method name(452): getBluetoothClass
11-29 09:19:12.043: method name(452): getBondState
11-29 09:19:12.043: method name(452): getName
11-29 09:19:12.043: method name(452): getServiceChannel
11-29 09:19:12.043: method name(452): getTrustState
11-29 09:19:12.043: method name(452): getUuids
11-29 09:19:12.043: method name(452): hashCode
11-29 09:19:12.043: method name(452): isBluetoothDock
11-29 09:19:12.043: method name(452): removeBond
11-29 09:19:12.043: method name(452): setPairingConfirmation
11-29 09:19:12.043: method name(452): setPasskey
11-29 09:19:12.043: method name(452): setPin
11-29 09:19:12.043: method name(452): setTrust
11-29 09:19:12.043: method name(452): toString
11-29 09:19:12.043: method name(452): writeToParcel
11-29 09:19:12.043: method name(452): convertPinToBytes
11-29 09:19:12.043: method name(452): getClass
11-29 09:19:12.043: method name(452): notify
11-29 09:19:12.043: method name(452): notifyAll
11-29 09:19:12.043: method name(452): wait
11-29 09:19:12.051: method name(452): wait
11-29 09:19:12.051: method name(452): wait
 
3.如果枚舉發現API存在(SDK卻隱藏)，則自己實現調用方法：
[java] view plaincopyprint?
/** 
 * 與設備配對 參考源碼：platform/packages/apps/Settings.git 
 * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java 
 */  
static public boolean createBond(Class btClass,BluetoothDevice btDevice) throws Exception {  
    Method createBondMethod = btClass.getMethod("createBond");  
    Boolean returnValue = (Boolean) createBondMethod.invoke(btDevice);  
    return returnValue.booleanValue();  
}  
  
/** 
 * 與設備解除配對 參考源碼：platform/packages/apps/Settings.git 
 * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java 
 */  
static public boolean removeBond(Class btClass,BluetoothDevice btDevice) throws Exception {  
    Method removeBondMethod = btClass.getMethod("removeBond");  
    Boolean returnValue = (Boolean) removeBondMethod.invoke(btDevice);  
    return returnValue.booleanValue();  
}  

PS:SDK之所以不給出隱藏的API肯定有其原因，也許是出於安全性或者是後續版本相容性的考慮，因此不能保證隱藏API能在所有Android平台上很好地運行。。。
本文程式運行效果如下：

main.xml源碼如下：
[xhtml] view plaincopyprint?
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:orientation="vertical" android:layout_width="fill_parent"  
    android:layout_height="fill_parent">  
    <LinearLayout android:id="@+id/LinearLayout01"  
        android:layout_height="wrap_content" android:layout_width="fill_parent">  
        <Button android:layout_height="wrap_content" android:id="@+id/btnSearch"  
            android:text="Search" android:layout_width="160dip"></Button>  
        <Button android:layout_height="wrap_content"  
            android:layout_width="160dip" android:text="Show" android:id="@+id/btnShow"></Button>  
    </LinearLayout>  
    <LinearLayout android:id="@+id/LinearLayout02"  
        android:layout_width="wrap_content" android:layout_height="wrap_content"></LinearLayout>  
    <ListView android:id="@+id/ListView01" android:layout_width="fill_parent"  
        android:layout_height="fill_parent">  
    </ListView>  
</LinearLayout>  

工具類ClsUtils.java源碼如下：
[java] view plaincopyprint?
package com.testReflect;  
  
import java.lang.reflect.Field;  
import java.lang.reflect.Method;  
  
import android.bluetooth.BluetoothDevice;  
import android.util.Log;  
  
public class ClsUtils {  
  
    /** 
     * 與設備配對 參考源碼：platform/packages/apps/Settings.git 
     * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java 
     */  
    static public boolean createBond(Class btClass,BluetoothDevice btDevice) throws Exception {  
        Method createBondMethod = btClass.getMethod("createBond");  
        Boolean returnValue = (Boolean) createBondMethod.invoke(btDevice);  
        return returnValue.booleanValue();  
    }  
  
    /** 
     * 與設備解除配對 參考源碼：platform/packages/apps/Settings.git 
     * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java 
     */  
    static public boolean removeBond(Class btClass,BluetoothDevice btDevice) throws Exception {  
        Method removeBondMethod = btClass.getMethod("removeBond");  
        Boolean returnValue = (Boolean) removeBondMethod.invoke(btDevice);  
        return returnValue.booleanValue();  
    }  
  
    /** 
     *  
     * @param clsShow 
     */  
    static public void printAllInform(Class clsShow) {  
        try {  
            // 取得所有方法  
            Method[] hideMethod = clsShow.getMethods();  
            int i = 0;  
            for (; i < hideMethod.length; i++) {  
                Log.e("method name", hideMethod[i].getName());  
            }  
            // 取得所有常量  
            Field[] allFields = clsShow.getFields();  
            for (i = 0; i < allFields.length; i++) {  
                Log.e("Field name", allFields[i].getName());  
            }  
        } catch (SecurityException e) {  
            // throw new RuntimeException(e.getMessage());  
            e.printStackTrace();  
        } catch (IllegalArgumentException e) {  
            // throw new RuntimeException(e.getMessage());  
            e.printStackTrace();  
        } catch (Exception e) {  
            // TODO Auto-generated catch block  
            e.printStackTrace();  
        }  
    }  
}  

主程式testReflect.java的源碼如下：
[java] view plaincopyprint?
package com.testReflect;  
  
import java.util.ArrayList;  
import java.util.List;  
import android.app.Activity;  
import android.bluetooth.BluetoothAdapter;  
import android.bluetooth.BluetoothDevice;  
import android.content.BroadcastReceiver;  
import android.content.Context;  
import android.content.Intent;  
import android.content.IntentFilter;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.View;  
import android.widget.AdapterView;  
import android.widget.ArrayAdapter;  
import android.widget.Button;  
import android.widget.ListView;  
import android.widget.Toast;  
  
public class testReflect extends Activity {  
    Button btnSearch, btnShow;  
    ListView lvBTDevices;  
    ArrayAdapter<String> adtDevices;  
    List<String> lstDevices = new ArrayList<String>();  
    BluetoothDevice btDevice;  
    BluetoothAdapter btAdapt;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
  
        btnSearch = (Button) this.findViewById(R.id.btnSearch);  
        btnSearch.setOnClickListener(new ClickEvent());  
        btnShow = (Button) this.findViewById(R.id.btnShow);  
        btnShow.setOnClickListener(new ClickEvent());  
  
        lvBTDevices = (ListView) this.findViewById(R.id.ListView01);  
        adtDevices = new ArrayAdapter<String>(testReflect.this,  
                android.R.layout.simple_list_item_1, lstDevices);  
        lvBTDevices.setAdapter(adtDevices);  
        lvBTDevices.setOnItemClickListener(new ItemClickEvent());  
  
        btAdapt = BluetoothAdapter.getDefaultAdapter();// 初始化本機藍牙功能  
        if (btAdapt.getState() == BluetoothAdapter.STATE_OFF)// 開藍牙  
            btAdapt.enable();  
  
        // 註冊Receiver來獲取藍牙設備相關的結果  
        IntentFilter intent = new IntentFilter();  
        intent.addAction(BluetoothDevice.ACTION_FOUND);  
        intent.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);  
        registerReceiver(searchDevices, intent);  
  
    }  
  
      
    private BroadcastReceiver searchDevices = new BroadcastReceiver() {  
        public void onReceive(Context context, Intent intent) {  
            String action = intent.getAction();  
            Bundle b = intent.getExtras();  
            Object[] lstName = b.keySet().toArray();  
  
            // 顯示所有收到的消息及其細節  
            for (int i = 0; i < lstName.length; i++) {  
                String keyName = lstName[i].toString();  
                Log.e(keyName, String.valueOf(b.get(keyName)));  
            }  
            // 搜索設備時，取得設備的MAC地址  
            if (BluetoothDevice.ACTION_FOUND.equals(action)) {  
                BluetoothDevice device = intent  
                        .getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  
  
                if (device.getBondState() == BluetoothDevice.BOND_NONE) {  
                    String str = "未配對|" + device.getName() + "|" + device.getAddress();  
                    lstDevices.add(str); // 獲取設備名稱和mac地址  
                    adtDevices.notifyDataSetChanged();  
                }  
            }  
        }  
    };  
  
    class ItemClickEvent implements AdapterView.OnItemClickListener {  
  
        @Override  
        public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,  
                long arg3) {  
            btAdapt.cancelDiscovery();  
            String str = lstDevices.get(arg2);  
            String[] values = str.split("//|");  
            String address=values[2];  
  
            btDevice = btAdapt.getRemoteDevice(address);  
            try {  
                if(values[0].equals("未配對"))  
                {     
                    Toast.makeText(testReflect.this, "由未配對轉為已配對", 500).show();  
                    ClsUtils.createBond(btDevice.getClass(), btDevice);  
                }  
                else if(values[0].equals("已配對"))  
                {  
                    Toast.makeText(testReflect.this, "由已配對轉為未配對", 500).show();  
                    ClsUtils.removeBond(btDevice.getClass(), btDevice);  
                }  
            } catch (Exception e) {  
                // TODO Auto-generated catch block  
                e.printStackTrace();  
            }  
        }  
          
    }  
      
    /** 
     * 按鍵處理 
     * @author GV 
     * 
     */  
    class ClickEvent implements View.OnClickListener {  
  
        @Override  
        public void onClick(View v) {  
            if (v == btnSearch) {//搜索附近的藍牙設備  
                lstDevices.clear();  
                  
                Object[] lstDevice = btAdapt.getBondedDevices().toArray();  
                for (int i = 0; i < lstDevice.length; i++) {  
                    BluetoothDevice device=(BluetoothDevice)lstDevice[i];  
                    String str = "已配對|" + device.getName() + "|" + device.getAddress();  
                    lstDevices.add(str); // 獲取設備名稱和mac地址  
                    adtDevices.notifyDataSetChanged();  
                }  
                // 開始搜索  
                setTitle("本機藍牙地址：" + btAdapt.getAddress());  
                btAdapt.startDiscovery();  
            }  
            else if(v==btnShow){//顯示BluetoothDevice的所有方法和常量，包括隱藏API  
                ClsUtils.printAllInform(btDevice.getClass());  
            }  
  
        }  
  
    }  
  
  
}  


/******************************************************************************/
Reading a MiFare Classic 1K from Android using Nexus S.
/******************************************************************************/
Ever since Near Field Communication was embedded on mobile phones, loads of new ideas and business proposals made people very busy. 
So does the Android platform with its API's supporting NFC. 
Nexus S looks like a state of the art - good starting point if one wants to get past the monotonic Nokia's piece of the cake. 
I just want to share with you my experience on reading a MiFare Classic tag using the Nexus S..and the Android platform. 

You need to have:
A MiFare Classic 1k Tag - ( hopefully you know the keys for its Blocks :=) )
Android SDK and IDE
Preferable a Nexus S (Make sure if the Android version is 2.3.3 and above).

Some Basics about the card:
MiFare classic cards store data in its Sectors. In MiFare classic 1k card there are 16 of them. Each Sector contains 4 blocks.  
You can store 16 bytes in each block. Making about 1024 bytes of storage space..that explains the 1K part of the card. You can perform common tasks like
 reading, writing data on these blocks, authentification, navigating the card sectors by incrementing the blocks count. The first sector contains 
 manufacturer』s details and a unique id for the card. This is a read only part.
Each sector on the Mifare card is secured by two 48-bit keys: A and B. The last block in the sector contains these keys, as well as a configuration that defines what each key can do with each block, i.e block 0 could be configured so that
key A could read and write, but if a reader authenticates with key B, the reader would only be able to read that block.
The rest of the memory storage can be read or written using keys A and B. Fresh, empty Mifare cards have all their sectors locked with a pair of default keys FFFFFFFFFFFF or 000000000000. 

Default Keys from experiments
About the NFC part of Android
Since ver 2.3.3 Gingerbread - Android exposes an API to read a list of card technologies. 
To perform operations on a tag, there are three things to be noted.
1) The cards store data in a format,
2) Reading and Writing data is done using a protocol
3) Cards support a technology that defines what they are 
hence reading and writing to these cards can be done only when the data is arranged in that format. MiFare 1K cards support the NDEF format. 
It also supports NFC - protocol on the communication level. Precisely - ISO 14443 - 3A specification in short NFCA and it uses the MiFare technology.
Now we need to let the Android know what kind of cards we would be using in our application. This is often defined in an XML file stored in the resource 
folder ( I have named the file - filter_nfc.xml and stored it in a folder named xml). This resource file contains for example,

<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <tech-list> 
        <tech>android.nfc.tech.NfcA</tech> 
        <tech>android.nfc.tech.MifareClassic</tech> 
    </tech-list>
</resources> 

Here we have declared a tech-list. This list has to be used in the Manifest file. Imagine you would like to start an activity when a tag is touched. The Manifest file is the right place to let the launcher know what activity is to be called when a particular tag is touched.
In the Manifest file, you would have an element - activity. This would declare the name of the activity, a title for it and some metadata. Ideally you would let the system know that you want to start this activity when you touch a MiFare classic card. You can define you own filters for different activities for a variety of tag and protocol combinations.

<activity android:label="@string/event_verify" android:name="verifytagscanact">
            <intent-filter>
                <action android:name="android.nfc.action.TECH_DISCOVERED"/>
            </intent-filter>
            <meta-data android:name="android.nfc.action.TECH_DISCOVERED" android:resource="@xml/filter_nfc"/>
        </activity>

You would then set the permissions on your Manifest file.
<uses-permission android:name="android.permission.NFC"/>

You can also do this in your onCreate method by using an NfcAdapter,
 NfcAdapter mAdapter = NfcAdapter.getDefaultAdapter(this);


When a MiFare tag is discovered, the NFC stack would get the details of the tag and deliver it to a new Intent of this same activity. 
Hence to handle this, we would need an instance of the  PendingIntent from the current activity.
PendingIntent mPendingIntent = PendingIntent.getActivity(this, 0,
                new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);

Then we could set up our filter which defines the data format and technology type.
IntentFilter ndef = new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED);
        try {
            ndef.addDataType("*/*");
        } catch (MalformedMimeTypeException e) {
            throw new RuntimeException("fail", e);
        }
        mFilters = new IntentFilter[] {
                ndef,
        };

        // Setup a tech list for all NfcF tags
        mTechLists = new String[][] { new String[] { MifareClassic.class.getName() } };
        
        Intent intent = getIntent();

Finally when the pending intent calls the activity again, we like to read the tag. I have put all the steps in the method resolveIntent which would do 
only the reading part of the tag.
        resolveIntent(intent); 

Reading the tag
The method looks like 
private void resolveIntent(Intent intent){
 1) Parse the intent and get the action that triggered this intent
 2) Check if it was triggered by a tag discovered interruption.
 3) Get an instance of the TAG from the NfcAdapter
 4) Get an instance of the Mifare classic card from this TAG instance
 5) Connect to card and get the number of sectors this card has..and loop thru these sectors
 6) In each sector - get the block count, loop thru the blocks, authenticate the sector and read the data
 7) Convert the data into a string from Hex format.
}

filling up with the Android NFC API's
void resolveIntent(Intent intent) {
        // 1) Parse the intent and get the action that triggered this intent
        String action = intent.getAction();
        // 2) Check if it was triggered by a tag discovered interruption.
        if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(action)) {
            //  3) Get an instance of the TAG from the NfcAdapter
            Tag tagFromIntent = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
            // 4) Get an instance of the Mifare classic card from this TAG intent
            MifareClassic mfc = MifareClassic.get(tagFromIntent);
            byte[] data;
            
            try {       //  5.1) Connect to card 
            mfc.connect();
            boolean auth = false;
            String cardData = null;
            // 5.2) and get the number of sectors this card has..and loop thru these sectors
            int secCount = mfc.getSectorCount();
            int bCount = 0;
            int bIndex = 0;
            for(int j = 0; j < secCount; j++){
                // 6.1) authenticate the sector
                auth = mfc.authenticateSectorWithKeyA(j, MifareClassic.KEY_DEFAULT);
                if(auth){
                    // 6.2) In each sector - get the block count
                    bCount = mfc.getBlockCountInSector(j);
                    bIndex = 0;
                    for(int i = 0; i < bCount; i++){
                        bIndex = mfc.sectorToBlock(j);
                        // 6.3) Read the block
                        data = mfc.readBlock(bIndex);    
                        // 7) Convert the data into a string from Hex format.                
                        Log.i(TAG, getHexString(data, data.length));
                        bIndex++;
                    }
                }else{ // Authentication failed - Handle it
                    
                }
            }    
        }catch (IOException e) { 
                Log.e(TAG, e.getLocalizedMessage());
                showAlert(3);
            }
    }// End of method
}
you would have to think about how you like to handle the lifecycle of this activity. I Like to call the reading part of the activity when I detect a tag and if on pause.. would like to disable this. It has been very neatly explained in the Android samples on Foreground dispatch.. I have added this part of the code here too,


     @Override
        public void onResume() {
            super.onResume();
            mAdapter.enableForegroundDispatch(this, mPendingIntent, mFilters, mTechLists);
        }

        @Override
        public void onNewIntent(Intent intent) {
            Log.i("Foreground dispatch", "Discovered tag with intent: " + intent);
            resolveIntent(intent);            
        }

        @Override
        public void onPause() {
            super.onPause();
            mAdapter.disableForegroundDispatch(this);
        }

Hope this was useful for you. I would try writing to tag on my next blog. If you would find better ideas, please do share.
Cheers
Domnic
PS: Hope you enjoy this sample code :)


/******************************************************************************/
〔Android〕利用手機藍芽控制小車機器人(視頻+程式碼) @ 資訊園 :: 痞客邦 PIXNET ::
/******************************************************************************/
目前主流的手機作業系統有塞班、安卓（Android）、Windows Mobile，對比了一下，首先，塞班是用C++寫的，這麼多門語言我唯獨看到C++就頭大•••，放棄了•••，Windows Moblie其實和之前發的電腦端程式基本是一樣的，也就沒什麼意思了，最後決定選擇目前正火的Android手機作為控制平台。
Android是個開源的應用，使用Java語言對其編程。於是這次的開發我選用Eclipse作為開發工具，用Java語言開發手機端的控制程式，由於之前對Android的藍牙通信這塊涉及不多，一開始感覺有點小茫然，而網上也少有這方面的例程，有少數人做出了類似的東西，但是只傳了個視頻裝X！雪特••••
經過幾天的研究，最終確定了手機藍牙通信其實就是Socket編程，在經過一番編寫和調試，昨晚終於大功告成！
這是視頻：
下面開始介紹Android手機端控制程式的編寫：
首先打開Eclipse，當然之前的Java開發環境和安卓開發工具自己得先配置好，這裡就不多說了，網上教程一大摞。
然後新建一個Android項目，修改佈局文件main.xml，代碼如下：
<?xml version="1.0" encoding="utf-8"?>
<AbsoluteLayout
android:id="@+id/widget0"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
xmlns:android="http://schemas.android.com/apk/res/android "
>
<Button
android:id="@+id/btnF"
android:layout_width="100px"
android:layout_height="60px"
android:text="前進"
android:layout_x="130px"
android:layout_y="62px"
>
</Button>
<Button
android:id="@+id/btnL"
android:layout_width="100px"
android:layout_height="60px"
android:text="左轉"
android:layout_x="20px"
android:layout_y="152px"
>
</Button>
<Button
android:id="@+id/btnR"
android:layout_width="100px"
android:layout_height="60px"
android:text="右轉"
android:layout_x="240px"
android:layout_y="152px"
>
</Button>
<Button
android:id="@+id/btnB"
android:layout_width="100px"
android:layout_height="60px"
android:text="後退"
android:layout_x="130px"
android:layout_y="242px"
>
</Button>
<Button
android:id="@+id/btnS"
android:layout_width="100px"
android:layout_height="60px"
android:text="停止"
android:layout_x="130px"
android:layout_y="152px"
>
</Button>
</AbsoluteLayout>

這個佈局文件的效果就是如視頻中所示的手機操作界面。
然後是權限聲明，這一步不能少，否則將無法使用安卓手機的藍牙功能。
權限聲明如下：
打開AndroidManifest.xml文件，修改代碼如下：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android "
package="com.ThinBTClient.www"
android:versionCode="1"
android:versionName="1.0">

<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH" />
<application android:icon="@drawable/icon" android:label="@string/app_name">
<activity android:name=".ThinBTClient"
android:label="@string/app_name">
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>

</application>
</manifest>

其中紅色、加粗部分就是要添加的權限聲明。
然後編寫Activity中的執行代碼，這些代碼的作用就是發送指令，控制小車的運動。
代碼如下：

package com.ThinBTClient.www;

import android.app.Activity;
import android.os.Bundle;
import java.io.IOException;
import java.io.OutputStream;
import java.util.UUID;
import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.provider.ContactsContract.CommonDataKinds.Event;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class ThinBTClient extends Activity {
    private static final String TAG = "THINBTCLIENT";
    private static final boolean D = true;
    private BluetoothAdapter mBluetoothAdapter = null;
    private BluetoothSocket btSocket = null;
    private OutputStream outStream = null;

    Button mButtonF;
    Button mButtonB;
    Button mButtonL;
    Button mButtonR;
    Button mButtonS;

    private static final UUID MY_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
    private static String address = "00:11:03:21:00:43"; // <==要連接的藍牙設備MAC地址

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        //前進
        mButtonF=(Button)findViewById(R.id.btnF);
        mButtonF.setOnTouchListener(new Button.OnTouchListener(){
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // TODO Auto-generated method stub
                String message;
                byte[] msgBuffer;
                int action = event.getAction();
                switch(action)
                {
                    case MotionEvent.ACTION_DOWN:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "1";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;

                    case MotionEvent.ACTION_UP:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "0";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;
                }
                return false;
            }
        });

        //後退
        mButtonB=(Button)findViewById(R.id.btnB);
        mButtonB.setOnTouchListener(new Button.OnTouchListener(){
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // TODO Auto-generated method stub
                String message;
                byte[] msgBuffer;
                int action = event.getAction();
                switch(action)
                {
                    case MotionEvent.ACTION_DOWN:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "3";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;

                    case MotionEvent.ACTION_UP:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "0";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;
                }
                return false;
            }
        });

        //左轉
        mButtonL=(Button)findViewById(R.id.btnL);
        mButtonL.setOnTouchListener(new Button.OnTouchListener(){
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // TODO Auto-generated method stub
                String message;
                byte[] msgBuffer;
                int action = event.getAction();
                switch(action)
                {
                    case MotionEvent.ACTION_DOWN:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "2";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;

                    case MotionEvent.ACTION_UP:
                    try {
                        outStream = btSocket.getOutputStream();
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                    }
                    message = "0";
                    msgBuffer = message.getBytes();
                    try {
                        outStream.write(msgBuffer);
                    } catch (IOException e) {
                        Log.e(TAG, "ON RESUME: Exception during write.", e);
                    }
                    break;
                }
                return false;
            }
        });

        //右轉
        mButtonR=(Button)findViewById(R.id.btnR);
        mButtonR.setOnTouchListener(new Button.OnTouchListener(){

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // TODO Auto-generated method stub
            String message;
            byte[] msgBuffer;
            int action = event.getAction();
            switch(action)
            {
                case MotionEvent.ACTION_DOWN:
                try {
                    outStream = btSocket.getOutputStream();
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                }
                message = "4";
                msgBuffer = message.getBytes();
                try {
                    outStream.write(msgBuffer);
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Exception during write.", e);
                }
                break;

                case MotionEvent.ACTION_UP:
                try {
                    outStream = btSocket.getOutputStream();
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                }
                message = "0";
                msgBuffer = message.getBytes();
                try {
                    outStream.write(msgBuffer);
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Exception during write.", e);
                }
                break;
            }
            return false;
            }
        });

        //停止
        mButtonS=(Button)findViewById(R.id.btnS);
        mButtonS.setOnTouchListener(new Button.OnTouchListener(){
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // TODO Auto-generated method stub
                if(event.getAction()==MotionEvent.ACTION_DOWN)
                try {
                    outStream = btSocket.getOutputStream();
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                }

                String message = "0";
                byte[] msgBuffer = message.getBytes();
                try {
                    outStream.write(msgBuffer);
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Exception during write.", e);
                }
                return false;
            }
        });

        if (D)
        Log.e(TAG, "+++ ON CREATE +++");
        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter == null) {
        Toast.makeText(this, "Bluetooth is not available.", Toast.LENGTH_LONG).show();
        finish();
        return;
        }

        if (!mBluetoothAdapter.isEnabled()) {
        Toast.makeText(this, "Please enable your Bluetooth and re-run this program.", Toast.LENGTH_LONG).show();
        finish();
        return;
        }

        if (D)
        Log.e(TAG, "+++ DONE IN ON CREATE, GOT LOCAL BT ADAPTER +++");
    }

    @Override
    public void onStart() {
      super.onStart();
      if (D) Log.e(TAG, "++ ON START ++");
    }

    @Override
    public void onResume() {
        super.onResume();
        if (D) {
            Log.e(TAG, "+ ON RESUME +");
            Log.e(TAG, "+ ABOUT TO ATTEMPT CLIENT CONNECT +");

            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
            btSocket = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) {
            Log.e(TAG, "ON RESUME: Socket creation failed.", e);
        }

        mBluetoothAdapter.cancelDiscovery();
        try {
            btSocket.connect();
            Log.e(TAG, "ON RESUME: BT connection established, data transfer link open.");
        } catch (IOException e) {
            try {
                btSocket.close();
            } catch (IOException e2) {
                Log .e(TAG,"ON RESUME: Unable to close socket during connection failure", e2);
            }

            // Create a data stream so we can talk to server.
            if (D)
                Log.e(TAG, "+ ABOUT TO SAY SOMETHING TO SERVER +");
                /* try {
                    outStream = btSocket.getOutputStream();
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Output stream creation failed.", e);
                }
                String message = "1";
                byte[] msgBuffer = message.getBytes();
                try {
                    outStream.write(msgBuffer);
                } catch (IOException e) {
                    Log.e(TAG, "ON RESUME: Exception during write.", e);
                }
            */
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        if (D)
            Log.e(TAG, "- ON PAUSE -");
            if (outStream != null) {
            try {
            outStream.flush();
            } catch (IOException e) {
            Log.e(TAG, "ON PAUSE: Couldn't flush output stream.", e);
        }
        try {
            btSocket.close();
        } catch (IOException e2) {
            Log.e(TAG, "ON PAUSE: Unable to close socket.", e2);
        }
        }
    }

    @Override
    public void onStop() {
        super.onStop();
        if (D)Log.e(TAG, "-- ON STOP --");
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (D) Log.e(TAG, "--- ON DESTROY ---");
    }
}


可以看到，在這個程式中我直接把小車藍牙模組的MAC地址給寫進去了，其實更合理一點應該讓程式運行後搜索周圍藍牙設備，然後選擇需要連接的設備，獲取它的MAC地址再
連接，但是我為了圖省事，就直接把我的小車的藍牙MAC給定死了（反正也沒那麼多小車讓我遙控~~~），這樣一打開程式，手機將自動連接智慧小車。
好了，手機端的開發到此介紹完畢~希望能為需要者提供一點幫助。
下一步是打算增加紅外避障功能、超音波測距功能，機械手臂，如果有機會，以後再安裝上火控系統發射鑽天猴~，不過估計時間不太允許了••••••
再次鄙視光顯擺卻不肯分享技術的裝X黨！
版權所有：Liuviking，轉載請註明出處，O(∩_∩)O謝謝~
資料來源：http://hi.baidu.com/liuhuiviking/blog/item/503f2e1feb0e00e3e1fe0b74.html


/******************************************************************************/
Java多線程初學者指南（10）：使用Synchronized關鍵字同步類方法    from: http://www.blogjava.net/nokiaguy/archive/2009/nokiaguy/archive/2009/03/20/261020.html
/******************************************************************************/
要想解決「髒數據」的問題，最簡單的方法就是使用synchronized關鍵字來使run方法同步，代碼如下：
public synchronized void run()
{
 ...    
}
從上面的代碼可以看出，只要在void和public之間加上synchronized關鍵字，就可以使run方法同步，也就是說，對於同一個Java類的對象實例，run方法同時只能被一個線程調用，並當前的run執行完後，才能被其他的線程調用。即使當前線程執行到了run方法中的yield方法，也只是暫停了一下。由於其他線程無法執行run方法，因此，最終還是會由當前的線程來繼續執行。先看看下面的代碼：
sychronized關鍵字只和一個對像實例綁定
  class Test
  {
        public synchronized void method()
       {
         ...    
       }
  }
   
  public class Sync implements Runnable
  {
       private Test test;
       public void run()
       {
            test.method();
       }
       public Sync(Test test)
       {
           this.test = test;
       }
       public static void main(String[] args) throws Exception
       {
           Test test1 =  new Test();
           Test test2 =  new Test();
           Sync sync1 = new Sync(test1);
           Sync sync2 = new Sync(test2);
           new Thread(sync1).start();
           new Thread(sync2).start(); 
       }
   }
在Test類中的method方法是同步的。但上面的代碼建立了兩個Test類的實例，因此，test1和test2的method方法是分別執行的。要想讓method同步，必須在建立Sync類的實例時向它的構造方法中傳入同一個Test類的實例，如下面的代碼所示：
Sync sync1 = new Sync(test1);
    不僅可以使用synchronized來同步非靜態方法，也可以使用synchronized來同步靜態方法。如可以按如下方式來定義method方法：
class Test 
{
    public static synchronized void method() {   }
}

建立Test類的對象實例如下：
Test test = new Test();
對於靜態方法來說，只要加上了synchronized關鍵字，這個方法就是同步的，無論是使用test.method()，還是使用Test.method()來調用method方法，method都是同步的，並不存在非靜態方法的多個實例的問題。
在23種設計模式中的單件（Singleton）模式如果按傳統的方法設計，也是線程不安全的，下面的代碼是一個線程不安全的單件模式。
package test;
// 線程安全的Singleton模式
class Singleton
{
    private static Singleton sample;

    private Singleton()
    {
    }
    public static Singleton getInstance()
    {
        if (sample == null)
        {
            Thread.yield(); // 為了放大Singleton模式的線程不安全性
            sample = new Singleton();
        }
        return sample;
    }
}
public class MyThread extends Thread
{
    public void run()
    {
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton.hashCode());
    }
    public static void main(String[] args)
    {
        Thread threads[] = new Thread[5];
        for (int i = 0; i < threads.length; i++)
            threads[i] = new MyThread();
        for (int i = 0; i < threads.length; i++)
            threads[i].start();
    }
}
在上面的代碼調用yield方法是為了使單件模式的線程不安全性表現出來，如果將這行去掉，上面的實現仍然是線程不安全的，只是出現的可能性小得多。
程式的運行結果如下：
25358555
26399554
7051261
29855319
5383406
上面的運行結果可能在不同的運行環境上有所有同，但一般這五行輸出不會完全相同。從這個輸出結果可以看出，通過getInstance方法得到的對象實例是五個，而不是我們期望的一個。這是因為當一個線程執行了Thread.yield()後，就將CPU資源交給了另外一個線程。由於在線程之間切換時並未執行到創建Singleton對像實例的語句，因此，這幾個線程都通過了if判斷，所以，就會產生了建立五個對像實例的情況（可能創建的是四個或三個對像實例，這取決於有多少個線程在創建Singleton對像之前通過了if判斷，每次運行時可能結果會不一樣）。

要想使上面的單件模式變成線程安全的，只要為getInstance加上synchronized關鍵字即可。代碼如下：
public static synchronized Singleton getInstance() {   }
當然，還有更簡單的方法，就是在定義Singleton變數時就建立Singleton對像，代碼如下：
private static final Singleton sample = new Singleton();
然後在getInstance方法中直接將sample返回即可。這種方式雖然簡單，但不知在getInstance方法中創建Singleton對像靈活。讀者可以根據具體的需求選擇使用不同的方法來實現單件模式。
在使用synchronized關鍵字時有以下四點需要注意：
1.  synchronized關鍵字不能繼承。
雖然可以使用synchronized來定義方法，但synchronized並不屬於方法定義的一部分，因此，synchronized關鍵字不能被繼承。如果在父類中的某個方法使用了synchronized關鍵字，而在子類中覆蓋了這個方法，在子類中的這個方法默認情況下並不是同步的，而必須顯式地在子類的這個方法中加上synchronized關鍵字才可以。當然，還可以在子類方法中調用父類中相應的方法，這樣雖然子類中的方法不是同步的，但子類調用了父類的同步方法，因此，子類的方法也就相當於同步了。這兩種方式的例子代碼如下：
在子類方法中加上synchronized關鍵字
class Parent
{
    public synchronized void method() {   }
}
class Child extends Parent
{
    public synchronized void method() {   }
}
在子類方法中調用父類的同步方法
class Parent
{
    public synchronized void method() {   }
}
class Child extends Parent
{
    public void method() { super.method();   }
}
2.  在定義介面方法時不能使用synchronized關鍵字。
3.  構造方法不能使用synchronized關鍵字，但可以使用下節要討論的synchronized塊來進行同步。
4.  synchronized可以自由放置。
在前面的例子中使用都是將synchronized關鍵字放在方法的返回類型前面。但這並不是synchronized可放置唯一位置。在非靜態方法中，synchronized還可以放在方法定義的最前面，在靜態方法中，synchronized可以放在static的前面，代碼如下：

public synchronized void method();
synchronized public void method();
public static synchronized void method();
public synchronized static void method();
synchronized public static void method();
但要注意，synchronized不能放在方法返回類型的後面，如下面的代碼是錯誤的：

public void synchronized method();
public static void synchronized method();
synchronized關鍵字只能用來同步方法，不能用來同步類變數，如下面的代碼也是錯誤的。

public synchronized int n = 0;
public static synchronized int n = 0;
雖然使用synchronized關鍵字同步方法是最安全的同步方式，但大量使用synchronized關鍵字會造成不必要的資源消耗以及性能損失。雖然從表面上看synchronized鎖定的是一個方法，但實際上synchronized鎖定的是一個類。也就是說，如果在非靜態方法method1和method2定義時都使用了synchronized，在method1未執行完之前，method2是不能執行的。靜態方法和非靜態方法的情況類似。但靜態和非靜態方法不會互相影響。看看如下的代碼：
package test;
public class MyThread1 extends Thread
{
    public String methodName;

    public static void method(String s)
    {
        System.out.println(s);
        while (true)
            ;
    }
    public synchronized void method1()
    {
        method("非靜態的method1方法");
    }
    public synchronized void method2()
    {
        method("非靜態的method2方法");
    }
    public static synchronized void method3()
    {
        method("靜態的method3方法");
    }
    public static synchronized void method4()
    {
        method("靜態的method4方法");
    }
    public void run()
    {
        try
        {
            getClass().getMethod(methodName).invoke(this);
        }
        catch (Exception e)
        {
        }
    }
    public static void main(String[] args) throws Exception
    {
        MyThread1 myThread1 = new MyThread1();
        for (int i = 1; i <= 4; i++)
        {
            myThread1.methodName = "method" + String.valueOf(i);
            new Thread(myThread1).start();
            sleep(100);
        }
    }
}
運行結果如下：
非靜態的method1方法
靜態的method3方法
從上面的運行結果可以看出，method2和method4在method1和method3未結束之前不能運行。因此，我們可以得出一個結論，如果在類中使用synchronized關鍵字來定義非靜態方法，那將影響這箇中的所有使用synchronized關鍵字定義的非靜態方法。如果定義的是靜態方法，那麼將影響類中所有使用synchronized關鍵字定義的靜態方法。這有點像數據表中的表鎖，當修改一條記錄時，系統就將整個表都鎖住了，因此，大量使用這種同步方式會使程式的性能大幅度下降。


/******************************************************************************/
Java多線程初學者指南（11）：使用Synchronized塊同步方法
/******************************************************************************/
    synchronized關鍵字有兩種用法。第一種就是在《使用Synchronized關鍵字同步類方法》一文中所介紹的直接用在方法的定義中。另外一種就是synchronized塊。我們不僅可以通過synchronized塊來同步一個對像變數。也可以使用synchronized塊來同步類中的靜態方法和非靜態方法。
synchronized塊的語法如下：
public void method()
{
    … …
    synchronized(表達式)
    {
        … …
    }
}
一、非靜態類方法的同步   
從《使用Synchronized關鍵字同步類方法》一文中我們知道使用synchronized關鍵字來定義方法就會鎖定類中所有使用synchronzied關鍵字定義的靜態方法或非靜態方法，但這並不好理解。而如果使用synchronized塊來達到同樣的效果，就不難理解為什麼會產生這種效果了。如果想使用synchronized塊來鎖定類中所有的同步非靜態方法，需要使用this做為synchronized塊的參數傳入synchronized塊國，代碼如下：
通過synchronized塊同步非靜態方法
  001  public class SyncBlock
  002  {
  003      public void method1()
  004      {
  005          synchronized(this)  // 相當於對method1方法使用synchronized關鍵字
  006          {
  007              … …
  008          }
  009      }
  010      public void method2()
  011      {
  012          synchronized(this)  // 相當於對method2方法使用synchronized關鍵字
  013          {
  014              … …
  015          }
  016      }
  017      public synchronized void method3()  
  018      {
  019          … …
  020      }
  021  }
在上面的代碼中的method1和method2方法中使用了synchronized塊。而第017行的method3方法仍然使用synchronized關鍵字來定義方法。在使用同一個SyncBlock類實例時，這三個方法只要有一個正在執行，其他兩個方法就會因未獲得同步鎖而被阻塞。在使用synchronized塊時要想達到和synchronized關鍵字同樣的效果，必須將所有的代碼都寫在synchronized塊中，否則，將無法使當前方法中的所有代碼和其他的方法同步。

除了使用this做為synchronized塊的參數外，還可以使用SyncBlock.this作為synchronized塊的參數來達到同樣的效果。
在內類（InnerClass）的方法中使用synchronized塊來時，this只表示內類，和外類(OuterClass)沒有關係。但內類的非靜態方法可以和外類的非靜態方法同步。如在內類InnerClass中加一個method4方法，並使method4方法和SyncBlock的三個方法同步，代碼如下：
使內類的非靜態方法和外類的非靜態方法同步 
public class SyncBlock
{
    … …
    class InnerClass
    {
        public void method4()
        {
            synchronized(SyncBlock.this)
            {
                … … 
            }
        }
    }
    … …
}
在上面SyncBlock類的新版本中，InnerClass類的method4方法和SyncBlock類的其他三個方法同步，因此，method1、method2、method3和method4四個方法在同一時間只能有一個方法執行。
Synchronized塊不管是正常執行完，還是因為程式出錯而異常退出synchronized塊，當前的synchronized塊所持有的同步鎖都會自動釋放。因此，在使用synchronized塊時不必擔心同步鎖的釋放問題。

二、靜態類方法的同步
由於在調用靜態方法時，對像實例不一定被創建。因此，就不能使用this來同步靜態方法，而必須使用Class對像來同步靜態方法。代碼如下：
通過synchronized塊同步靜態方法 
   public class StaticSyncBlock
   {
       public static void method1()
       {
           synchronized(StaticSyncBlock.class)  
           {
               … …
           }
       }
       public static synchronized void method2()  
       {
           … …
       }
   }
    在同步靜態方法時可以使用類的靜態字段class來得到Class對象。在上例中method1和method2方法同時只能有一個方法執行。除了使用class字段得到Class對像外，還可以使用實例的getClass方法來得到Class對象。上例中的代碼可以修改如下：

使用getClass方法得到Class對像
public class StaticSyncBlock
{
    public static StaticSyncBlock instance; 
    public StaticSyncBlock()
    {
        instance = this;
    }
    public static void method1()
    {
       synchronized(instance.getClass())
       {
            
       }
    }
     
}
在上面代碼中通過一個public的靜態instance得到一個StaticSyncBlock類的實例，並通過這個實例的getClass方法得到了Class對像（一個類的所有實例通過getClass方法得到的都是同一個Class對像，因此，調用任何一個實例的getClass方法都可以）。我們還可以通過Class對像使不同類的靜態方法同步，如Test類的靜態方法method和StaticSyncBlock類的兩個靜態方法同步，代碼如下：

Test類的method方法和StaticSyncBlock類的method1、method2方法同步
   public class Test
   {
       public static void method()
       {
           synchronized(StaticSyncBlock.class)
           {
                
           }
       }
   }
注意：在使用synchronized塊同步類方法時，非靜態方法可以使用this來同步，而靜態方法必須使用Class對像來同步。它們互不影響。當然，也可以在非靜態方法中使用Class對像來同步靜態方法。但在靜態方法中不能使用this來同步非靜態方法。這一點在使用synchronized塊同步類方法時應注意。


/******************************************************************************/
一個activity中多個handler和消息的處理過程
/******************************************************************************/
能否有多個handler

handler的構造方法
public Handler() {
        mLooper = Looper.myLooper();
        mQueue = mLooper.mQueue;
        mCallback = null;
}
因為幾乎主要的成員變數都是從Looper中拿出來的，最初以為一個線程中只能有一個handler。
後來看構造方法也沒有限制，嘗試的寫了下，發現的確可以實例化多個handler
後來又想，如果兩個handler都重寫了handleMessage方法，而handleMessage方法之後，消息會從消息隊列中移除。
那麼假設A發送了一個消息，想實現一些功能，但是B卻對這個消息進行了處理，那麼A中的功能不是無法實現了嗎？
重新看了一下消息的分法機制，終於恍然大悟
1、 Handler發送消息的時候
public boolean sendMessageAtTime(Message msg, long uptimeMillis){
        if (queue != null) {
            msg.target = this;// 發送消息的時候會把target設為當前的Handler
            sent = queue.enqueueMessage(msg, uptimeMillis);
        }
}

2、而Looper中的循環
public static final void loop() {
        Looper me = myLooper();
        MessageQueue queue = me.mQueue;

        while (true) {
        ...
            Message msg = queue.next();
        ...
        // 我汗啊… 竟然直接交給了target即發送這個消息的handler處理
           msg.target.dispatchMessage(msg);
           msg.recycle();
            }
        }
}
3、這麼簡單的問題竟然糾結了好久，只能感歎菜鳥真可怕
既然看到這了，就稍微看下dispatchMessage的邏輯吧
public void dispatchMessage(Message msg) {

        if (msg.callback != null) {
            handleCallback(msg);
        } else {
          if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
           }
            handleMessage(msg);
        }
}

--  如果msg.callback不為空，則調用handleCallback(msg);
callback是一個Runnable的實例，那麼什麼時候不為空呢？
|-  當調用 message 的obtain靜態方法來實例化Message的時候，會對這個Runnable賦值

public static Message obtain(Handler h, Runnable callback) {
    Message m = obtain();
    m.target = h;
    m.callback = callback;
    return m;
}
|-  更常用的方式
當Handler.post(Runnable r)的時候
public final boolean post(Runnable r) {
         return  sendMessageDelayed(getPostMessage(r), 0);
    }
        private final Message getPostMessage(Runnable r) {
            Message m = Message.obtain();
            m.callback = r;
            return m;
    }
這時候，handler  dispatch這個消息會直接調用Runnable中的run方法
這也是為什麼重寫的handlerMessage不對這種形式發送的消息進行處理
如果mCallback不為空，則調用mCallback.handleMessage方法
而這個Callback默認情況下為空，只有當調用
public Handler(Callback callback)或者public Handler(Looper looper, Callback callback)這兩種構造方法的時候才會被賦值
當然，一般使用handler處理消息都是為了與ui線程通信，而ui的looper是系統維護的，所以推薦第一種方式。
當dispatch消息的時候，會直接調用callback.handleMessage()方法
前邊兩個都為空的時候，才會調用Handler的handleMessage方法，如果沒有重寫，則調用系統默認的handleMessage，即什麼也不做

文章出處：http://blog.csdn.net/boliu123/article/details/6942057


/******************************************************************************/
String、StringBuilder和StringBuffer的區別
/******************************************************************************/
String 字串常量
StringBuffer 字串變數（線程安全）
StringBuilder 字串變數（非線程安全）
 簡要的說， String 類型和 StringBuffer 類型的主要性能區別其實在於 String 是不可變的對象, 因此在每次對 String 類型進行改變的時候其實都等同於生成了一個新的
 String對像，然後將指針指向新的 String 對像，所以經常改變內容的字串最好不要用 String ，因為每次生成對象都會對系統性能產生影響，特別當記憶體中無引用對像多
了以後， JVM 的 GC 就會開始工作，那速度是一定會相當慢的。
而如果是使用 StringBuffer 類則結果就不一樣了，每次結果都會對 StringBuffer 對像本身進行操作，而不是生成新的對象，再改變對像引用。所以在一般情況下我們推薦
使用 StringBuffer ，特別是字串對像經常改變的情況下。而在某些特別情況下， String 對象的字串拼接其實是被 JVM 解釋成了 StringBuffer 對象的拼接，所以這些時候
 String 對象的速度並不會比 StringBuffer 對像慢，而特別是以下的字串對像生成中， String 效率是遠要比 StringBuffer 快的：
String S1 = 「This is only a」 + 「 simple」 + 「 test」;
StringBuffer Sb = new StringBuilder(「This is only a」).append(「 simple」).append(「 test」);
你會很驚訝的發現，生成 String S1 對象的速度簡直太快了，而這個時候 StringBuffer 居然速度上根本一點都不佔優勢。其實這是 JVM 的一個把戲，在 JVM 眼裡，這個
String S1 = 「This is only a」 + 「 simple」 + 「test」; 其實就是：
String S1 = 「This is only a simple test」; 所以當然不需要太多的時間了。但大家這裡要注意的是，如果你的字串是來自另外的 String 對象的話，速度就沒那麼快了
，譬如：
String S2 = 「This is only a」;
String S3 = 「 simple」;
String S4 = 「 test」;
String S1 = S2 +S3 + S4;
這時候 JVM 會規規矩矩的按照原來的方式去做
在大部分情況下 StringBuffer > String
StringBuffer
Java.lang.StringBuffer線程安全的可變字元序列。一個類似於 String 的字串緩衝區，但不能修改。雖然在任意時間點上它都包含某種特定的字元序列，但通過某些方法調
用可以改變該序列的長度和內容。
可將字串緩衝區安全地用於多個線程。可以在必要時對這些方法進行同步，因此任意特定實例上的所有操作就好像是以串行順序發生的，該順序與所涉及的每個線程進行的方
法調用順序一致。
StringBuffer 上的主要操作是 append 和 insert 方法，可重載這些方法，以接受任意類型的數據。每個方法都能有效地將給定的數據轉換成字串，然後將該字串的字元追加
或插入到字串緩衝區中。append 方法始終將這些字元添加到緩衝區的末端；而 insert 方法則在指定的點添加字元。
例如，如果 z 引用一個當前內容是「start」的字串緩衝區對像，則此方法調用 z.append("le") 會使字串緩衝區包含「startle」，而 z.insert(4, "le") 將更改字串緩衝
區，使之包含「starlet」。
在大部分情況下 StringBuilder > StringBuffer
java.lang.StringBuilde
java.lang.StringBuilder一個可變的字元序列是5.0新增的。此類提供一個與 StringBuffer 相容的 API，但不保證同步。該類被設計用作 StringBuffer 的一個簡易替換，
用在字串緩衝區被單個線程使用的時候（這種情況很普遍）。如果可能，建議優先採用該類，因為在大多數實現中，它比 StringBuffer 要快。兩者的方法基本相同。
何時用StringBuffer、StringBuilder:
StringBuilder一般使用在方法內部來完成類似"+"功能,因為是線程不安全的,所以用完以後可以丟棄.StringBuffer要用在全局變數中
 
文章二：
關於這三個類在字串處理中的位置不言而喻，那麼他們到底有什麼優缺點，到底什麼時候該用誰呢？下面我們從以下幾點說明一下 
1.三者在執行速度方面的比較：StringBuilder >  StringBuffer  >  String 
2.String <（StringBuffer，StringBuilder）的原因 
　String：字串常量 
　StringBuffer：字元創變數 
　StringBuilder：字元創變數 
　從上面的名字可以看到，String是「字元創常量」，也就是不可改變的對象。對於這句話的理解你可能會產生這樣一個疑問  ，比如這段代碼： 
Java代碼  
String s = "abcd";  
s = s+1;  
System.out.print(s);// result : abcd1  
我們明明就是改變了String型的變數s的，為什麼說是沒有改變呢? 其實這是一種欺騙，JVM是這樣解析這段代碼的：首先創建對像s，賦予一個abcd，然後再創建一個新的對象
s用來執行第二行代碼，也就是說我們之前對像s並沒有變化，所以我們說String類型是不可改變的對象了，由於這種機制，每當用String操作字串時，實際上是在不斷的創建
新的對象，而原來的對象就會變為垃圾被ＧＣ回收掉，可想而知這樣執行效率會有多底。 
而StringBuffer與StringBuilder就不一樣了，他們是字串變數，是可改變的對象，每當我們用它們對字串做操作時，實際上是在一個對像上操作的，這樣就不會像String一樣
創建一些而外的對象進行操作了，當然速度就快了 
3.一個特殊的例子： 
Java代碼  
 1 String str = 「This is only a」 + 「 simple」 + 「 test」;  
 3 StringBuffer builder = new StringBuilder(「This is only a」).append(「 simple」).append(「 test」);  
　你會很驚訝的發現，生成str對象的速度簡直太快了，而這個時候StringBuffer居然速度上根本一點都不佔優勢。其實這是JVM的一個把戲，實際上： 
　String str = 「This is only a」 + 「 simple」 + 「test」; 
　其實就是： 
　String str = 「This is only a simple test」;
　所以不需要太多的時間了。但大家這裡要注意的是，如果你的字串是來自另外的String對象的話，速度就沒那麼快了，譬如：
　String str2 = 「This is only a」;
　String str3 = 「 simple」;
　String str4 = 「 test」;
　String str1 = str2 +str3 + str4;
　這時候JVM會規規矩矩的按照原來的方式去做。
4.StringBuilder與 StringBuffer 
　StringBuilder：線程非安全的 
　StringBuffer：線程安全的 
　當我們在字串緩衝去被多個線程使用是，JVM不能保證StringBuilder的操作是安全的，雖然他的速度最快，但是可以保證StringBuffer是可以正確操作的。當然大多數情況下就是我們是在單線程下進行的操作，所以大多數情況下是建議用StringBuilder而不用StringBuffer的，就是速度的原因。 

對於三者使用的總結： 
1.如果要操作少量的數據用 = String 
2.單線程操作字串緩衝區下操作大量數據 = StringBuilder 
3.多線程操作字串緩衝區下操作大量數據 = StringBuffer 


/******************************************************************************/
Data Storage in Android
/******************************************************************************/
以下資料來自於：
http://developer.android.com/guide/topics/data/data-storage.html

儲存的方法，基本上，要看你儲存要做什麼樣的用途？要不要分享給其他Ap使用？或者儲存資料的大小？這些都是考量點。 

Android儲存的方法有5種。 

1. Share Preferences：私密的(private)資料。使用Key-Value方式儲存
2. Internal storage：私密的資料，儲存在device memory上
3. External storage：公開的資料，儲存在external storage上
4. SQLite Database：結構化的資料，儲存在私密的database上
5. Network connection：儲存在Server上

基本上，私密的資料可以使用content provider 來分享資料給其他Ap。有興趣的人可以參與content provider相關資料。 


1. Share Preferences：

有兩種方法使用SharedPreferences物件。 
a. getSharedPreferences() ，需要多個preferences時使用，透過第一個參數name來判斷read/write的是那一個preferences 
b. getPreferences() ，單單使用一個preference，每一個Activity都會提供一個不用名稱的preference。 

把值寫入Preference有三步驟。 
a. 呼叫edit()得到SharedPreferences.Editor. 
b. 使用putBoolean() 和 putString().把值寫入 
c. 使用commit()更改其值。 

底下是Share Preference的範例。在OnCreate()中，取得silent的值，在OnStop()當中儲存silent的值。
public class Calc extends Activity {
    public static final String PREFS_NAME = "MyPrefsFile";

    @Override
    protected void onCreate(Bundle state){
       super.onCreate(state);
       . . .

       // Restore preferences
       SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
       boolean silent = settings.getBoolean("silentMode", false);
       setSilent(silent);
    }

    @Override
    protected void onStop(){
       super.onStop();

      // We need an Editor object to make preference changes.
      // All objects are from android.context.Context
      SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
      SharedPreferences.Editor editor = settings.edit();
      editor.putBoolean("silentMode", mSilentMode);

      // Commit the edits!
      editor.commit();
    }
}
2. Internal Storage

使用這方法，儲存的資料只會被你目前的Ap所使用，其他Ap無法使用。一旦Ap被移除，資料也將會被移除。 

寫入需要三步驟。 

a. openFileOutput()得到FileOutputStream. 
b. 使用write().寫入到檔案 
c. 使用close().關閉stream 

底下是範例。 
String FILENAME = "hello_file";
String string = "hello world!";
FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
fos.write(string.getBytes());
fos.close();openFileOutput()第二個參數代表開啟檔案的模式，MODE_PRIVATE代表這一個file只有被目前這一個AP所使用。 

讀取檔案也需要三步驟。 

a. 呼叫openFileInput()得到FileInputStream. 
b. 使用read().從檔案讀資料 
c. 使用close().關閉stream 

這邊另外值得一提的是，saving cache files。也就是，如果你想要暫時儲存某一個資料在Internal Storage使用的方法。 

使用getCacheDir() 去開啟一個File ，這一個File就會用來表示你的暫存資料將會放在那邊。 

3. External Storage

再使用External Storage之前，必需要先check external storage 狀態。 

使用getExternalStorageState()去check external storage狀態，有可能是missing or read-only等其他狀態，底下是範例： 
boolean mExternalStorageAvailable = false;
boolean mExternalStorageWriteable = false;
String state = Environment.getExternalStorageState();

if (Environment.MEDIA_MOUNTED.equals(state)) {
    // We can read and write the media
    mExternalStorageAvailable = mExternalStorageWriteable = true;
} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
    // We can only read the media
    mExternalStorageAvailable = true;
    mExternalStorageWriteable = false;
} else {
    // Something else is wrong. It may be one of many other states, but all we need
    //  to know is we can neither read nor write
    mExternalStorageAvailable = mExternalStorageWriteable = false;
}在存取external storage時。API 7或 API 8有些許的不同，這邊只討論API 8。 

使用getExternalFilesDir()去開啟一個File。這一個method的type將會用來指定哪一個子目錄是你要的，例如：DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（也可以指定null，null會把資料放在根目錄）。設定type好處在於，android的media scanner會適當的分類你的檔案（例如：ringtone就會是ringtone而不會是music）。使用這方法，如果ap被uninstall，檔案也會被移除。 

有另外一種方法，可以讓ap被uninstall，但是檔案仍然可以保存。 

使用getExternalStoragePublicDirectory()，至於type的設定和getExternalFilesDir()一樣。 

External Storage仍然有cache file的功能，使用getExternalCacheDir()。 

4. SQLite Database

建議的使用方法是，繼承SQLiteOpenHelper，並且override onCreate()，在onCreate()當中執行SQLite指令，去建立一個table。 

底下是範例： 
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = "dictionary";
    private static final String DICTIONARY_TABLE_CREATE =
                "CREATE TABLE " + DICTIONARY_TABLE_NAME + " (" +
                KEY_WORD + " TEXT, " +
                KEY_DEFINITION + " TEXT);";

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}之後你可以得到一個自己實做的instance，然後透過getWritableDatabase()和getReadableDatabase()去讀寫SQLite Database。 

可以透過query()去查詢資料，如果很複雜的查詢，可以透過SQLiteQueryBuilder，它有很多方便的method來幫助你。 

查詢回來的結果，回傳Cursor，可以透過它尋找查詢的結果。 

5. Network connection

兩個package，要自己看。 
java.net.*
android.net.*


/******************************************************************************/
學習筆記-翻譯資料：Android 2.3.3 近場通信NFC介紹（本人翻譯的）  from: http://blog.csdn.net/nicebooks/article/details/6223956
/******************************************************************************/
NFC(近場通信)
NFC是一套短距離的無線通信，通常距離是4厘米或更短。NFC工作頻率是13.56M Hz,傳輸速率是106kbit/s 到848kbit/s. NFC總是在一個發起者和一個被動目標之間發生。
發起者發出近場無線電波，這個近場可以給被動目標供電。這些被動的目標包括不需要電源的標籤，卡，也可以是有電源的設備。
與其他無線通信技術比較， 例如藍牙和WiFi， NFC提供更低帶寬和距離，並且低成本，不需要供電，不需要實現匹配，整個通信過程僅僅是短短的靠近一秒就能完成。
一個帶有NFC支援的android設備通常是一個發起者。也可以作為NFC的讀寫設備。他將檢測NFC tags並且打開一個Activity來處理. Android 2.3.3還有支援有限的P2P。

Tags分很多種，其中簡單的只提供讀寫段，有的只能讀。
複雜的tags可以支援一些運算，加密來控制對tags裡數據段的讀寫。
甚至一些tags上有簡單的作業系統，允許一些複雜的交互和可以執行一些代碼。

API概覽
Android.nfc  package包含頂層類用來與本地NFC適配器交互. 這些類可以表示被檢測到的tags和用NDEF數據格式。
Class
Description
NfcManager
一個NFC adapter的管理器，可以列出所有此android設備支援的NFC adapter.只不過大部分android 設備只有一個NFC adapter，所以你大部分情況下可以直接用靜態方法 getDefaultAdapter(context)來取適配器。
NfcAdapter
表示本設備的NFC adapter,可以定義Intent來請求將系統檢測到tags的提醒發送到你的Activity.並提供方法去註冊前台tag提醒發佈和前台NDEF推送。 前台NDEF推送是當前android版本唯一支援的p2p NFC通信方式。
NdefMessage and NdefRecord
NDEF是NFC論壇定義的數據結構，用來有效的存數據到NFC tags.比如文本，URL，和其他MIME類型。一個NdefMessage扮演一個容器，這個容器存哪些發送和讀到的數據。一個NdefMessage對像包含0或多個NdefRecord,每個NDEF record有一個類型，比如文本，URL，智慧型海報/廣告，或其他MIME數據。在NDEFMessage裡的第一個NfcRecord的類型用來發送tag到一個android設備上的activity.

Tag
標示一個被動的NFC目標，比如tag，card，鑰匙掛扣，甚至是一個電話模擬的的NFC卡.
當一個tag被檢測到，一個tag對像將被創建並且封裝到一個Intent裡，然後NFC 發佈系統將這個Intent用startActivity發送到註冊了接受這種Intent的activity裡。你可以用getTechList()方法來得到這個tag支援的技術細節和創建一個android.nfc.tech提供的相應的TagTechnology對象。
android.nfc.tech package 包含那些對tag查詢屬性和進行I/O操作的類。這些類分別標示一個tag支援的不同的NFC技術標準。

Class
Description
TagTechnology
這個介面是下面所有tag technology類必須實現的。
NfcA
支援ISO 14443-3A 標準的操作。Provides access to NFC-A (ISO 14443-3A) properties and I/O operations.
NfcB
Provides access to NFC-B (ISO 14443-3B) properties and I/O operations.
NfcF
Provides access to NFC-F (JIS 6319-4) properties and I/O operations.
NfcV
Provides access to NFC-V (ISO 15693) properties and I/O operations.
IsoDep
Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations.

Ndef
提供對那些被格式化為NDEF的tag的數據的訪問和其他操作。
Provides access to NDEF data and operations on NFC tags that have been formatted as NDEF.
NdefFormatable
對那些可以被格式化成NDEF格式的tag提供一個格式化的操作

MifareClassic
如果android設備支援MIFARE，提供對MIFARE Classic目標的屬性和I/O操作。
MifareUltralight
如果android設備支援MIFARE，提供對MIFARE Ultralight目標的屬性和I/O操作。
聲明Android Manifest.xml的元素
在你能訪問一個設備的NFC硬體和正確的處理NFC的Intent之前，需要在AndroidManifest.xml中先聲明下面的項：
1.     NFC使用 <uses-permission> 元素來訪問NFC硬體:
<uses-permission android:name="android.permission.NFC" />
2.     最小SDK版本需要設置正確，API level 9只包含有限的tag支援,包括：
    .通過ACTION_TAG_DISCOVERED來發佈Tag資訊
    .只有通過EXTRA_NDEF_MESSAGES擴展來訪問NDEF消息
    .其他的tag屬性和I/O操作都不支援
所以你可能想要用API level 10來實現對tag的廣泛的讀寫支援。
<uses-sdk android:minSdkVersion="10"/>
3.     uses-feature 元素定義：你的程式可以再android市場裡顯示有NFC硬體。
<uses-feature android:name="android.hardware.nfc" android:required="true" />
4.      NFC intent filter告訴android系統你的activity能處理NFC數據，可以定義1個或多個intent filter:
<intent-filter>
  <action android:name="android.nfc.action.NDEF_DISCOVERED"/>
  <data android:mimeType="mime/type" />
</intent-filter>
<intent-filter>
  <action android:name="android.nfc.action.TECH_DISCOVERED"/>
  <meta-data android:name="android.nfc.action.TECH_DISCOVERED"
                android:resource="@xml/nfc_tech_filter.xml" />
</intent-filter>

<intent-filter>
  <action android:name="android.nfc.action.TAG_DISCOVERED"/>
</intent-filter>
上邊3個intent filters 有優先級，更多資訊可以看下面的Tag發佈系統
也可以看NFCDemo例子的 AndroidManifest.xml來有個更深的理解。

Tag發佈系統
當android設備掃瞄到一個NFC tag，通用的行為是自動找最合適的Activity會處理這個tag Intent而不需要用戶來選擇哪個Activity來處理。因為設備掃瞄NFC tags是在很短的範圍和時間，如果讓用戶選擇的話，那就有可能需要移動設備，這樣將會打斷這個掃瞄過程。你應該開發你只處理需要處理的tags的Activity，以防止讓用戶選擇使用哪個Activity來處理的情況。Android提供兩個系統來幫助你正確的識別一個NFC tag是否是你的Activity想要處理的：Intent發佈系統和前台Activity發佈系統。
Intent發佈系統檢查所有Activities的intent filters，找出那些定義了可以處理此tag的Activity，如果有多個Activity都配置了處理同一個tag Intent，那麼將使用Activity選擇器來讓用戶選擇使用哪個Activity。用戶選擇之後，將使用選擇的Activity來處理此Intent.
前台發佈系統允許一個Activity覆蓋掉Intent發佈系統而首先處理此tag Intent，這要求你將要處理Tag Intent的Activity運行在前台，這樣當一個NFC tag被掃瞄到，系統先檢測前台的Activity是否支援處理此Intent，如果支援，即將此Intent傳給此Activity，如果不支援，則轉到Intent發佈系統。
使用Intent發佈系統
Intent發佈系統指定了3個intent有不同的優先級。通常當一個tag被檢測到之後，Intent就被啟動（start）了，這個啟動遵循以下行為:
•         android.nfc.action.NDEF_DISCOVERED: 這個intent是在一個包含NDEF負載的tag被檢測到時啟動，這是最高優先級的intent, android系統不會讓你指定一個Intent能處理所有的NFC數據類型，你必須在AndroidManifest.xml中指定與NFC tag對應的<data>元素，這樣當掃瞄到的tag傳過來的數據類型與你定義的相匹配時，你的Activity就會被調用。例如想處理一個包含plain text 的 NDEF_DISCOVERED intent ，你要按照如下定義AndroidManifest.xml file:
<intent-filter>
    <action android:name="android.nfc.action.NDEF_DISCOVERED"/>
    <data android:mimeType="text/plain" />
</intent-filter>
如果NDEF_DISCOVERED intent 已經被啟動，TECH_DISCOVERED 和 TAG_DISCOVERED intents 將不會被啟動。假如一個未知的tag或者不包含NDEF負載的tag被檢測到，此Intent就不會被啟動。
•         android.nfc.action.TECH_DISCOVERED: 如果 NDEF_DISCOVERED intent沒啟動或者沒有一個Activity的filter檢測NDEF_DISCOVERED ，並且此tag是已知的，那麼此TECH_DISCOVERED Intent將會啟動. TECH_DISCOVERED intent要求你在一個資源文件裡(xml)裡指定你要支援technologies列表。更多細節請看下面的Specifying tag technologies to handle.
•         android.nfc.action.TAG_DISCOVERED: 如果沒有一個activity處理_DISCOVERED and TECH_DISCOVERED intents或者tag被檢測為未知的，那麼此Intent將會被啟動。
Specifying tag technologies to handle指定處理的technologies
假如你的Activity在AndroidManifest.xml文件裡聲明了處理android.nfc.action.TECH_DISCOVERED intent ，你必須創建一個Xml格式的資源文件，並加上你的activity支援的technologies到tech-list集合裡。這樣你的activity將被認作能處理這些tech-list的處理者，如果tag使用的technology屬於你的定義的list裡，你的Activity將接收此Intent。你可以用getTechList()來獲得tag支援的technologies。
例如：如果一個tag被檢測到支援MifareClassic, NdefFormatable, 和 NfcA，你的tech-list集合必須指定了其中的一項或者多項來保證你的Activity能處理此Intent。
下面是一個資源文件例子，定義了所有的technologies. 你可以根據需要刪掉不需要的項，將此文件以任意名字+.xml保存到<project-root>/res/xml文件夾.
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <tech-list>
        <tech>android.nfc.tech.IsoDep</tech>
        <tech>android.nfc.tech.NfcA</tech>        
        <tech>android.nfc.tech.NfcB</tech>
        <tech>android.nfc.tech.NfcF</tech>
        <tech>android.nfc.tech.NfcV</tech>
        <tech>android.nfc.tech.Ndef</tech>
        <tech>android.nfc.tech.NdefFormatable</tech>
        <tech>android.nfc.tech.MifareClassic</tech>
        <tech>android.nfc.tech.MifareUltralight</tech>
    </tech-list>
</resources>

你也可以指定多個tech-list集合，每個集合都認做獨立的。如果任何單個tech-list集合是getTechList()返回的technologies集合的子集，那麼你的Activity將被認為匹配了。這個還提供』與』和』或』操作。下面的例子表示支援 NfcA和NDef的卡，或者支援NfcB和NDef的卡：
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <tech-list>
        <tech>android.nfc.tech.NfcA</tech>        
        <tech>android.nfc.tech.Ndef</tech>
    </tech-list>
</resources>

<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <tech-list>
        <tech>android.nfc.tech.NfcB</tech>        
        <tech>android.nfc.tech.Ndef</tech>
    </tech-list>
</resources>

在 AndroidManifest.xml 文件中, 指定這個tech-list資源文件的方法是在<activity> 元素中創建<meta-data>元素，例如下面例子:
<activity>
...
<intent-filter>
    <action android:name="android.nfc.action.TECH_DISCOVERED"/>
</intent-filter>

<meta-data android:name="android.nfc.action.TECH_DISCOVERED"
    android:resource="@xml/nfc_tech_filter" />
...
</activity>
使用前台發佈系統Using the foreground dispatch system
前台發佈系統允許一個Activity 攔截一個tag Intent 獲得最高優先級的處理，這種方式很容易使用和實現：
1.     添加下列代碼到Activity的onCreate() 方法裡
a.     創建一個 PendingIntent 對像, 這樣Android系統就能在一個tag被檢測到時定位到這個對象
PendingIntent pendingIntent = PendingIntent.getActivity(
    this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);
b.    在Intent filters裡聲明你想要處理的Intent，一個tag被檢測到時先檢查前台發佈系統，如果前台Activity符合Intent filter的要求，那麼前台的Activity的將處理此Intent。如果不符合，前台發佈系統將Intent轉到Intent發佈系統。如果指定了null的Intent filters，當任意tag被檢測到時，你將收到TAG_DISCOVERED intent。因此請注意你應該只處理你想要的Intent。
    IntentFilter ndef = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
        try {
            ndef.addDataType("*/*");    /* Handles all MIME based dispatches. 
                                           You should specify only the ones that you need. */
        }
        catch (MalformedMimeTypeException e) {
            throw new RuntimeException("fail", e);
        }
        intentFiltersArray = new IntentFilter[] {
                ndef,
        };
c.     設置一個你程式要處理的Tag technologies的列表，調用Object.class.getName() 方法來獲得你想要支援處理的technology類。

  techListsArray = new String[][] { new String[] { NfcF.class.getName() } };
 
2.     覆蓋下面的方法來打開或關閉前台發佈系統。比如onPause()和onResume（）方法。必須在主線程裡調用enableForegroundDispatch(Activity, PendingIntent, IntentFilter[], String[][]) 而且Activity在前台（可以在onResume()裡調用來保證這點）。你也要覆蓋onNewIntent回調來處理得到的NFC tag數據。
public void onPause() {
    super.onPause();
    mAdapter.disableForegroundDispatch(this);
}   

public void onResume() {
    super.onResume();
    mAdapter.enableForegroundDispatch(this, pendingIntent, intentFiltersArray, techListsArray);
}

public void onNewIntent(Intent intent) {
    Tag tagFromIntent = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
    //do something with tagFromIntent
}
See the ForegroundDispatch sample from API Demos for the complete sample.

使用NFC tag上的數據
NFC tag上的數據是以位元組存放，所以你可以將其轉換成其他你想要的格式。當往tag寫東西時，你必須以位元組格式來寫。Android提供API來幫助寫符合NDEF標準的資訊。使用此標準能保證你的數據在往tag寫時能被所有Android NFC設備支援。然而，很多tag使用他們自己的標準來存儲數據，這些標準也被Android支援。但你必須自己實現協定棧來讀寫這些tag。你可以在android.nfc.tech裡找到所有支援的technologies，並且可以在TagTechnology介面裡對technology有個瞭解。這一段是簡單介紹在android系統裡怎樣使用NDEF 消息。這不意味著是一個完整的NDEF功能的介紹。但標出了主要需要注意和使用的東西。
為了方便使用NDEF消息，android提供NdefRecord 和 NdefMessage來包裝原始位元組數據為NDEF消息。一個NdefMessage是保存0個或多個NdefRecords的容器。每個NdefRecord有自己的唯一類型名字格式，記錄類型和ID來與其他記錄區分開。你可以存儲不同類型的記錄，不同的長度到同一個 NdefMessage。NFC tag容量的限制決定你的NdefMessage的大小。
那些支援Ndef和NdefFormatable技術的tag可以返回和接受NdefMessage對像為參數來進行讀寫操作。你需要創建你自己的邏輯來為其他在android.nfc.tech的tag技術實現讀寫位元組的操作。
你可以從NFC Forum(http://www.nfc-forum.org/specs/)下載NDEF消息標準的技術文檔，比如純文本和智慧型海報. NFCDemo例子裡聲明了純文本和智慧型海報的NDef 消息。

讀一個NFC tag
當一個NFC tag靠近一個NFC設備，一個相應的Intent將在設備上被創建。然後通知合適的程式來處理此Intent。
下面的方法處理TAG_DISCOVERED intent並且使用迭代器來獲得包含在NDEF tag負載的數據
NdefMessage[] getNdefMessages(Intent intent) {
    // Parse the intent
    NdefMessage[] msgs = null;
    String action = intent.getAction();
    if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action)) {
        Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
        if (rawMsgs != null) {
            msgs = new NdefMessage[rawMsgs.length];
            for (int i = 0; i < rawMsgs.length; i++) {
                msgs[i] = (NdefMessage) rawMsgs[i];
            }
        }
        else {
        // Unknown tag type
            byte[] empty = new byte[] {};
            NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, empty, empty);
            NdefMessage msg = new NdefMessage(new NdefRecord[] {record});
            msgs = new NdefMessage[] {msg};
        }
    }        
    else {
        Log.e(TAG, "Unknown intent " + intent);
        finish();
    }
    return msgs;
}
請記住NFC設備讀到的數據是byte類型，所以你可能需要將他轉成其他格式來呈現給用戶。NFCDemo例子展示了怎樣用com.example.android.nfc.record中的類來解析NDEF消息，比如純文本和智慧型海報。

寫NFC tag
往NFC tag寫東西涉及到構造一個NDEF 消息和使用與tag匹配的Tag技術。下面的代碼展示怎樣寫一個簡單的文本到NdefFormatable tag：
NdefFormatable tag = NdefFormatable.get(t);
Locale locale = Locale.US;
final byte[] langBytes = locale.getLanguage().getBytes(Charsets.US_ASCII);
String text = "Tag, you're it!";
final byte[] textBytes = text.getBytes(Charsets.UTF_8);
final int utfBit = 0;
final char status = (char) (utfBit + langBytes.length);
final byte[] data = Bytes.concat(new byte[] {(byte) status}, langBytes, textBytes);
NdefRecord record = NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data);
try {
    NdefRecord[] records = {text};
    NdefMessage message = new NdefMessage(records);
    tag.connect();
    tag.format(message);
}
catch (Exception e){
    //do error handling
}

點對點的數據交換
前台推送技術支援簡單點對點的數據交換，你可以用enableForegroundNdefPush(Activity, NdefMessage) 方法來打開此功能. 為了用這個功能：
•         推送數據的Activity必須是前台Activity。
•         你必須將你要發送的數據封裝到NdefMessage對像裡。
•         接收推送數據的設備必須支援com.android.npp  NDEF推送協定，這個對於Android設備是可選的
假如你的Activity打開了前台推送功能並且位於前台，這時標準的Intent發佈系統是禁止的。然而，如果你的Activity允許前台發佈系統，那麼此時檢測tag的功能仍然是可用的，不過只適用於前台發佈系統。
要打開前台推送:
1.     創建一個你要推送給其他NFC設備的包含NdefRecords的NdefMessage。
2.     在你的Activity裡實現onResume() 和 onPause() 的回調來正確處理前台推送的生命週期。你必須在你的Activity位於前台並在主線程裡調用enableForegroundNdefPush(Activity, NdefMessage) （可以在onResume()裡調用來保證這點）.
public void onResume() {
    super.onResume();
    if (mAdapter != null)
        mAdapter.enableForegroundNdefPush(this, myNdefMessage);
}
public void onPause() {
    super.onPause();
    if (mAdapter != null)
        mAdapter.disableForegroundNdefPush(this);
}
當Activity位於前台，你可以靠近另外一個NFC設備來推送數據。請參考例子ForegroundNdefPush來瞭解點對點數據交


/******************************************************************************/
Android timer / sleep / delay / 更新 UI 的方法
/******************************************************************************/
目的:
Sleep / Delay 的功能
UI 卡住不能更新

Android 不能套用 Java or C 的 sleep 方法，列出幾種可以取代的方法
以下幾個方法都可以達到 "Delay" 的效果 (A1 -> (wait 10s) -> A2 -> (wait 10s) -> A3...)

Thread + sleep (Thread.sleep(xxx))
Handler (handler.postDelayed(Runnable, 2000);) => Call back 到 Runnable 的 run()
Timer (timer.schedule(TimerTask, 10000);) => Call back 到 TimerTask 的 run()
Thread + Handler
Timer + Handler
SystemClock.sleep(2000);
asynctask
Handlerthread
IntentService

若要更新 UI，可以在 UI/Main thread 或者 other thread:
Thread + Handler
Timer + Handler
Timer: postInvalidate (update a view when you're not in the current UI thread.) => http://blog.csdn.net/lixinso/archive/2009/06/23/4290432.aspx
Activity.runOnUiThread(Runnable) => http://lak4cyut.blogspot.com/2011/03/android-tip-activityrunonuithread.html
View.post(Runnable)
View.postDelayed(Runnable, long)
Handler / Timer 簡單的應用區分:
Handler: 
定期工作 & UI 更新 & Message dispatcher (與呼叫者處於同一線程; 可用 Message 與 Other thread 溝通)
對運行在不同線程中的多個任務進行排隊，並使用Message和Runnable對像安排這些任務。
HandlerThread:
由於採用Android Handler的post()方法並不能真正創建新的線程(參照博文：Handler.post()說明)，此處引入HandlerThread和Looper來創建新的線程。
HandlerThread繼承自Java的Thread類，HandlerThread用來創建持有一個Looper對象的線程，此Looper對象可以用來創建Handler對象。通過這種方式創建的Handler對像其start()方法一定會被調用。
Looper 直接繼承自Java的Object類，用來為一個線程維護一個消息循環隊列。線程自身默認是沒有消息隊列與其相關的；為了給線程創建消息循環隊列，要調用Looper的prepare()方法和loop()方法來創建及運行一個消息隊列。
參考:
http://www.zeroup.org/looper-by-handlerthread-and-create-a-new-thread.html
http://ytfei.iteye.com/blog/717227
http://water-e.blogspot.com/2009/04/android_23.html
http://oommoo.wordpress.com/2009/12/02/handler-%E8%88%87-handlerthread-%E5%8E%9F%E7%90%86/
http://blog.csdn.net/fenghome/archive/2010/06/17/5675421.aspx
Timer: 定期工作

Handler / Timer 使用的時機:
當 Delay or Sleep 用
類似迴圈的應用
定期觸發的定期行為
只要講到 Timer or Handler，一定會跟幾個名詞綁在一起: Thread / Handler / Timer / Timertask / Message / Looper / AsyncTask

參考 URL:

http://www.cnblogs.com/playing/archive/2011/03/24/1993583.html
http://ascii-iicsa.blogspot.com/2010/10/androidtimer.html
http://www.limodev.cn/blog/archives/1207
http://www.360doc.com/content/10/1216/10/1605498_78592393.shtml
http://sonyericssonss.blog.163.com/blog/static/10968396920104561215503/
http://www.cnblogs.com/crazypebble/archive/2011/03/23/1991829.html
http://caterpillar.onlyfun.net/Gossip/JavaGossip-V2/TimerTaskAndTimer.htm
http://developer.android.com/resources/articles/painless-threading.html
http://www.android1.net/Topic.aspx?BoardID=11&TopicID=651
http://ccanywhere.pixnet.net/blog/post/25520924
http://www.android123.com.cn/androidkaifa/422.html
http://jacky-google-android.blogspot.com/2010/07/thread.html


/******************************************************************************/
對藍牙profile的理解 (2012-07-15 16:10)
/******************************************************************************/
 藍牙profile協定概覽.pdf   
PS：從網上找的 http://blog.csdn.net/evilcode/  http://blog.sina.com.cn/samzhen1977
http://www.linuxidc.com/Linux/2011-09/43182.htm
 
之所以把Profile翻譯為配置文件,是為避免和JavaME中的簡表混淆.配置文件也是藍牙 SIG官方網站給出的標準翻譯.
想要使用藍牙無線技術,設備必須能夠翻譯特定藍牙配置文件,配置文件定義了可能的應用.
藍牙配置文件表達了一般行為,藍牙設備可以通過這些行為與其他設備進行通信.
藍牙技術定義了廣泛的配置文件,描述了許多不同類型的使用安全.按藍牙規格中提供的指導,開發商可創建應用程式以用來與其他符合藍牙規格的設備協同工作.
在最低限度下,各配置文件規格應包含下列主題的相關資訊.
１:與其他配置文件的相關性
２:建議的用戶界面格式
３:配置文件使用的藍牙協定堆棧的特定部分.
為執行其任務,每個配置文件都使用堆棧各層上的特定選項和參數.若需要,也可包括必需的服務記錄概要.

四種最基本的配置文件
1.通用訪問配置文件(Generic Access Profile, GAP)
    GAP是所有其他配置文件的基礎,它定義了在藍牙設備間建立基帶鏈路的通用方法.除此之外,GAP還定義了下列內容:
１:必須在所有藍牙設備中實施的功能
２:發現和鏈接設備的通用步驟
３:基本用戶界面術語.
GAP確保了應用程式和設備間的高度互操作性,還允許開發人員利用現有的定義更加容易地定義新的配置文件.GAP處理未連接的兩個設備間的發現和建立連接過程.此配置文件定義了一些通用的操作,這些操作可供引用GAP的配置文件,以及實施多個配置文件的設備使用.GAP確保了兩個藍牙設備可通過藍牙技術交換資訊,以發現彼此支援的應用程式.不符合任何其他藍牙配置文件的藍牙設備必須與GAP符合以確保基本的互操作性和共存.

2.服務發現應用配置文件(Service Discovery Application Profile, SDAP)
    SDAP描述了應用程式如何使用SDP發現遠端設備上的服務.由於GAP的要求,任何藍牙設備都應能夠連接至其他藍牙設備.基於此,SDAP要求任何應用程式都應當能夠發現它要連接的其他藍牙設備上的可用服務.此配置文件可承擔搜索已知和特定服務及一般的任務.SDAP涉及了稱為「服務發現用戶應用程式」的一個應用程式,這是藍牙設備查找服務所必需的.此應用程式可與向/從其他藍牙設備發送/接收服務查詢的SDP相接.SDAP依賴於GAP,並可以重新使用部分GAP.

3.串行連接埠配置文件(Serial Port Profile, SPP)
    SPP定義了如何設置虛擬串行連接埠及如何連接兩個藍牙設備.SPP基於ETSI TS 07.10規格,使用RFCOMM協定提供串行商品仿真.SPP提供了以無線方式替代現有的RS-232串行通信應用程式和控制信號的方法.SPP為DUN,FAX,HSP和LAN配置文件提供了基礎.此配置文件可以支援最高128kb/s的數據率.SPP依賴於GAP.

4.通用對像交換配置文件(Generic Object Exchange Profile, GOEP)
    GOEP可用於將對像從一個設備傳輸到另一個設備.對象可以是任意的.如:圖片,文檔,名片等.此配置文件定義了兩個角色:提供拉提或推送對像位置的伺服器及啟動操作的用戶端.使用GOEP的應用程式假定鏈路和信道已按GAP的定義建立.GOEP依賴於串行連接埠配置文件.
    GOEP為使用OBEX協定的其他配置文件提供了通用藍圖,並為設備定義了用戶端和伺服器角色.對於所有的OBEX事務.GOEP規定應由用戶端啟動所有事務.但是此配置文件並沒有描述應用程式就如何定義要交換的對象或如何實施交換.這些細節留給屬於GOEP的配置文件.即OPP,FTP和SYNC去完成.通常使用此配置文件的藍牙設備為筆記本電腦,PDA,手機及智慧電話.
注意:藍牙1.1版本規範所有藍牙設備的最小實現必須支援通用訪問配置文件,服務發現應用配置文件和串行連接埠配置文件.

PS2：
Bluetooth的一個很重要特性，就是所有的Bluetooth產品都無須實現全部的Bluetooth規範。為了更容易的保持Bluetooth設備之間的相容，Bluetooth規範中定義了Profile。Profile定義了設備如何實現一種連接或者應用，你可以把Profile理解為連接層或者應用層協定。
比如，如果一家公司希望它們的Bluetooth晶片支援所有的Bluetooth耳機，那麼它只要支援HeadSet Profile即可，而無須考慮該晶片與其它Bluetooth設備的通訊與相容性問題。如果你想購買Bluetooth產品，你應該瞭解你的應用需要哪些Profile來完成，並且確保你購買的Bluetooth產品支援這些Profile。
在所有的Profile中，有四種是基本的Profile，這些Profile會被其它的Profile使用。它們是：
GAP Profile: Generic Access Profile，該Profile保證不同的Bluetooth產品可以互相發現對方並建立連接。
SDAP Profile: Service Discovery Application Profile，通過該Profile，一個Bluetooth設備可以找到其它Bluetooth設備提供的服務，以及查詢相關的資訊。
SPP Profile: Serial Port Profile，模擬串口通訊
GOEP Profile: Generic Object Exchange Profile，通用對像交換。這個Profile的名字有些費解，它定義的是數據的傳輸，包括同步，文件傳輸，或者推送其它的數據。你可以把它理解為內容無關的傳輸層協定，可以被任何應用用來傳輸自己定義的數據對象。

另外，Bluetooth還定義了9種應用(usage)Profile。
CTP Profile: Cordless Telephone Profile，無繩電話。
IP Profile: Intercom Profile，這是在兩個設備之間建立語音連接，換句話說，把兩個昂貴的藍牙設備變成廉價的對講機。
HS Profile: HeadSet Profile，用於連接耳機。
DNP Profile: Dial-up Networking Profile，用於為PC提供撥號網路功能。
FP Profile: Fax Profile，傳真功能。
LAP Profile: LAN Access Profile，使用PPP協定建立局域網。
OPP Profile: Object Push Profile，用於設備之間傳輸數據對象。
FTP Profile: File Transfer Profile，用於文件傳輸。
SP Profile: Synchronization Profile，用於不同的Bluetooth設備同步，保持數據的一致性。

Bluetooth的Profile問題是相當複雜的，這些Profile規範在全部的Bluetooth規範中佔有了400頁的內容

Ｂｌｕｅｔｏｏｔｈ是一種短距離無線通訊傳輸介面，允許的傳輸距離長度設計為１０米到１００米，當含有Ｂｌｕｅｔｏｏｔｈ的手機 或電腦等 在多個含Ｂｌｕｅｔｏｏｔｈ裝置的環境中，設備尚未加入藍牙微網時，它會先進入待機狀態。在此狀態下，它會隨時監聽傳呼訊息，直到收到的信號與自己本身的識別碼有相關時，自己才會激活Ｂｌｕｅｔｏｏｔｈ服務 稱為Ｍａｓｔｅｒ 時，開始尋找外圍所有Ｂｌｕｅｔｏｏｔｈ裝置 稱為Ｓｌａｖｅ ，並且呼叫連結程式。接下來則進行識別碼的確認及信號時間的同步，以便決定往後跳頻之Ｓｅｑｕｅｎｃｅ，而將這些裝置連成一個群體，稱為微網 Ｐｉｃｏｎｅｔ 。可由Ｂｌｕｅｔｏｏｔｈ形成一個微網的方式來分享資料，可提供７－８個主動服務者 Ａｃｔｉｖｅ Ｓｌａｖｅ Ｄｅｖｉｃｅ 以及２５５個等待服務者 Ｓｔａｎｄｂｙ Ｓｌａｖｅ Ｄｅｖｉｃｅ 。為了維持資訊的傳送，微網內的其中一個裝置為此微網的主控裝置，而其它裝置則為從屬裝置。在微網內的任何一個裝置都可以成為主控裝置，但在任何時間中微網內只有一個主控裝置。Ｂｌｕｅｔｏｏｔｈ提供點對點或點對多的連結方式，各個Ｂｌｕｅｔｏｏｔｈ裝置連結建立都由Ｍａｓｔｅｒ來主控，在一個區域內，同時可以加入多個微網，這種多個微網架構所組成稱為疊網 Ｓｃａｔｔｅｒｎｅｔ 。
基本通訊硬體的機制能夠作點對點的傳輸，所以網路通訊能提供便利的、高層次的應用介面軟體。這軟體大部分處理低層次的通訊項目及自動化的程式。可較容易應用到通訊上，大部分的應用程式依靠網路軟體聯機。當傳送資料時，在複雜的通訊上必須取得一致的規格，此規格稱為協定 Ｐｒｏｔｏｃｏｌ 。以上已經提過了一些Ｂｌｕｅｔｏｏｔｈ相關的協定，在這裡為協定作詳細的說明： 
　　ａ．在物理層 Ｐｈｙｓｉｃａｌ 上為ＬＭＰ Ｌｉｎｋ ｍａｎａｇｅｒ Ｐｒｏｔｏｃｏｌ 協定，主控不同元件間的聯機控制、元件的連結狀態，傳輸封包的加解密和身份認證等。 
　　ｂ．Ｈｏｓｔ Ｃｏｎｔｒｏｌｌｅｒ Ｉｎｔｅｒｆａｃｅ用來界定Ｂｌｕｅｔｏｏｔｈ與Ｈｏｓｔ設備之間連結介面的控制指令。 
　　ｃ．Ｌ２ＣＡＰ Ｌｏｇｉｃａｌ Ｌｉｎｋ Ｃｏｎｔｒｏｌ ａｎｄ Ａｄａｐｔａｔｉｏｎ Ｐｒｏｔｏｃｏｌ 協定，負責對上層不同應用的軟體介面網路連結功能，而對應於不同的應用程式，此所謂多任務。另外也提供Ｍｕｌｔｉｐｌｅｘｉｎｇ、Ｑｕａｌｉｔｙ Ｏｆ Ｓｅｒｖｉｃｅ 服務品質 、封包切割 Ｓｅｇｍｅｎｔａｔｉｏｎ 與整合 Ｒｅａｓｓｅｍｂｌｙ 的等服務功能，將上層傳下來的資訊包整理成６４Ｋ位元組。 
　　ｄ．ＲＦＣＯＭＭ ＲＦ Ｃｏｍｍｕｎｉｃａｔｉｏｎ 協定，提供串行聯機的功能，類似ＲＳ２３２的控制信號與資料收發的信號。 
　　ｅ．ＴＣＳ Ｔｅｌｅｐｈｏｎｙ Ｃｏｎｔｒｏｌ Ｓｅｒｖｉｃｅ 協定，其中是二元化 ＴＣＳ ＢＩＮ ，負責電話聯機信號的建立控制 Ｃａｌｌ Ｃｏｎｔｒｏｌ 、移動漫遊管理 Ｍｏｂｉｌｉｔｙ Ｍａｎａｇｅｍｅｎｔ 。另外為ＡＴ指令 ＡＴ Ｃｏｍｍａｎｄ ，此用來讓手機 或電腦等 經由Ｂｌｕｅｔｏｏｔｈ連上的硬體介面來上網，此時也提供傳真的指令。 
　　ｆ．ＳＤＰ Ｓｅｒｖｉｃｅ Ｄｉｓｃｏｖｅｒｙ Ｐｒｏｔｏｃｏｌ 協定，其中包含服務的紀錄，主要記錄服務特性和身份認證。另外是描述有關服務發現後所要作的事情，主要建立一個通話聯機，所使用通話協定。 
　　ｇ．Ｐｒｏｆｉｌｅｓ ＡＰＩ層則分別對Ａｕｄｉｏ、Ｄａｔａ、Ｃｏｎｔｒｏｌ等提供了不同的模組。目前已規範有四大類、十三種協定規格。
　　ｈ．Ａｐｐｌｉｃａｔｉｏｎ則是依據語音、數據、控制等應用需求，提供應用軟體所需的通訊協定功能與應用程式介面。


/******************************************************************************/
NfcV(ISO 15693)讀寫操作         from: http://www.eoeandroid.com/home.php?mod=space&uid=638603&do=blog&id=4129
/******************************************************************************/
NfcV(ISO 15693)讀寫操作
package com.wanry;

import java.io.IOException;
import android.nfc.tech.NfcV;

/**
 * 
 * @author cloin
 * 用法
 * NfcV mNfcV = NfcV.get(tag);
 * mNfcV.connect();
 * NfcVUtil mNfcVutil = new NfcVUtil(mNfcV);
 * 取得UID
 * mNfcVutil.getUID();
 * 讀取block在1位置的內容
 * mNfcVutil.readOneBlock(1);
 * 從位置7開始讀2個block的內容
 * mNfcVutil.readBlocks(7, 2);
 * 取得block的個數
 * mNfcVutil.getBlockNumber();
 * 取得1個block的長度
 * mNfcVutil.getOneBlockSize();
 * 往位置1的block寫內容
 * mNfcVutil.writeBlock(1, new byte[]{0, 0, 0, 0})
 */
public class NfcVUtil {
    private NfcV mNfcV;
    /**UID數組行式*/
    private byte[] ID;
    private String UID;
    private String DSFID;
    private String AFI;
    /**block的個數*/
    private int blockNumber;
    /**一個block長度*/
    private int oneBlockSize;
    /**資訊*/
    private byte[] infoRmation;
    /**
     * 初始化
     * @param mNfcV NfcV對像
     * @throws IOException
     */
    public NfcVUtil(NfcV mNfcV) throws IOException{
        this.mNfcV = mNfcV;
        ID = this.mNfcV.getTag().getId();
        byte[] uid = new byte[ID.length];
        int j = 0;
        for(int i = ID.length - 1; i >=0; i-- ){
        uid[j] = ID[i];
        j++;
        }
        this.UID = printHexString(uid);
        getInfoRmation();
    }
    public String getUID() {
        return UID;
    }

    /**
     * 取得標籤資訊
     */
    private byte[] getInfoRmation() throws IOException{
        byte[] cmd = new byte[10];
        cmd[0] = (byte) 0x22; // flag
        cmd[1] = (byte) 0x2B; // command
        System.arraycopy(ID, 0, cmd, 2, ID.length); // UID
        infoRmation = mNfcV.transceive(cmd);
        blockNumber = infoRmation[12];
        oneBlockSize = infoRmation[13];
        AFI = printHexString(new byte[]{infoRmation[11]});
        DSFID = printHexString(new byte[]{infoRmation[10]});
        return infoRmation;
    }

    public String getDSFID() {
        return DSFID;
    }

    public String getAFI() {
        return AFI;
    }
    public int getBlockNumber(){
        return blockNumber + 1;
    }

    public int getOneBlockSize() {
        return oneBlockSize + 1;
    }

    /**
     * 讀取一個位置在position的block
     * @param position 要讀取的block位置
     * @return 返回內容字串
     * @throws IOException
     */
    public String readOneBlock(int position) throws IOException{
        byte cmd[] = new byte[11];
        cmd[0] = (byte) 0x22;
        cmd[1] = (byte) 0x20;
        System.arraycopy(ID, 0, cmd, 2, ID.length); // UID
        cmd[10] = (byte) position;
        byte res[] = mNfcV.transceive(cmd);
        if(res[0] == 0x00){
        byte block[] = new byte[res.length - 1];
        System.arraycopy(res, 1, block, 0, res.length - 1);
        return printHexString(block);
        }
        return null;
    }
    /**
     * 讀取從begin開始end個block
     * begin + count 不能超過blockNumber
     * @param begin block開始位置
     * @param count 讀取block數量
     * @return 返回內容字串
     * @throws IOException
     */
    public String readBlocks(int begin, int count) throws IOException{
        if((begin + count) > blockNumber){
            icount = blockNumber - begin;
        }
            StringBuffer data = new StringBuffer();
            for(int i = begin; i < count + begin; i++){
            data.append(readOneBlock(i));
        }
        return data.toString();
    }

    /**
     * 將byte[]轉換成16進制字串
     * @param data  要轉換成字串的位元組數組
     * @return 16進制字串
     */
    private String printHexString(byte[] data) {
        StringBuffer s = new StringBuffer();;
        for (int i = 0; i < data.length; i++) {
            String hex = Integer.toHexString(data[i] & 0xFF);
            if (hex.length() == 1) {
                hex = '0' + hex;
            }
            s.append(hex);
        }
        return s.toString();
    }
    /**
     * 將數據寫入到block,
     * @param position 要寫內容的block位置
     * @param data 要寫的內容,必須長度為blockOneSize
     * @return false為寫入失敗，true為寫入成功
     * @throws IOException
     */
    public boolean writeBlock(int position, byte[] data) throws IOException{
        byte cmd[] = new byte[15];
        cmd[0] = (byte) 0x22;
        cmd[1] = (byte) 0x21;
        System.arraycopy(ID, 0, cmd, 2, ID.length); // UID
        //block
        cmd[10] = (byte) 0x02;
        //value
        System.arraycopy(data, 0, cmd, 11, data.length);
        byte[]rsp = mNfcV.transceive(cmd);
        if(rsp[0] == 0x00)
        return true;
        return false;
    }
}


/******************************************************************************/
// NFC tag write NDEF format for BLUETOOTH Simple pairing. (ISO 14443)
/******************************************************************************/
SB701                        創傑                            YoFree                         Nokia bluetooth+nfc
Mac: 00 17 53 03 80 01       Mac: 00 11 67 FD C2 AF          Mac: 20 74 8A 00 FD 16         Mac: 00 0D FD 47 4D B0
0x00 3EA99ADD |    |         0x00 04E23C52 |    |            0x00 053400b9 |    |           0x00 053400B9 |    |
0x01 D0880400 |    |         0x01 EA7B2880 |    |            0x01 028b163b |    |           0x01 002121BC |    |
0x02 468F3513 |    |         0x02 39480000 |    |            0x02 a4000000 |    |           0x02 BC00FFFF |    |
0x03 59402110 |    |         0x03 E1101200 |    |            0x03 e1101000 |    |           0x03 E111100F |    |
0x04 140103E1 |    |         0x04 033BDA20 |    |            0x04 0348d220 |    |           0x04 01039014 |....|
0x05 03E103E1 |    |         0x05 16016170 |  ap|            0x05 25617070 | app|           0x05 24020393 |$...|
0x06 03E103E1 |    |         0x06 706C6963 |plic|            0x06 6c696361 |clia|           0x06 05040351 |...Q|
0x07 03E103E1 |    |         0x07 6174696F |atio|            0x07 74696f6e |tion|           0x07 91020A48 |...H|
0x08 03E103E1 |    |         0x08 6E2F766E |n/vn|            0x08 2f766e64 |/vnd|           0x08 7312D102 |s...|
0x09 03E103E1 |    |         0x09 642E626C |d.bl|            0x09 2e626c75 |.blu|           0x09 04616301 |.ac.|
0x0A 03E103E1 |    |         0x0A 7565746F |ueto|            0x0A 65746f6f |etoo|           0x0A 0130005A |.0.Z|
0x0B 03E103E1 |    |         0x0B 6F74682E |oth.|            0x0B 74682e65 |th.e|           0x0B 201D0161 | ..a|
0x0C 00000346 |    |         0x0C 65702E6F |ep.o|            0x0C 702e6f6f |p.oo|           0x0C 70706C69 |ppli|
0x0D DA202101 |    |         0x0D 6F623016 |ob0 |            0x0D 62250016 |b   |           0x0D 63617469 |cati|
0x0E 6170706C |appl|         0x0E 00AFC2FD |    |            0x0E fd008a74 |    |           0x0E 6F6E2F76 |on/v|
0x0F 69636174 |icat|         0x0F 6711000D |    |            0x0F 20170942 |   B|           0x0F 6E642E62 |nd.b|
0x10 696F6E2F |ion/|         0x10 09495353 | ISS|            0x10 6c756574 |luet|           0x10 6C756574 |luet|
0x11 766E642E |vnd.|         0x11 435F4E46 |C_NF|            0x11 6f6f7468 |ooth|           0x11 6F6F7468 |ooth|
0x12 626C7565 |blue|         0x12 435F5441 |C_TA|            0x12 20537465 | Ste|           0x12 2E65702E |.ep.|
0x13 746F6F74 |toot|         0x13 47FE0000 |G   |            0x13 72656f20 |reo |           0x13 6F6F6230 |oob0|
0x14 682E6570 |h.ep|         0x14          |    |            0x14 41756469 |Audi|           0x14 1D00B04D |...M|
0x15 2E6F6F62 |.oob|         0x15          |    |            0x15 6f040d14 |o   |           0x15 47FD0D00 |G...|
0x16 30210001 |0   |         0x16          |    |            0x16 2400fe00 |    |           0x16 0F094E6F |..No|
0x17 80035317 |    |         0x17          |    |            0x17          |    |           0x17 6B696120 |kia |
0x18 000D0953 |   S|         0x18          |    |            0x18          |    |           0x18 506C6179 |Play|
0x19 42373031 |B701|         0x19          |    |            0x19          |    |           0x19 20333630 | 360|
0x1A 20343236 | 426|         0x1A          |    |            0x1A          |    |           0x1A 040D1404 |....|
0x1B 35353004 |550 |         0x1B          |    |            0x1B          |    |           0x1B 20FE0000 | ...|
0x1C 0D040420 |    |         0x1C          |    |            0x1C          |    |           0x1C          |    |
0x1D 05031E11 |    |         0x1D          |    |            0x1D          |    |           0x1D          |    |
0x1E 0B11FE00 |    |         0x1E          |    |            0x1E          |    |           0x1E          |    |

    // NDEF recode header
    03  
    // Record type Length
    49

    // NDEF recode header
    da 
    // Record Type ength
    20
    // Plyload length
    24
    // Payload ID Length
    01
    // Record type Name(application/vnd.bluetooth.ep.oob)
    6170706c69636174696f6e2f766e642e626c7565746f6f74682e65702e6f6f62
    // Payload ID
    30

    // Bluetooth OOB data Len
    2400
    // Bluetooth Mac Addr.(00:17:53:03:80:e0)
    e08003531700

    // EIR Data Length
    10
    // EIR Data Type(Complete Local Name)
    09
    // Bluetooth Device Name(Amphitheater BT)
    416d70686974686561746572204254

    // EIR data Length
    04
    // EIR Data type(Class of Device)
    0d
    // Class of Device
    040420

    // EIR Data Length
    05
    // EIR Data Type
    03
    1e110b11

    // END
    fe

/******************************************************************************/
// NXP TYPE-2 format Bluetooth Pairing data 
/******************************************************************************/
00  04aa9cba            UID
01  a26b2b80            Serial Number( 10 bytes) = 04aa9cbaa26b2b806448
02  62480000            Lock (2 bytes) = 0000
03  e1101200            CC (4 bytes) 
04  0103a010            TLV(Lock Control(01+03+3bytes)
05  44035c9a            TLV(NDEF Message = 03 + Len + NDEF message)
06  20170161  ...a      application/vnd.bluetooth.ep.oob
07  70706c69  ppli
08  63617469  cati
09  6f6e2f76  on/v
10  6e642e62  nd.b
11  6c756574  luet
12  6f6f7468  ooth
13  2e65702e  .ep.
14  6f6f6230  oob0
15  17000100  xxxx
16  35531700  xx  
17  03095331  .S1
18  040d0404
19  2005031e
20  110b1154
21  0f0e616e  ..an      excute APP.
22  64726f69  droi
23  642e636f  d.co
24  6d3a706b  m:pk
25  67636f6d  gcom
26  2e6a732e  .js.
27  73706561  spea
28  6b6572fe  ker
29  00000000


/******************************************************************************/
// TI Type4 NDEF format. Bluetooth Pairing.
/******************************************************************************/
The capability container and NDEF message should be formatted as shown in the code snippet below for an
example Bluetooth OOB connection handover.
unsigned char NDEF_Application_Data[] =
{
    //NDEF Tag Application Name
    0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01,

    //Capability Container ID
    0xE1, 0x03,
    //Capability Container
    0x00, 0x0F, //CCLEN
    0x20, //Mapping version 2.0
    0x00, 0x3B, //MLe (49 bytes); Maximum R-APDU data size
    0x00, 0x34, //MLc (52 bytes); Maximum C-APDU data size
    0x04, //Tag, File Control TLV (4 = NDEF file)
    0x06, //Length, File Control TLV (6 = 6 bytes of data for this tag)
    0xE1, 0x04, //File Identifier
    0x0C, 0x02, //Max NDEF size (3072 bytes)
    0x00, //NDEF file read access condition, read access without any security
    0x00, //NDEF file write access condition; write access without any security

    //NDEF File ID
    0xE1, 0x04,
    0x00, 0x44, // NLEN; NDEF length (68 byte long message)
    0xD2, //MB=1b, ME=1b, CF=0b, SR=1b, IL=0b, TNF=010b
    0x20, //Record Type Length: 32 octets
    0x21, //payload length: 33 octets;
    0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x76,
    0x6E, 0x64, 0x2E, 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F, 0x74, 0x68, 0x2E,
    0x65, 0x70, 0x2E, 0x6F, 0x6F, 0x62, //Record Type Name: application/vnd.bluetooth.ep.oob
    0x21, 0x00, //OOB optional data length: 33 octets
    0x06, 0x05, 0x04, 0x03, 0x02, 0x01, //bluetooth device address:01:02:03:04:05:06 (example address only)
    0x0D, //EIR Data Length: 13 octets
    0x09, //EIR Data Type: Complete Local Name
    0x48, 0x65, 0x61, 0x64, 0x53, 0x65, 0x74, 0x20, 0x4E, 0x61,0x6D, 0x65, //Bluetooth Local Name: HeadSet Name
    0x04, //EIR Data Length: 4 octets
    0x0D, //EIR Data Type: Class of device
    0x04, 0x04, 0x20, //Class of Device: 0x20:Service Class=Audio, 0x04:Major Device Class=Audio/Video, 0x04: Minor Device Class=Wearable Headset Device
    0x05, //EIR Data Length: 5 octets
    0x03, //EIR Data type: 16-bit Service Class UUID list (complete)
    0x1E, 0x11, 0x0B, 0x11 //16-bit Service Class UUID list (complete) ;0x111E – HFP-HF, 0x011B – A2DP-SNK
}

/******************************************************************************/
// NDEF Empty Data in Type4
/******************************************************************************/
    0xD2, 0x76, 0x00, 0x00, 
    0x85, 0x01, 0x01, 0xE1, 
    0x03, 0x00, 0x0F, 0x20, 
    0x00, 0x3B, 0x00, 0x34,
     
    0x04, 0x06, 0xE1, 0x04, 
    0x0C, 0x02, 0x00, 0x00, 

    //NDEF File ID
    0xE1, 0x04, 0x00, 0x00, 0xD0, 0x00, 0x00


/******************************************************************************/
Android NDK Hello       from: http://rritw.com/a/JAVAbiancheng/ANT/20121104/248032.html
/******************************************************************************/
前段時間，工作中需要用android的應用程式訪問android的根文件系統中的文件，但是由於應用程式的權限限制，無法訪問這些文件，怎麼辦？ 
所以這就要用到了NDK編程了，既用C/C++代碼實現訪問系統文件，並將其生成本地庫，供android中的java代碼調用，這樣就可以在java代碼中通過調用C/C++編寫的庫的介面
來實現對系統文件的訪問。
 
下面就介紹下Android NDK的入門學習過程：
入門的最好辦法就是學習Android自帶的例子， 這奡N通過學習Android的NDK自帶的demo程式：hello-jni來達到這個目的。
一、 開發環境的搭建
android的NDK開發需要在linux下進行： 因為需要把C/C++編寫的代碼生成能在arm上運行的.so文件，這就需要用到交叉編譯環境，而交叉編譯需要在linux系統下才能完成。
安裝android-ndk開發包，這個開發包可以在google android 官網下載： 通過這個開發包的工具才能將android jni 的C/C++的代碼編譯成庫
android應用程式開發環境： 包括eclipse、java、 android sdk、 adt等。
如何下載和安裝android-ndk我這奡N不囉嗦了，安裝完之後，需要將android-ndk的路勁加到環境變數PATH中：
sudo gedit /etc/environment
在environment的PATH環境變數中添加你的android-ndk的安裝路勁，然後再讓這個更改的環境變數立即生效：
 source  /etc/environment
經過了上述步驟，在命令行下敲：
ndk-bulid
彈出如下的錯誤，而不是說ndk-build not found，就說明ndk環境已經安裝成功了。
Android NDK: Could not find application project directory !    
Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.    
/home/braincol/workspace/android/android-ndk-r5/build/core/build-local.mk:85: *** Android NDK: Aborting    .  Stop.
 
二、代碼的編寫
1.首先是寫java代碼
建立一個Android應用工程HelloJni，創建HelloJni.java文件：
HelloJni.java :
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.example.hellojni;

import android.app.Activity;
import android.widget.TextView;
import android.os.Bundle;

public class HelloJni extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        /* Create a TextView and set its content.
         * the text is retrieved by calling a native
         * function.
         */
        TextView  tv = new TextView(this);
        tv.setText( stringFromJNI() );
        setContentView(tv);
    }

    /* A native method that is implemented by the
     * 'hello-jni' native library, which is packaged
     * with this application.
     */
    public native String  stringFromJNI();

    /* This is another native method declaration that is *not*
     * implemented by 'hello-jni'. This is simply to show that
     * you can declare as many native methods in your Java code
     * as you want, their implementation is searched in the
     * currently loaded native libraries only the first time
     * you call them.
     *
     * Trying to call this function will result in a
     * java.lang.UnsatisfiedLinkError exception !
     */
    public native String  unimplementedStringFromJNI();

    /* this is used to load the 'hello-jni' library on application
     * startup. The library has already been unpacked into
     * /data/data/com.example.HelloJni/lib/libhello-jni.so at
     * installation time by the package manager.
     */
    static {
        System.loadLibrary("hello-jni");
    }
}

這段代碼很簡單，註釋也很清晰，這堨u提兩點：:
static{ 
    System.loadLibrary("hello-jni"); 
}
表明程式開始運行的時候會加載hello-jni, static區聲明的代碼會先於onCreate方法執行。如果你的程式中有多個類，而且如果HelloJni這個類不是你應用程式的入口，那麼
hello-jni（完整的名字是libhello-jni.so）這個庫會在第一次使用HelloJni這個類的時候加載。
public native String stringFromJNI(); 
public native String unimplementedStringFromJNI();
可以看到這兩個方法的聲明中有 native 關鍵字， 這個關鍵字表示這兩個方法是本地方法，也就是說這兩個方法是通過本地代碼（C/C++）實現的，在java代碼中僅僅是聲明。
用eclipse編譯該工程，生成相應的.class文件，這步必須在下一步之前完成，因為生成.h文件需要用到相應的.class文件。
 
2. 編寫相應的C/C++代碼
剛開始學的時候，有個問題會讓人很困惑，相應的C/C++代碼如何編寫，函數名如何定義？ 
這媮縣@個方法，利用javah這個工具生成相應的.h文件，然後根據這個.h文件編寫相應的C/C++代碼。
2.1 生成相應.h文件：
就拿我這的環境來說，首先在終端下進入剛剛建立的HelloJni工程的目錄：
braincol@ubuntu:~$ cd workspace/android/NDK/hello-jni/
ls查看工程文件
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls 
AndroidManifest.xml  assets  bin  default.properties  gen  res  src 
可以看到目前僅僅有幾個標準的android應用程式的文件（夾）。
首先我們在工程目錄下建立一個jni文件夾：
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ mkdir jni 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls 
AndroidManifest.xml  assets  bin  default.properties  gen  jni  res  src 
下面就可以生成相應的.h文件了：
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ javah -classpath bin -d jni com.example.hellojni.HelloJni 
-classpath bin：表示類的路勁
-d jni: 表示生成的頭文件存放的目錄
com.example.hellojni.HelloJni 則是完整類名
這一步的成功要建立在已經在 bin/com/example/hellojni/  目錄下生成了 HelloJni.class的基礎之上。
現在可以看到jni目錄下多了個.h文件：
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd jni/ 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ ls 
com_example_hellojni_HelloJni.h
我們來看看com_example_hellojni_HelloJni.h的內容：
com_example_hellojni_HelloJni.h :
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_hellojni_HelloJni */

#ifndef _Included_com_example_hellojni_HelloJni
#define _Included_com_example_hellojni_HelloJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_example_hellojni_HelloJni
 * Method:    stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
  (JNIEnv *, jobject);

/*
 * Class:     com_example_hellojni_HelloJni
 * Method:    unimplementedStringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
上面代碼中的JNIEXPORT 和 JNICALL 是jni的宏，在android的jni中不需要，當然寫上去也不會有錯。
從上面的源碼中可以看出這個函數名那是相當的長啊。。。。 不過還是很有規律的， 完全按照：java_pacakege_class_mathod 形式來命名。
也就是說：
Hello.java中 stringFromJNI() 方法對應於 C/C++中的 Java_com_example_hellojni_HelloJni_stringFromJNI() 方法
HelloJni.java中的 unimplementedStringFromJNI() 方法對應於 C/C++中的 Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI() 方法 
注意下其中的註釋：
Signature: ()Ljava/lang/String; 
()Ljava/lang/String;
()表示函數的參數為空（這堿高贗O指除了JNIEnv *, jobject 這兩個參數之外沒有其他參數，JNIEnv*, jobject是所有jni函數必有的兩個參數，分別表示jni環境和對應的
java類（或對像）本身），
Ljava/lang/String; 表示函數的返回值是java的String對象。
 
2.2 編寫相應的.c文件：
hello-jni.c :
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include <string.h>
#include <jni.h>

/* This is a trivial JNI example where we use a native method
 * to return a new VM String. See the corresponding Java source
 * file located at:
 *
 *   apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java
 */
jstring Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )
{
    return (*env)->NewStringUTF(env, "Hello from JNI !");
}
這堨u是實現了Java_com_example_hellojni_HelloJni_stringFromJNI方法，而 Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI 方法並沒有實現，因為
在HelloJni.java中只調用了stringFromJNI()方法，所以unimplementedStringFromJNI()方法沒有實現也沒關係，不過建議最好還是把所有java中定義的本地方法都實現了，
寫個空函數也行啊。。。有總比沒有好。
Java_com_example_hellojni_HelloJni_stringFromJNI() 函數只是簡單的返回了一個內容為 "Hello from JNI !" 的jstring對像（對應於java中的String對像）。
hello-jni.c文件已經編寫好了，現在可以把com_example_hellojni_HelloJni.h文件給刪了，當然留著也行，只是我還是習慣把不需要的文件給清理幹淨了。
 
3. 編譯hello-jni.c 生成相應的庫
3.1 編寫Android.mk文件
在jni目錄下（即hello-jni.c 同級目錄下）新建一個Android.mk文件，Android.mk 文件是Android 的 makefile文件，內容如下：
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := hello-jni
LOCAL_SRC_FILES := hello-jni.c
include $(BUILD_SHARED_LIBRARY)

這個Androd.mk文件很短，下面我們來逐行解釋下：
LOCAL_PATH := $(call my-dir)
一個Android.mk 文件首先必須定義好LOCAL_PATH變數。它用於在開發樹中查找源文件。在這個例子中，宏函數"my-dir", 由編譯系統提供，用於返回當前路徑
（即包含Android.mk file文件的目錄）。
include $( CLEAR_VARS)
CLEAR_VARS由編譯系統提供，指定讓GNU MAKEFILE為你清除許多LOCAL_XXX變數（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等...), 
除LOCAL_PATH 。這是必要的，因為所有的編譯控制文件都在同一個GNU MAKE執行環境中，所有的變數都是全局的。
LOCAL_MODULE := hello-jni
編譯的目標對像，LOCAL_MODULE變數必須定義，以標識你在Android.mk文件中描述的每個模組。名稱必須是唯一的，而且不包含任何空格。
注意：編譯系統會自動產生合適的前綴和後綴，換句話說，一個被命名為'hello-jni'的共享庫模組，將會生成'libhello-jni.so'文件。
重要注意事項：
如果你把庫命名為"libhello-jni"，編譯系統將不會添加任何的lib前綴，也會生成 'libhello-jni.so'，這是為了支援來源於Android平台的源代碼的Android.mk文件，
如果你確實需要這麼做的話。
LOCAL_SRC_FILES := hello-jni.c
LOCAL_SRC_FILES變數必須包含將要編譯打包進模組中的C或C++源代碼文件。注意，你不用在這埵C出頭文件和包含文件，因為編譯系統將會自動為你找出依賴型的文件；僅僅
列出直接傳遞給編譯器的源代碼文件就好。
注意，默認的C++源碼文件的擴展名是".cpp" . 指定一個不同的擴展名也是可能的，只要定義LOCAL_DEFAULT_CPP_EXTENSION變數，不要忘記開始的小圓點（也就是".cxx",
而不是".cxx" ）
include $(BUILD_SHARED_LIBRARY)
BUILD_SHARED_LIBRARY表示編譯生成共享庫，是編譯系統提供的變數，指向一個GNU Makefile腳本，負責收集自從上次調用'include $(CLEAR_VARS)'以來，定義在LOCAL_XXX變數中的所有資訊，並且決定編譯什麼，如何正確地去做。還有 BUILD_STATIC_LIBRARY變數表示生成靜態庫：lib$(LOCAL_MODULE).a， BUILD_EXECUTABLE 表示生成可執行文件。
 
3.2 生成.so共享庫文件
Andro文件已經編寫好了，現在可以用android NDK開發包中的 ndk-build腳本生成對應的.so共享庫了，方法如下：
braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ cd .. 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls 
AndroidManifest.xml  assets  bin  default.properties  gen  jni  libs  obj  res  src 
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ndk-build 
Gdbserver      : [arm-linux-androideabi-4.4.3] libs/armeabi/gdbserver 
Gdbsetup       : libs/armeabi/gdb.setup 
Install        : libhello-jni.so => libs/armeabi/libhello-jni.so 
可以看到已經正確的生成了libhello-jni.so共享庫了， 我們去 libs/armeabi/ 目錄下看看：
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd libs/ 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ ls 
armeabi 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ cd armeabi/ 
braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs/armeabi$ ls 
gdbserver  gdb.setup  libhello-jni.so
4. 在eclipse重新編譯HelloJni工程，生成apk
eclipse中刷新下HelloJni工程，重新編譯生成apk，libhello-jni.so共享庫會一起打包在apk文件內。


/******************************************************************************/
Windows下NDK開發環境的搭建(Cygwin+Android-SDK+NDK) ref: http://hi.baidu.com/j_key/item/bdfe28f6b1758ad56325d259
/******************************************************************************/
一：什麼是NDK？
NDK 提供了一系列的工具，幫助開發者快速開發C（或C++）的動態庫，並能自動將so 和java 應用一起打包成apk。這些工具對開發者的幫助是巨大的。
NDK 集成了交叉編譯器，並提供了相應的mk 文件隔離CPU、平台、ABI 等差異，開發人員只需要簡單修改mk 文件（指出「哪些文件需要編譯」、「編譯特性要求」等），就可
以創建出so。NDK 可以自動地將so 和Java 應用一起打包，極大地減輕了開發人員的打包工作。比較簡單的說，NDK是一套交叉編譯工具，它可以幫你把你用C或C++書寫的代碼
，編譯為.so（類似與win下的.dll）格式的文件，使你可以在你的Android程式當中用Java語言（JNI）調用這些代碼.
二：下載安裝cygwin
由於NDK編譯代碼時必須要用到make和gcc，所以你必須先搭建一個linux環境， cygwin是一個在windows平台上運行的unix模擬環境,它對於學習unix/linux操作環境，或者從
unix到windows的應用程式移植，非常有用。通過它，你就可以在不安裝linux的情況下使用NDK來編譯C、C++代碼了。下面我們一步一步的安裝cygwin吧。

首先，你得先跑到http://www.cygwin.com下載setup.exe(我已經下載)
1、 然後雙擊運行吧，運行後你將看到安裝嚮導界面：
2、  點擊下一步
此時讓你選擇安裝方式：
1）Install from Internet：直接從Internet上下載並立即安裝（安裝完成後，下載好的安裝文件並不會被刪除，而是仍然被保留，以便下次再安裝）。(好久了,應該是這個)
2）Download Without Installing：只是將安裝文件下載到本地，但暫時不安裝。
3）Install from Local Directory：不下載安裝文件，直接從本地某個含有安裝文件的目錄進行安裝。
3、選擇第一項，然後點擊下一步：
4、選擇要安裝的目錄，注意，最好不要放到有中文和空格的目錄裡，似乎會造成安裝出問題，其它選項不用變，之後點下一步：
5、上一步是選擇安裝cygwin的目錄，這個是選擇你下載的安裝包所在的目錄，默認是你運行setup.exe的目錄，直接點下一步就可以：
6、此時你共有三種連接方式選擇：
1) Direct Connection：直接連接。
2) Use IE5 Settings：使用IE的連接參數設置進行連接。
3) Use HTTP/FTP Proxy：使用HTTP或FTP代理伺服器進行連接（需要輸入伺服器地址、連接埠號）。
用戶可根據自己的網路連接的實情情況進行選擇，一般正常情況下，均選擇第一種，也就是直接連接方式。然後再點擊「下一步」，
7、 這是選擇要下載的站台，我用的是http://mirrors.kernel.org，速度感覺還挺快，選擇後點下一步(http://mirror.lupaworld.com/cygwin/ 這個是我從這個地址下的,好像是國內的伺服器,挺快的,用其他的,有的2k/s,而且安了好幾次,有一次快好了,那個伺服器關了,囧...)
8、 此時會下載加載安裝包列表
9、Search是可以輸入你要下載的包的名稱，能夠快速篩選出你要下載的包。那四個單選按鈕是選擇下邊樹的樣式，默認就行，不用動。View默認是Category，建議改成full顯示全部包再查，省的一些包被隱藏掉。左下角那個復選框是是否隱藏過期包，默認打鉤，不用管它就行，下邊開始下載我們要安裝的包吧，為了避免全部下載，這裡列出了後面開發NDK用得著的包：autoconf2.1、automake1.10、binutils、gcc-core、gcc- , g++、gcc4-core、gcc4-g++、gdb、pcre、pcre-devel、gawk、make(寧可多選,不能少選)共12個包.
10、  然後開始選擇安裝這些包吧，點skip，把它變成數字版本格式，要確保Bin項變成叉號，而Src項是源碼，這個就沒必要選了。
11、  下面測試一下cygwin是不是已經安裝好了。
運行cygwin，在彈出的命令行窗口輸入：cygcheck -c cygwin命令，會列印出當前cygwin的版本和運行狀態，如果status是ok的話，則cygwin運行正常。
然後依次輸入gcc –v，g++  --version，make –version，gdb –version進行測試，(注意空格和-)如果都列印出版本資訊和一些描述資訊，非常高興的告訴你，你的cygwin安裝完成了！
三：配置NDK環境變數
1、  首先找到cygwin的安裝目錄，找到一個home\<你的用戶名>\.bash_profile文件，我的是：E:\cygwin\home\Administrator\.bash_profile，
    (注意：我安裝的時候我的home文件夾下面神馬都沒有，解決的辦法：首先打開環境變數，把裡面的用戶變數中的HOME變數刪掉，
     在E:\cygwin\home文件夾下建立名為Administrator的文件夾（是用戶名），然後把E:\cygwin\etc\skel\.bash_profile拷貝到該文件夾下)。
2、  打開bash_profile文件，添加NDK=/cygdrive/<你的盤符>/<android ndk 目錄> 例    如：NDK=/cygdrive/e/android-ndk-r5
export NDK
NDK這個名字是隨便取的，為了方面以後使用方便，選個簡短的名字，然後保存
3、打開cygwin，輸入cd $NDK，如果輸出上面配置的/cygdrive/e/android-ndk-r5資訊，則表明環境變數設置成功了。
四：用NDK來編譯程式
1、  現在我們用安裝好的NDK來編譯一個簡單的程式吧，我們選擇ndk自帶的例子hello-jni，我的位於E:\android-ndk-r5\samples\hello-jni(根據你具體的安裝位置而定)，
2、 運行cygwin，輸入命令cd /cygdrive/e/android-ndk-r5/samples/hello-jni，進入到E:\android-ndk-r5\samples\hello-jni目錄。
3、 輸入$NDK/ndk-build，執行成功後，它會自動生成一個libs目錄，把編譯生成的.so文件放在裡面。($NDK是調用我們之前配置好的環境變數，ndk-build是調用ndk的編譯程式)
4、  此時去hello-jni的libs目錄下看有沒有生成的.so文件，如果有，你的ndk就運行正常啦！
生成之後,這時候可以再用ndk的samples裡邊的例子生成eclipse工程了.
如下,選擇新建android工程然後如下圖:
 
然後就可以試驗其他的幾個例子了.我也還在研究中, 大家一起加油!!!
五：在eclipse中集成c/c++開發環境
(這個好像在國內悲劇啊,下不動啊,在傳兩個fan牆的軟體)
1、 裝Eclipse的C/C++環境插件：CDT，這裡選擇在線安裝。
首先登錄http://www.eclipse.org/cdt/downloads.php，找到對應你Eclipse版本的CDT插件的在線安裝地址。
2、  然後點Help功能表，找到Install New Software功能表
3、  點擊Add按鈕，把取的地址填進去，出來插件列表後，選Select All，然後選擇下一步即可完成安裝
4、  安裝完成後，在eclispe中右擊新建一個項目，如果出現了c/c++項目，則表明你的CDT插件安裝成功啦！
六：配置C/C++的編譯器
(建議先用命令行編譯,然後再研究google ndk samples 裡邊的例子, 然後再研究傻瓜式的編譯)
1、  打開eclipse，導入ndk自帶的hello-jni例子，右鍵單擊項目名稱，點擊Properties，彈出配置界面，之後再點擊Builders，彈出項目的編譯工具列表，之後點擊New，新添加一個編譯器，點擊後出現添加界面，選擇Program，點擊OK
2、  出現了添加界面，首先給編譯配置起個名字，如：C_Builder
設置Location為<你cygwin安裝路徑>\bin\bash.exe程式，例如：E:\cygwin\bin\bash.exe，設置Working  Directory為<你cygwin安裝路徑>\bin目錄，例如：E:\cygwin\bin
設置Arguments為
--login -c "cd /cygdrive/e/android-ndk-r5/samples/hello-jni && $NDK/ndk-build"(不能改動的,--login –c 是神馬意思我也不懂)
上面的配置中/cygdrive/e/android-ndk-r5/samples/hello-jni是你當前要編譯的程式的目錄，$NDK是之前配置  的ndk的環境變數，這兩個根據你具體的安裝目錄進行配置，其他的不用變，Arguments這串參數實際是  給bash.exe命令行程式傳參數，進入要編譯的程式目錄，然後運行ndk-build編譯程式
3、 接著切換到Refresh選項卡，給Refresh resources upon completion打上鉤
4、  然後切換到Build Options選項卡，勾選上最後三項
5、  之後點擊Specify Resources按鈕，選擇資源目錄，勾選你的項目目錄即可
6、  最後點擊Finish，點擊OK一路把剛才的配置都保存下來，注意：如果你配置的編譯器在其它編譯器下邊，記得一定要點Up按鈕，把它排到第一位，否則C代碼的編譯晚於Java代碼的編譯，會造成你的C代碼要編譯兩次才能看到最新的修改
7、  這一路下來肯定很累了吧，現在再次恭喜你，編譯配置也配置完成啦，現在來測試一下是否可以自動編譯呢，打開項目jni目錄裡的hello-jni.c文件把提示Hello from JNI!改成其他的文字：如：Hello，My name is alex.，然後再模擬器中運行你的程式，如果模擬器中顯示了你最新修改的文字，那麼Congratulations！你已經全部配置成功啦！
 

/******************************************************************************/
Compile C/C++ ARM binary (Static Library) for Android using Standalone toolchain
/******************************************************************************/
This post is intended for those who wants to compile and reuse their existing C/C++ code or who wants to compile an open source code for their Android 
applications. The idea came into my mind after putting time and effort for compiling and using an open source library CS-MAP in Android application. 
Hopefully this will help you to save a lot of time and efforts.
Android NDK provides set of tools for compiling and using C and/or C++ source files and generate the native ARM binaries (static, shared and executable) 
on Linux, OS X and Windows, which can be further used in Android application through Java Native Interface (JNI) calls.
I will explain how we can use the standalone cross-compilers for creating ARM binary (a static library) from C++ source files.

Step 1: Extract the standalone cross-compiler toolchain.
Install ANDROID-NDK from http://developer.android.com/sdk/ndk/index.html
Add an environment variable NDK and add path of NDK root directory as its value.
Run the script for extracting android NDK standalone toolchain binaries and other stuff.                                                                                                                                $NDK/build/tools/make-standalone-toolchain.sh –platform=android-14 –install-dir = /cygdrive/e/android/standalone-14
The above script creates a directory name "standalone-14" in "E:\android\" directory of my Window box
Note: As I am extracting the toolchain on Windows Box, so I passed the /cygwin/e/android/standalone-14 in my install directory path. 
For Linux and OS X one need to customize the above command accordingly.

Step 2: Identify the C/C++ Sources for compilation
Create a project directory having name "StaticLibraryTest"
Create a source directory having name "src" in StaticLibraryTestdirectory which contains the C/C++ source files
Test1.cpp
// Contents of Test1.cpp
#include "Test1.h"
int  test1(int  x, int  y){
    int temp = 44;
    return (x + y )+ temp ;
}

Test2.cpp
// Content of Test2.cpp
#include "Test2.h"
int  test2(int  x, int  y, int z){
    int temp = 9;
    return (x * y) – temp + z;
}

Create a header directory having name "include" in StaticLibraryTestdirectory which contains the C/C++ header files
Test1.h
// Contents of Test1.h
#ifndef TEST1_H
#define TEST1_H
extern int test1(int  x, int  y);
#endif /* TEST1_H */

Test2.h
// Contents of Test2.h
#ifndef TEST2_H
#define TEST2_H
extern int test2(int  x, int  y, int z);
#endif /* TEST2_H */

Step 3: Create a make file for building the source and create static library
Create a file having name "make-static-library.mak" in "src" directory. This directory also contains the C/C++ source files. 
The content of make script are given below.

# This variable contains the path of bin directory which contains all the gnu tools required for compilation
# I have extracted the standalone toolchain for Android platform 14 in "e:\android\standalone-14"
ANDROID_NDK_BIN:=/cygdrive/e/android/standalone-14/bin

# Compilation Tools
CC := $(ANDROID_NDK_BIN)/arm-linux-androideabi-gcc
CPP := $(ANDROID_NDK_BIN)/arm-linux-androideabi-g++
AR := $(ANDROID_NDK_BIN)/arm-linux-androideabi-ar

# Compiler flags
# Specify all the flags below which you want to use for your compilation, For this simple example, we only need to specify the include directory path
CFLAGS          := -I../include
# Rule for making C++ object file
.cpp.o:
$(CPP) $(CFLAGS) -c  $<
# Rule for making C object file
.c.o:
$(CC) $(CFLAGS) -c  $<
STATIC_LIB_SRC = Test1.cpp Test2.cpp
STATIC_LIB_OBJ = Test1.o Test2.o
OUT = ccStaticLib.a
$(OUT): $(STATIC_LIB_OBJ)
$(AR) -crs $(OUT) $(STATIC_LIB_OBJ)

Step 4: Compilation using the make script
Open the console (Cygwin for Windows) and change the directory to the "src" directory which contains the C/C++ source files (Test1.cpp and Test2.cpp) and
 the make file (make-static-library.mak)
Execute the following command to compile the sources and generate the static library from these sources. 
"make –f make-static-library.mak"
This will create the static library in the src directory name "ccStaticLib.a". I have added the "cc" (Cross Compiler) as prefix in the name of static Library generated from make script.
Now static library "ccStaticLib.a" (ARM Binary for Android) is created and our next mission is to use this static library in Android project.


/******************************************************************************/
Use of prebuild static Library compiled with Android Toolchain
/******************************************************************************/
Just to continue with my last post in which I compiled two simple C++ files and archived as a static library. So make sure to open previous blog  in another tab because I will refer this in current post as well.
Now in this Post i will use the same static library in an Android project. Following are the simple steps.

Step 1: Create an Android Project
Create a new android project having name "CrossCompilation".
Set the package name as "com.tmz.cc"
Create a default activity name "MainActivity"
Update the layout file "main.xml" and xml contains
<?xml version="1.0" encoding=" utf-8〞?>
<GridLayout
xmlns:android="http://schemas.android.com/apk/res/android&#8221";
android:layout_width="match_parent"
android:layout_height="match_parent"
android:useDefaultMargins="true"
android:alignmentMode="alignBounds"
android:columnOrderPreserved="false"
android:columnCount="4">

<TextView
android:text="Cross Compiled Library Testing"
android:textSize="16dip"
android:layout_columnSpan="4"
android:layout_gravity="center_horizontal" />

<TextView
android:text="Native methods calls Results:"
android:textSize="16dip"
android:layout_columnSpan="4"
android:layout_gravity="left" />

<TextView
android:text="Test 1:"
android:layout_gravity="right" />

<TextView
android:id = "@+id/test1Result"
android:text="Press Button to get result"
android:ems="10" />

<TextView
android:text="Test 2:"
android:layout_column="0"
android:layout_gravity="right" />

<TextView
android:id = "@+id/test2Result"
android:text="Press Button to get result"
android:ems="10" />

<Space
android:layout_row="4"
android:layout_column="0"
android:layout_columnSpan="3"
android:layout_gravity="fill" />

<Button
android:text="Call Native Methods"
android:layout_row="4"
android:layout_column="1"
android:id = " @+id/btnCallNative" />
</GridLayout>

Now Open the MainActivity.java file and following are its contents
package com.tmz.cc;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends Activity {
    private Button btnCallNative;
    private TextView tvTest1Result;
    private TextView tvTest2Result;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        btnCallNative = (Button)findViewById(R.id.btnCallNative);
        tvTest1Result = (TextView)findViewById(R.id.test1Result);
        tvTest2Result = (TextView)findViewById(R.id.test2Result);

        btnCallNative.setOnClickListener(new View.OnClickListener(){
            public void onClick(View view)
            {
                callNativeMethods();
            }
        });
        //setContentView(R.layout.main);
    }

    private native int test1();
    private native int test2();

    public void callNativeMethods() {
        System.loadLibrary("ccSharedLib");
        int a = test1();
        int b = test2();
        Integer res1= new Integer(a);
        Integer res2 = new Integer(b);
        tvTest1Result.setText(res1.toString());
        tvTest2Result.setText(res2.toString());
        System.out.print(a);
        System.out.print(b);
    }
}
Now we are done with Java side. Its time to add native side in our project.

Step 2: Add native code and pre-build binaries
Create a directory on root of project having name "jni"
Add two more directories in "jni"  directory.
1)"include"  (which contains the headers files of pre-build static library)  and put Test1.h and Test2.h in this directory which I created in the previous blog.  See previous blog
2) "prebuild"  (which contains the pre-build static library created in previous blog) and put the ccStaticLib.a in this directory See previous blog

Add two files in "jni"  directory
1) "Android.mk"  and its contents are

LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE    := ccStaticLibrary
LOCAL_SRC_FILES := prebuild/ccStaticLib.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE    := ccSharedLib
LOCAL_SRC_FILES := main-jni.cpp
LOCAL_STATIC_LIBRARIES := ccStaticLibrary
include $(BUILD_SHARED_LIBRARY)

2) "main-jni.cpp"  and its contents are
#include <jni.h>
#include <stdio.h>
#include "include/test1.h"
#include "include/test2.h"

extern " C"  {
jint Java_com_tmz_cc_MainActivity_test1( JNIEnv*  env, jobject  thiz)
{
    jint temp = 0;
    temp = test1(4,5);
    return temp;
}

jint Java_com_tmz_cc_MainActivity_test2( JNIEnv*  env, jobject  thiz)
{
    jint temp = 0;
    temp = test2(4,5,6);
    return temp;
}
}
We are done with the coding stuff.
Now we need to compile the project both the native side as well as the Java (Android side) and after compilation you can run this and see the native calls results by pressing the button on main layout.


/******************************************************************************/
Android MK 文件寫法 @ Welkin 小窩 :
/******************************************************************************/
(1)Android.mk文件首先需要指定LOCAL_PATH變數，用於查找源文件。由於一般情況下
   Android.mk和需要編譯的源文件在同一目錄下，所以定義成如下形式：
   LOCAL_PATH:=$(call my-dir)
   上面的語句的意思是將LOCAL_PATH變數定義成本文件所在目錄路徑。

(2)Android.mk中可以定義多個編譯模組，每個編譯模組都是以include $(CLEAR_VARS)開始以include $(BUILD_XXX)結束。
   include $(CLEAR_VARS)
   CLEAR_VARS由編譯系統提供，指定讓GNU MAKEFILE為你清除除LOCAL_PATH以外的所有LOCAL_XXX變數，
   如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_SHARED_LIBRARIES，LOCAL_STATIC_LIBRARIES等。

   include $(BUILD_STATIC_LIBRARY)表示編譯成靜態庫
   include $(BUILD_SHARED_LIBRARY)表示編譯成動態庫。
   include $(BUILD_EXECUTABLE)表示編譯成可執行程式

(3)舉例如下(frameworks/base/libs/audioflinger/Android.mk)：
java代碼：
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS) 模組一
ifeq ($(AUDIO_POLICY_TEST),true)
ENABLE_AUDIO_DUMP := true
endif
LOCAL_SRC_FILES:= AudioHardwareGeneric.cpp AudioHardwareStub.cpp AudioHardwareInterface.cpp
ifeq ($(ENABLE_AUDIO_DUMP),true)
LOCAL_SRC_FILES += AudioDumpInterface.cpp
LOCAL_CFLAGS += -DENABLE_AUDIO_DUMP
endif
LOCAL_SHARED_LIBRARIES := libcutils libutils libbinder libmedia libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
LOCAL_CFLAGS += -DGENERIC_AUDIO
endif
LOCAL_MODULE:= libaudiointerface
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
LOCAL_SRC_FILES += A2dpAudioInterface.cpp
LOCAL_SHARED_LIBRARIES += liba2dp
LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
LOCAL_C_INCLUDES += $(call include-path-for, bluez)
endif
include $(BUILD_STATIC_LIBRARY) 模組一編譯成靜態庫
include $(CLEAR_VARS) 模組二
LOCAL_SRC_FILES:= AudioPolicyManagerBase.cpp
LOCAL_SHARED_LIBRARIES := libcutils libutils libmedia
ifeq ($(TARGET_SIMULATOR),true)
LOCAL_LDLIBS += -ldl
else
LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudiopolicybase
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
LOCAL_CFLAGS += -DWITH_A2DP
endif
ifeq ($(AUDIO_POLICY_TEST),true)
LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
include $(BUILD_STATIC_LIBRARY) 模組二編譯成靜態庫
include $(CLEAR_VARS) 模組三
LOCAL_SRC_FILES:= AudioFlinger.cpp AudioMixer.cpp.arm AudioResampler.cpp.arm AudioResamplerSinc.cpp.arm AudioResamplerCubic.cpp.arm AudioPolicyService.cpp
LOCAL_SHARED_LIBRARIES := libcutils libutils libbinder libmedia libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
LOCAL_STATIC_LIBRARIES += libaudiointerface libaudiopolicybase
LOCAL_CFLAGS += -DGENERIC_AUDIO
else
LOCAL_SHARED_LIBRARIES += libaudio libaudiopolicy
endif
ifeq ($(TARGET_SIMULATOR),true)
LOCAL_LDLIBS += -ldl
else
LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudioflinger
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
LOCAL_SHARED_LIBRARIES += liba2dp
endif
ifeq ($(AUDIO_POLICY_TEST),true)
LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
ifeq ($(TARGET_SIMULATOR),true)
ifeq ($(HOST_OS),linux)
LOCAL_LDLIBS += -lrt -lpthread
endif
endif
ifeq ($(BOARD_USE_LVMX),true)
LOCAL_CFLAGS += -DLVMX
LOCAL_C_INCLUDES += vendor/nxp
LOCAL_STATIC_LIBRARIES += liblifevibes
LOCAL_SHARED_LIBRARIES += liblvmxservice
# LOCAL_SHARED_LIBRARIES += liblvmxipc
endif
include $(BUILD_SHARED_LIBRARY) 模組三編譯成動態庫

(4)編譯一個應用程式(APK)
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory-->直譯（建立在java子目錄中的所有Java文件）
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build-->直譯（創建APK的名稱）
LOCAL_PACKAGE_NAME := LocalPackage

# Tell it to build an APK-->直譯（告訴它來建立一個APK）
include $(BUILD_PACKAGE)

(5)編譯一個依賴於靜態Java庫(static.jar)的應用程式
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# List of static libraries to include in the package
LOCAL_STATIC_JAVA_LIBRARIES := static-library

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

# Tell it to build an APK
include $(BUILD_PACKAGE)

(6)編譯一個需要用平台的key簽名的應用程式
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

LOCAL_CERTIFICATE := platform

# Tell it to build an APK
include $(BUILD_PACKAGE)

(7)編譯一個需要用特定key前面的應用程式
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Name of the APK to build
LOCAL_PACKAGE_NAME := LocalPackage

LOCAL_CERTIFICATE := vendor/example/certs/app

# Tell it to build an APK
include $(BUILD_PACKAGE)

(8)添加一個預編譯應用程式
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Module name should match apk name to be installed.
LOCAL_MODULE := LocalModuleName
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)

include $(BUILD_PREBUILT)

(9)添加一個靜態JAVA庫
java代碼：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Build all java files in the java subdirectory
LOCAL_SRC_FILES := $(call all-subdir-java-files)

# Any libraries that this library depends on
LOCAL_JAVA_LIBRARIES := android.test.runner

# The name of the jar file to create
LOCAL_MODULE := sample

# Build a static jar file.
include $(BUILD_STATIC_JAVA_LIBRARY)

(10)Android.mk的編譯模組中間可以定義相關的編譯內容，也就是指定相關的變數如下：
java代碼：
[code]LOCAL_AAPT_FLAGS
LOCAL_ACP_UNAVAILABLE
LOCAL_ADDITIONAL_JAVA_DIR
LOCAL_AIDL_INCLUDES 
LOCAL_ALLOW_UNDEFINED_SYMBOLS
LOCAL_ARM_MODE
LOCAL_ASFLAGS
LOCAL_ASSET_DIR
LOCAL_ASSET_FILES //在Android.mk文件中編譯應用程式(BUILD_PACKAGE)時設置此變數，表示資源文件，
通常會定義成LOCAL_ASSET_FILES += $(call find-subdir-assets)
LOCAL_BUILT_MODULE_STEM 
LOCAL_C_INCLUDES //額外的C/C++編譯頭文件路徑，用LOCAL_PATH表示本文件所在目錄
舉例如下：
LOCAL_C_INCLUDES += extlibs/zlib-1.2.3
LOCAL_C_INCLUDES += $(LOCAL_PATH)/src 
LOCAL_CC //指定C編譯器
LOCAL_CERTIFICATE //簽名認證
LOCAL_CFLAGS //為C/C++編譯器定義額外的標誌(如宏定義)，舉例：LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1
LOCAL_CLASSPATH 
LOCAL_COMPRESS_MODULE_SYMBOLS
LOCAL_COPY_HEADERS //install應用程式時需要複製的頭文件，必須同時定義LOCAL_COPY_HEADERS_TO
LOCAL_COPY_HEADERS_TO //install應用程式時複製頭文件的目的路徑
LOCAL_CPP_EXTENSION //如果你的C++文件不是以cpp為文件後綴，你可以通過LOCAL_CPP_EXTENSION//指定C++文件後綴名 
如：LOCAL_CPP_EXTENSION := .cc
注意統一模組中C++文件後綴必須保持一致。
LOCAL_CPPFLAGS //傳遞額外的標誌給C++編譯器，如：LOCAL_CPPFLAGS += -ffriend-injection
LOCAL_CXX //指定C++編譯器
LOCAL_DX_FLAGS
LOCAL_EXPORT_PACKAGE_RESOURCES
LOCAL_FORCE_STATIC_EXECUTABLE 
//如果編譯的可執行程式要進行靜態鏈接(執行時不依賴於任何動態庫)，則設置LOCAL_FORCE_STATIC_EXECUTABLE:=true 
//目前只有libc有靜態庫形式，這個只有文件系統中/sbin目錄下的應用程式會用到，這個目錄下的應用程式在運行時通常
//文件系統的其它部分還沒有加載，所以必須進行靜態鏈接。
LOCAL_GENERATED_SOURCES
LOCAL_INSTRUMENTATION_FOR
LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME
LOCAL_INTERMEDIATE_SOURCES
LOCAL_INTERMEDIATE_TARGETS
LOCAL_IS_HOST_MODULE
LOCAL_JAR_MANIFEST
LOCAL_JARJAR_RULES
LOCAL_JAVA_LIBRARIES //編譯java應用程式和庫的時候指定包含的java類庫，目前有core和framework兩種
多數情況下定義成：LOCAL_JAVA_LIBRARIES := core framework
注意LOCAL_JAVA_LIBRARIES不是必須的，而且編譯APK時不允許定義(系統會自動添加)
LOCAL_JAVA_RESOURCE_DIRS 
LOCAL_JAVA_RESOURCE_FILES
LOCAL_JNI_SHARED_LIBRARIES
LOCAL_LDFLAGS //傳遞額外的參數給連接器(務必注意參數的順序)
LOCAL_LDLIBS //為可執行程式或者庫的編譯指定額外的庫，指定庫以"-lxxx"格式，舉例：
LOCAL_LDLIBS += -lcurses -lpthread
LOCAL_LDLIBS += -Wl,-z,origin 
LOCAL_MODULE //生成的模組的名稱(注意應用程式名稱用LOCAL_PACKAGE_NAME而不是LOCAL_MODULE)
LOCAL_MODULE_PATH //生成模組的路徑
LOCAL_MODULE_STEM 
LOCAL_MODULE_TAGS //生成模組的標記 
LOCAL_NO_DEFAULT_COMPILER_FLAGS 
LOCAL_NO_EMMA_COMPILE
LOCAL_NO_EMMA_INSTRUMENT
LOCAL_NO_STANDARD_LIBRARIES
LOCAL_OVERRIDES_PACKAGES
LOCAL_PACKAGE_NAME //APK應用程式的名稱
LOCAL_POST_PROCESS_COMMAND
LOCAL_PREBUILT_EXECUTABLES //預編譯including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)時所用,指定需要複製的可執行文件
LOCAL_PREBUILT_JAVA_LIBRARIES
LOCAL_PREBUILT_LIBS //預編譯including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)時所用, 指定需要複製的庫.
LOCAL_PREBUILT_OBJ_FILES
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES 
LOCAL_PRELINK_MODULE //是否需要預連接處理(默認需要，用來做動態庫優化)
LOCAL_REQUIRED_MODULES //指定模組運行所依賴的模組(模組安裝時將會同步安裝它所


/******************************************************************************/
使用android ndk r8 編譯nativc C,生成動態庫。並連接使用
/******************************************************************************/
#今天我講解的是如何使用Android.mk文件加上android ndk來編譯一個可以加載動態庫的命令。 
  我用到的實例是math。目的是把double.c trip.c編譯成double.so 再編譯main.c並連接到double.so 
  其中要用到三個文件，分別是double.c trip.c main.c  各文件的內容如下：
  /* main.c */
#include<stdio.h> 
#include<math.h> 
int main() 
{   
    extern double dou();
    extern double trip();
    double x,y,z;
    puts("Enter a number please:");
    scanf("%lf",&x);
    y=dou(x);
    z=trip(x);
    printf("doub of the number is: %lf\n",y);
    printf("trip of the number is: %lf\n",z);
    printf("the sqrt of the trip is %lf\n",sqrt(z));
    return 0;
} 
########### 
/*double.c */ 
#include<stdio.h> 
double dou( double n) 
{   
    return n*n; 
} 
######### 
/*trip.c */
#include<stdio.h>
double trip(double n) 
{ 
   return n*n*n; 
} 
###### 
下面的文件是最重要的：Android.mk 
# build the math module for android
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)                   #聲名模組的開始
LOCAL_MODULE := double                  #生成的模組名稱是double
LOCAL_SRC_FILES := double.c trip.c      #編譯要用以的源代碼文件
LOCAL_EXPORT_LDLIBS:= -llog             #連接要用到的註冊庫（liblog.so)，為下面的編譯做準備
include $(BUILD_SHARED_LIBRARY)         #編譯生成動態的庫文件lib$(LOCAL_MODULE).so

include $(CLEAR_VARS)
LOCAL_MODULE :=math
LOCAL_SRC_FILES :=main.c
LOCAL_SHARED_LIBRARIES :=double m       #聲名需要連接的庫文件分別是，上面編譯的libdouble.so libm.so
include $(BUILD_EXECUTABLE)             #生成可以執行的文件$(LOCAL_MODULE)
########################
現在對編譯的工具的位置說明一下：
我把編譯工具放置在/home/sn/android-ndk-r8目錄裡面。
編譯源代碼的目錄是/home/sn/code/learning-c
真正的源代碼放置位置是/home/sn/code/learning-c/jni
編譯的時候，主要在jni的上層目錄進行，即是learning-c目錄，
我在終端的目錄顯示為如下：
root@sn-workshop:/home/sn/code/learning-c#
我把以上的目錄簡寫為$(PROJECT), {  即為我定義為有如下的規則PROJECT=/home/sn/code/learning-c
所以我的編譯命令就是如下所示：
$(PROJECT) http://www.cnblogs.com/android-ndk-r8/ndk-build
編譯器運行的時候得到如下資訊輸出：
Compile thumb  : double <= double.c
Compile thumb  : double <= trip.c V -
SharedLibrary  : libdouble.so
Install        : libdouble.so => libs/armeabi/libdouble.so
Compile thumb  : math <= main.c
Executable     : math
Install        : math => libs/armeabi/math
--------------------------
上面顯示的資訊如圖所示：
#加入圖片
能顯示以上的資訊，證明已經編譯成功了。
下面用cd命令進入生成math和libdouble.so文件目錄，命令如下：
$(PROJECT) cd ./libs/armeabi
查看當前目錄的文件是否存在：
$(PROJECT)/libs/armeabi#ls  #顯示
libdouble.so math
-----------------
現在使用arm-linux-androideabi-readelf命令查看一下，math命令需要哪些動態庫文件（*.so）文件。
其中這個arm-linux-androideabi-readelf是你從android ndk r7(r8)的源代碼程式中，提取出來的單獨的toolchain,
並把得到的toolchain加入到環境中去。
真正的命令如下所示：
$(PROJECT)libs/armeabi#arm-linux-androideabi-readelf -d math #其中的選項"-d"，目的是顯示加載的動態庫
顯示的內容如下：
-------------------------------------
Dynamic section at offset 0x2490 contains 26 entries:
Tag                Type              Name/Value
0x00000001            (NEEDED)        Shared library: [libdouble.so]
0x00000001            (NEEDED)        Shared library: [liblog.so]
0x00000001            (NEEDED)        Shared library: [libstdc++.so]
0x00000001            (NEEDED)        Shared library: [libm.so]
0x00000001            (NEEDED)        Shared library: [libc.so]
0x00000001            (NEEDED)        Shared library: [libdl.so]
0x00000020            (PREINIT_ARRAY) 0X12470
0X00000021            (PREINIT_ARRARYSZ) 0x8
---------------------  下面是實際的操作：
下面用adb push命令把生成的兩個文件push到手機目錄 ，前提是你的linux系統已經正確配置adb,
還有你的手機已經root
要用到的命令如下：
adb push math /system/math  #把生成的文件push到手機的/system目錄下面去
adb push libdouble.so /system/lib/libdouble.so  #把生成的libdouble.so文件push到/system/lib目錄去，
因為這個目錄是動態庫文件放置的地方。
#注意當沒有把libdouble.so文件複製到/system/lib目錄的時候會出現如下的錯誤：
Link_image[1962]: 726 could not load needed library 'libdouble.so' for './math' (Load_library[1104]:
Library 'libdouble.so' not found)CANNOT LINK EXECTABLE
繼續輸入如下的命令：（『#』後面是解釋詞）
adb shell        #進入手機的調試終端
#如果你的手機是從內核得到權限的，會顯示這個提示符#
$                #如果你的手機是沒有從內核得到權限的，就會顯示這個提示符，
當出現$提示符的時候，再輸入su,再在手機的螢幕上面按確定就行了。
.  再用如下的命令：
#cd /system        #進入/system目錄，
# ls math            #查看當前目錄是否有math文件，
#./math               #運行math程式， `
Enter a number please
4
double of the numbe is : 16.000000
trip of the numbe is   :64.000000
the sqrt of the trip is 8.000000
#                #程式運行完成後，返回命令行的終端模式。
#exit            #退出調試終端。
以上就是全部了。


/******************************************************************************/
// NDK ENV setting . Dexter..
/******************************************************************************/
// Cygwin setting
bash_profile
NDK=/cygdrive/d/DEXTER/AndroidTools/adt-bundle-windows-x86-20130729/ndk/android-ndk-r9


1. Location:
C:\cygwin\bin\bash.exe
2. Working Directory: 
C:\cygwin\bin
3. Argument:
--login -c "cd /cygdrive/d/Dexter/Eclipse\ workspace/[Project] && $NDK/ndk-build"



/******************************************************************************/
Android JNI/NDK 學習筆記        ref: http://www.kunli.info/wp-content/uploads/2011/08/JNIDocumentChinese.pdf
/******************************************************************************/
JNI，全稱Java Native Interface，是用於讓運行在JVM中的Java代碼和運行在JVM外的Native代碼（主要是C或者C++）溝通的橋樑。
代碼編寫者即可以使用JNI從Java的程式中調用Native代碼，又可以從Native程式中調用Java代碼。
這樣，編程人員可以將低階的代碼邏輯包裝到高階的程式框架中，獲得高性能高效率的同時保證了代碼框架的高抽像性。
在Android中，僅有以下類庫是允許在JNI中使用的：
● libc (C library) headers
● libm (math library) headers
● JNI interface headers
● libz (Zlib compression) headers
● liblog (Android logging) header
● OpenGL ES 1.1 (3D graphics library) headers (since 1.6)
● A Minimal set of headers for C++ support
JNI本身僅僅是一個把兩者融合的工具，作為編程者需要做的，就是在Java代碼和Native代碼中按照固定的格式告訴JNI如何調用對方。在Android中，有兩種方式可以調用JNI
，一種是Google release的專門針對Android Native開發的工具包，叫做NDK。去Android網站上下載該工具包後，就可以通過閱讀裡面的文檔來setup一個新的包含Native代碼
的工程，創建自己的Android.mk文件，編譯等等；另一種是完整的源碼編譯環境 ，也就是通過git從官方網站獲取完全的Android源代碼平台。這個平台中提供有基於make的編
譯系統。更多細節請參考這裡。不管選擇以上兩種方法的哪一個，都必須編寫自己的Android.mk文件，有關該文件的編寫請參考相關文檔。
下面通過一個簡單的使用例子來講解JNI。Android給C和C++提供的是兩套不同的Native API，本文僅以C++舉例說明。
假設這麼一個需求，Java代碼需要列印一個字串，而該字串需要Native代碼計算生成。
對應的JNI流程是這樣的：
1. 在準備列印字串的Android類中，添加兩段代碼。
第一段是：
private native String getPrintStr();
這一行代碼的目的是告訴JNI，這個Java文件中有這麼一個函數，該函數是在Native代碼中執行的，
Native代碼會返回一個字串供Java代碼來輸出。
第二段是：
try { 
    System.loadLibrary("LIBNAME"); 
} catch (UnsatisfiedLinkError ule) {
    Log.e(TAG, "Could not load native library");
}
這兩行代碼是告訴JNI，你需要找的所有Native函數都在libLIBNAME.so這個動態庫中。注意JNI會自動補全lib和so給LIBNAME，你只需要提供LIBNAME給loadLibrary就行了。
在最後執行的時候，JNI會先找到這個動態庫，然後找裡面的OnLoad函數，具體註冊流程由OnLoad函數接管。關於如何確定這個LIBNAME，和如何定義OnLoad函數，下面就會講。

2. 上面的第一步是告訴JNI，java代碼需要和Native代碼交互，同時把在哪裡找，找什麼都通知了。接下來的事情就由Native端接管。如果把上面的getPrintString函數申明
比作原型，那麼本地代碼中的具體函數定義就應該和該原型匹配，JNI才能知道具體在哪裡執行代碼。具體來說，應該有一個對應的Native函數，有和Java中定義的函數同樣的
參數列表以及返回值。另外，還需要有某種機制讓JNI將兩者相互映射，方便參數和返回值的傳遞。在老版的JNI中，這是通過醜陋的命名匹配實現的，比如說在Java中定義的
函數名是getPrintStr, 該函數屬於package java.come.android.xxx，那麼中對應Native代碼中的函數名就應該是Java_com_android_xxx_getPrintStr。這樣給開發人員帶來
了很多不便。可以用javah命令來生成對應Java code中定義函數的Native code版本header文件，從中得知傳統的匹配方法是如何做的。具體過程如下：
a. 通過SDK的方式編譯Java代碼。
b. 找到Eclipse的工程目錄，進入bin目錄下。這裡是編譯出的java文件所對應的class文件所在。
c. 假設包括Native函數調用的java文件屬於com.android.xxx package，名字叫test.java，那麼在bin下執行javah -jni com.android.xxx.test
執行完後，可以看到一個新生成的header文件，名字為com_android_xxx_test.h。
打開後會發現已經有一個函數申明，函數名為java_com_android_xxx_test_getPrintStr。這個名字就包括了該函數所對應Java版本所在的包，文件以及名稱。
這就是JNI傳統的確定名字的方法。
值得注意的是，header文件中不僅包含了基於函數名的映射資訊，還包含了另一個重要資訊，就是signature。
一個函數的signature是一個字串，描述了這個函數的參數和返回值。其中"()" 中的字元表示參數，後面的則代表返回值。
例如"()V" 就表示void Func(); "(II)V" 表示 void Func(int, int); 數組則以"["開始，用兩個字元表示。
具體的每一個字元的對應關係如下：
字元 Java類型 C類型
 V    void     void
 I    jint     int
 Z    jboolean boolean
 J    jlong    long
 D    jdouble  double
 F    jfloat   float
 B    jbyte    byte
 C    jchar    char
 S    jshort   short
上面的都是基本類型。如果Java函數的參數是class，則以"L"開頭，以";"結尾，中間是用"/" 隔開的包及類名。
而其對應的C函數名的參數則為jobject。 一個例外是String類，其對應的類為jstring。舉例：
Ljava/lang/String; String jstring
Ljava/net/Socket; Socket jobject
如果JAVA函數位於一個嵌入類，則用$作為類名間的分隔符號。例如 "(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z"
這個signature非常重要，是下面要介紹的新版命名匹配方法的關鍵點之一。
所以，即使傳統的命名匹配已經不再使用，javah這一步操作還是必須的，因為可以從中得到Java代碼中需要Native執行的函數的簽名，以供後面使用。
3. 在新版（版本號大於1.4）的JNI中，Android提供了另一個機制來解決命名匹配問題，那就是JNI_OnLoad。
正如前面所述，每一次JNI執行Native代碼，都是通過調用JNI_OnLoad實現的。下面的代碼是針對本例的OnLoad代碼：
/* Returns the JNI version on success, -1 on failure. */
jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env = NULL;
    jint result = -1;
    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        LOGE("ERROR: GetEnv failed");
        goto bail;
    }
    assert(env != NULL);
    if (!register_Test(env)) {
        LOGE("ERROR: Test native registration failed");
        goto bail;
    }
    /* success -- return valid version number */
    result = JNI_VERSION_1_4;
    bail:
    return result;
}
仔細分析這個函數。首先，OnLoad通過GetEnv函數獲取JNI的環境對像，然後通過register_Test來註冊Native函數。register_Test的實現如下：
int register_Test(JNIEnv *env) {
    const char* const ClassPathName ＝ "com/android/xxx/test";
    return registerNativeMethods(env, ClassPathName, TestMethods,
        sizeof(TestMethods) / sizeof(TestMethods[0]));
}
在這裡，ClassPathName是Java類的全名，包括package的全名。只是用 "/" 代替 "." 。
然後我們把類名以及TestMethods這個參數一同送到registerNativeMethods這個函數中註冊。這個函數是基於JNI_OnLoad的命名匹配方式的重點。
在JNI中，代碼編寫者通過函數signature名和映射表的配合，來告訴JNI_OnLoad，你要找的函數在
Native代碼中是如何定義的（signature），以及在哪定義的（映射表）。關於signature的生成和含
義，在上面已經介紹。而映射表，是Android使用的一種用於映射Java和C/C++函數的數組，這個數
組的類型是JNINativeMethod，定義為：
typedef struct {
    const char* name;
    const char* signature;
    void* fnPtr;
} JNINativeMethod;
其中，第一個變數是Java代碼中的函數名稱。第二個變數是該函數對應的Native signature。第三個變數是該函數對應的Native函數的函數指針。
例如，在上面register_Test的函數實現中，傳給registerNativeMethods的參數TestMethods就是映射表，定義如下：
static JNINativeMethod TestMethods[] = {
    {"getPrintStr", "()Ljava/lang/String", (void*)test_getPrintStr}
};
其中getPrintStr是在Java代碼中定義的函數的名稱，()Ljava/lang/String是簽名，因為該函數無參數傳入，並返回一個String。
test_getPrintStr則是我們即將在Native code中定義的函數名稱。該映射表和前面定義的類名ClassPathName一起傳入registerNativeMethods：
static int registerNativeMethods(JNIEnv* env, const char* className, JNINativeMethod*
Methods, int numMethods) {
    jclass clazz;
    clazz = env->FindClass(className);
    if (clazz == NULL) {
        LOGE("Native registration unable to find class '%s'", className);
        return JNI_FALSE；
    }
    if (env->RegisterNatives(clazz, gMethods, numMethods) < 0) {
        LOGE("RegisterNatives failed for '%s'", className);
        return JNI_FALSE;
    }
    return JNI_TRUE;
}
在這裡，先load目標類，然後註冊Native函數，然後返回狀態。
可以看出，通過映射表方式，Java code中的函數名不須再和Native code中的函數名呆板對應。
只需要將函數註冊進映射表中，Native code的函數編寫就有了很大的靈活性。
雖說和前一種傳統的匹配方法比，這種方式並沒有效率上的改進，因為兩者本質上都是從JNI load開始做函數映射。
但是這一種register的方法極大降低了兩邊的耦合性，所以實際使用中會受歡迎得多。
比如說，由於映射表是一個<名稱，函數指針>對照表，在程式執行時，可多次調用registerNativeMethods()函數來更換本地函數指針，而達到彈性抽換本地函數的目的。

4. 接下來本應介紹test_getPrintStr。但在此之前，簡單介紹Android.mk，也就是編譯NDK所需要的Makefile，從而完成JNI資訊鏈的講解。
Android.mk可以基於模版修改，裡面重要的變數包括：
a. LOCAL_C_INCLUDES：包含的頭文件。這裡需要包含JNI的頭文件。
b. LOCAL_SRC_FILES: 包含的源文件。
c. LOCAL_MODULE：當前模組的名稱，也就是第一步中我們提到的LIBNAME。注意這個需要加上lib前綴，但不需要加.so後綴，也就是說應該是libLIBNAME。
d. LOCAL_SHARED_LIBRARIES：當前模組需要依賴的共享庫。
e. LOCAL_PRELINK_MODULE：該模組是否被啟動就加載。該項設置依具體程式的特性而定。
5. 至此，JNI作為橋樑所需要的所有資訊均已就緒。JNI知道在調用Java代碼中的getPrintStr函數時，需要執行Native代碼。
於是通過System.loadLibrary所加載的libLIBNAME.so找到OnLoad入口。在OnLoad中，JNI發現了函數映射表，發現getPrintStr對應的Native函數是test_getPrintStr。
於是JNI將參數（如果有的話）傳遞給test_getPrintStr並執行，再將返回值（如果有的話）傳回Java中的getPrintStr。
6. 用於最後測試的test_getPrintStr函數實現如下：
const jstring testStr = env->NewStringUTF("hello, world");
return testStr;
然後在Java代碼中列印出返回的字串即可。這個網頁詳細介紹了env可以調用的所有方法。
7. 關於測試時使用Log。調用JNI進行Native Code的開發有兩種環境，完整源碼環境以及NDK。
兩種環境對應的Log輸出方式也並不相同，差異則主要體現在需要包含的頭文件中。
如果是在完整源碼編譯環境下，只要include <utils/Log.h>頭文件（位於Android-src/system/core/include/cutils）
，就可以使用對應的LOGI、LOGD等方法了，當然LOG_TAG，LOG_NDEBUG等宏值需要自定義。
如果是在NDK環境下編譯，則需要include <android/log.h>頭文件（位於ndk/android-ndk-r4/
platforms/android-8/arch-arm/usr/include/android/），另外自己定義宏映射，例如：
#include <android/log.h>
#ifndef LOG_TAG
#define LOG_TAG "MY_LOG_TAG"
#endif
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,LOG_TAG,__VA_ARGS__)
另外，在Android.mk文件中對類庫的應用在兩種環境下也不相同。如果是NDK環境下，需要包括 LOCAL_LDLIBS := -llog
而在完整源碼環境下，則需要包括 LOCAL_SHARED_LIBRARIES := libutils libcutils


/******************************************************************************/
Android 文件操作
/******************************************************************************/
android的文件操作要有權限：
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
判斷SD卡是否插入
Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED); 
獲得sd卡根目錄
File skRoot = Environment.getExternalStorageDirectory(); 
獲得私有根目錄
File fileRoot = Context.getFilesDir()+"\\";
確定或獲得文件夾和文件路徑
String path = File.getPath();//相對   
String path = File.getAbsoultePath();//絕對 
獲得文件或文件夾的父目錄
String parentPath = File.getParent()
獲得文件或文件夾的名稱：
String Name = File.getName(); 
建立文件或文件夾
File.createNewFile();//建立文件 
判斷是文件或文件夾
File.isDirectory() 
列出文件夾下的所有文件和文件夾名
File[] files = File.listFiles(); 
修改文件夾和文件名
File.renameTo(dest); 
刪除文件夾或文件
File.delete(); 
文件讀寫操作模式
Context.MODE_PRIVATE：新內容覆蓋原內容
Context.MODE_APPEND：新內容追加到原內容後
Context.MODE_WORLD_READABLE：允許其他應用程式讀取
Context.MODE_WORLD_WRITEABLE：允許其他應用程式寫入，會覆蓋原數據。

/*** 保存文件
* @param fileName
* @param fileContent
* @throws Exception*/
public void save(String fileName, String fileContent) throws Exception {
    // Activity的父類的父類就是context，context與其他框架中的context相同為我們以供了一些核心操作工具。
    FileOutputStream fileOutputStream = this.context.openFileOutput(
        fileName, Context.MODE_PRIVATE);
    fileOutputStream.write(fileContent.getBytes());
}

/**
* 讀取文件
*
* @param fileName
* @return
* @throws Exception
*/
public String read(String fileName) throws Exception {
    FileInputStream fileInputStream = this.context.openFileInput(fileName);
    ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024];
    int len = 0;
    while ((len = fileInputStream.read(buffer)) > 0) {
        byteArray.write(buffer, 0, len);
    };
    return byteArray.toString();
    }
}

/******************************************************************************/
ISO/IEC14443和15693的對比有何具體區別
/******************************************************************************/
ISO14443
     IS014443A/B:超短距離智慧卡標準。這標準訂出讀取距離7-15厘米的短距離非接觸智慧卡的功能及運作標準，使用的頻率為13.56MHz。
     IS014443定義了TYPE A, TYPE B兩種類型協定，通信速率為106kbit/s，它們的不同主要在於載波的調製深度及位的編碼方式。
     TYPE A採用開關鍵控(On-Off keying)的Manchester編碼，TYPE B採用NRZ-L的BPSK編碼。
     TYPE B與TYPE A相比，具有傳輸能量不中斷、速率更高、抗干擾能力強的優點。
     RFID的核心是防衝突技術，這也是和接觸式IC卡的主要區別。
     IS014443-3規定了TYPEA和TYPE B的防衝突機制.二者防衝突機制的原理不同，前者是基於位衝突檢測協定，而TYPE B通信系列命令序列完成防衝突.
     目前的第二代電子身份證採用的標準是IS014443 TYPE B協定。
ISO15693
    IS015693 (ISO SC17lWG8):短距離智慧卡標準，這標準訂出讀取距離可高達一米非接觸智慧卡，使用的頻率為13.56MHz,
    設計簡單讓生產讀取器的成本比IS014443低，大都用來做進出控制、出勤考核等，現在很多企業使用的門禁卡大都使用這一類的標準。

IS015693採用輪尋機制、分時查詢的方式完成防衝突機制。防衝突機制使得同時處於讀寫區內的多個標籤的正確操作成為可能，既方便了操作，也提高了操作的速度。
Iso10536，iso15693，iso14443的區別       
    ISO 10536標準主要發展於1992到1995年間，由於這種卡的成本高，與接觸式IC卡相比優點很少，因此這種卡從未在市場上銷售。 
    ISO 14443和ISO 15693標準在1995年開始操作，單個系統於1999年進入市場，兩項標準的完成則是在2000年之後。
    二者皆以13.56MHz交變信號為載波頻率：ISO15693讀寫距離較遠，當然這也與應用系統的天線形狀和發射功率有關；
    而ISO 14443 讀寫距離稍近，但應用較廣泛，目前的第二代電子身份證採用的標準是ISO 14443 TYPE B協定。 
    ISO14443定義了TYPE A、TYPE B兩種類型協定。通信速率為106kbits/s，它們的不同主要在於載波的調製深度及位的編碼方式。 
    從PCD向PICC傳送信號時，TYPE A採用改進的Miller編碼方式，調製深度為100%的ASK信號；TYPE B則採用NRZ編碼方式，調製深度為10%的ASK信號。


/******************************************************************************/
【原】android 中定時器的幾種用法總結    ref: http://hi.baidu.com/ljlkings/item/bf6fb853ccb1dc9009be17a6
/******************************************************************************/
在android中，經常用到的定時器主要有以下幾種實現：
一、採用Handler與線程的sleep(long )方法
二、採用Handler的postDelayed(Runnable, long) 方法
三、採用Handler與timer及TimerTask結合的方法。
下面逐一介紹：
一、採用Handle與線程的sleep(long )方法
Handler主要用來處理接受到的消息。這只是最主要的方法，當然Handler裡還有其他的方法供實現，有興趣的可以去查API，這裡不過多解釋。
1.定義一個Handler類，用於處理接受到的Message.
Handler handler = new Handler() {
   public void handleMessage(Message msg) {
    //要做的事情
    super.handleMessage(msg);
   }
};
2.新建一個實現Runnable介面的線程類。如下：
public class MyThread implements Runnable{
   @Override
   public void run() {
    // TODO Auto-generated method stub
    while (true) {
     try {
      Thread.sleep(10000);//線程暫停10秒，單位毫秒
      Message message=new Message();
      message.what=1;
      handler.sendMessage(message);//發送消息
     } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
     }
    }
   }
}
3.在需要啟動線程的地方加入下面語句：
new Thread(new MyThread()).start();
4.啟動線程後，線程每10s發送一次消息。

二、採用Handler的postDelayed(Runnable, long) 方法
這個實現比較簡單一些：
1. Handler handler=new Handler();
Runnable runnable=new Runnable(){
   @Override
   public void run() {
    // TODO Auto-generated method stub
    //要做的事情
    handler.postDelayed(this, 2000);
   } 
};
2.啟動計時器：
handler.postDelayed(runnable, 2000);//每兩秒執行一次runnable.
3.停止計時器：
handler.removeCallbacks(runnable);

三、採用Handler與timer及TimerTask結合的方法。
1.定義定時器、定時器任務及Handler控制碼
private final Timer timer = new Timer();
private TimerTask task;
Handler handler = new Handler() {
   @Override
   public void handleMessage(Message msg) {
    // TODO Auto-generated method stub
    //要做的事情
    super.handleMessage(msg);
   }
};
2.初始化計時器任務。
task = new TimerTask() {
    @Override
    public void run() {
     // TODO Auto-generated method stub
     Message message = new Message();
     message.what = 1;
     handler.sendMessage(message);
    }
   };
3.啟動定時器
timer.schedule(task, 2000, 2000);

簡要說一下上面三步提到的一些內容。
1.定時器任務（TimerTask）顧名思義，就是說當定時器到達指定的時間時要做的工作，這裡是想Handler發送一個消息，由Handler類進行處理。
2. java.util.Timer.schedule(TimerTask task, long delay):這個方法是說，dalay/1000秒後執行task.只執行一次。
java.util.Timer.schedule(TimerTask task, long delay, long period)：這個方法是說，delay/1000秒後執行task,然後進過period/1000秒再次執行task，這個用於循環任務，執行無數次，當然，你可以用timer.cancel();取消計時器的執行。
 
如果我們採用第一種方法，如何結束掉線程呢？當然如果你的程式在run方法裡有做控制，線程就不用結束，當run方法運行完畢，線程也就隨之結束。那今天就說一下在Handler裡面對線程的控制，如果想要在Handler裡面結束線程，可用：
Thread.currentThread().interrupt();
Thread.currentThread()可以獲得消息發送的線程，interrupt即是中斷。


/******************************************************************************/
/******************************************************************************/
[2013-07-22 18:00:43 - JsapCtrlDockSample] Installing JsapCtrlDockSample.apk...
[2013-07-22 18:00:45 - JsapCtrlDockSample] Re-installation failed due to different application signatures.
[2013-07-22 18:00:45 - JsapCtrlDockSample] You must perform a full uninstall of the application. WARNING: This will remove the application data!
[2013-07-22 18:00:45 - JsapCtrlDockSample] Please execute 'adb uninstall com.example.jsapctrldocksample' in a shell.
[2013-07-22 18:00:45 - JsapCtrlDockSample] Launch canceled!


/******************************************************************************/
android 藍牙開發常見問題總結
/******************************************************************************/
androidxp通訊製造產品
1、主機和從機有什麼區別
主機是主動搜索的，從機是被搜索的，主機可以記憶從機地址、密碼，也可以放棄這些記憶
重新搜索。
(HC-06)主機如果配對過從機，那麼就會記憶該從機的地址和密碼，下次上電就只會找這個從機，直到找到為止。
(hc-05 的需要通過指令設置才可以綁定某個從機，默認是任意從機都可以配對的)如果主機的KEY（26 腳）置高電平，則會放棄記憶，重新搜索，搜索過程中會先搜到哪個從
機就先和這個從機配對，假如密碼不對，則會主動搜索下一個從機，直到密碼匹配的，則自動配對上。
主機與從機有什麼區別呢？都可以相互傳輸（或者本身具有接收和發送功能），如果把模組連接到外設上面，與帶藍牙的筆記本相互通訊，那麼這時藍牙模組算從機嗎？
回復：
1、主機和從機在核心模組的硬體上是一樣的，區別只在於軟體。
2、從機和主機配對使用，也都可以和普通的藍牙適配器配對使用，分出主機或從機的目的
之一是和別的產品配對，比如有些GPS 定位系統本身配有從機的，那麼就應該使用主機的
藍牙模組和他配對。
3、主從通信都是半全雙工的，也就是收發可同時進行。
4、從機模組是相對於主機模組和適配器而言的，但主機模組如果和電腦的適配器配對的話，
也可以認為是從機的。


2、適配器可以配對多少個從機？
一般而言，藍牙組織規定，藍牙可以有8 個節點，也就是說一個適配器可以配對7 個從機設備，但同一個環境裡，可以認為不管多少個藍牙同時使用，都不會產生干擾衝突，因為藍牙每秒調頻至少1600 次，理論上800 個藍牙一起使用也不會衝突，用戶分清同時使用不衝突與適配器最多同時配對多少個設備的區別

3、USB 藍牙適配器的購買應該注意的地方
隨著掩膜技術的發展，USB 藍牙適配器的製造成本越來越低，質量也良莠不齊，購買時需要注意幾個地方一是最好買2.0 版本的藍牙適配器，因為公認最穩定成熟的藍牙版本就是2.0 版本的，我公司的藍牙也是2.0 版本，相容性很好是不要買太便宜的，因為太便宜的一般都是有5M 流量限制的，所謂5M 流量限制就是盜的，沒有經過藍牙組織授權的，藍牙傳輸的數據量超過5M 就胡會自動斷開，但重啟藍牙可以重新擁有5M 流量，買來玩可以，買來用就最好買正規的。

4、藍牙適配器的驅動問題
一般XP 系統SP2 以上版本都自帶藍牙驅動，但XP 帶的驅動有些沒有聲卡驅動，就是說不能播放聲音，一般用於文件傳輸和數據傳輸。我公司有提供IVT 的適配器驅動下載，功能齊全，但這種驅動會沖掉XP 的驅動，如果沒必要就用XP 的就可以了，但我們習慣用IVT的。IVT 的使用問題可以參考我公司的下載中心的資料。

5 藍牙會自動匹配頻率嗎？
待補充


/******************************************************************************/
android parse xml
/******************************************************************************/
在anroid parse xml其實有蠻多方法的
例如SAX(Simple API for XML)、DOM...
大家都知道用SAX來parse會較省記憶體。
但用SAX的麻煩就是必須自己去寫content handler...
但如果您的XML檔並不大，且去讀取的次數沒有很頻繁，那麼還是建議您用DOM吧!較簡單!
實作方法如下:

private static DocumentBuilder documentBuilder  = null; 
private static Document document        = null;
private static NodeList elements        = null;
private static int iElementLength= 0;
 
@Override
public void onStart(Intent intent, int startId) {
 super.onStart(intent, startId);
 try{
   
  URL urlUpdate = new URL("http://www.xxx.xxx/xxx.xml");
  documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder(); 
  document = documentBuilder.parse(urlUpdate.openStream());     
  document.getDocumentElement().normalize(); 
   
  /*
  *其實簡單到我也不知該怎麼寫註解了，
  *先get到你要的tag吧，記得回傳型態是NodeList，
  *不要看我命名為elements，就以為他是Element
  */
  elements  = document.getElementsByTagName("update_images");
  iElementLength=elements.getLength();
  if (iElementLength ==0 )
     return;

  for (int i = 0; i < iElementLength ; i++) {
    Element element = (Element) elements.item(i);
    Log.d("main",element.getAttribute("pic_name"));
  }
  }catch (Exception e) {
    Log.d("main",String.valueOf(e.toString()));
  }
}

大概就是這樣!


/******************************************************************************/
不懂JNI的朋友應該看，對學習android NDK很有幫助的文檔！
/******************************************************************************/
將介紹如何學習安裝Android NDK 並開始使用它。在這一教程結束後，將創建你自己的項目，從Java 代碼簡單地調用原生C 語言代碼。

先決經驗：
在開始之前，需要先花點時間瞭解一下這一教程的難度。 它的標記是「進階」。 之所以標為「進階」是因為作者想要確保你符合以下要求：
1、有Java和C語言經驗。
2、能適應命令行操作。
3、知道如何瞭解你的Cygwin、awk 和其他工具的版本。
4、能適應Android Development。
5、有一個有效的Andr??oid 開發環境（本文撰寫時，筆者使用的是Android 2.2）
5、使用Eclipse 或者可以將Eclipse 的指導步驟輕鬆應用於自己的IDE 上。
6、就算並不滿足這些條件，當然也歡迎你閱讀這一教程，不過可能在某些步驟遇到困難。

如果滿足了以上條件這些困難就會輕易解除。 也就是說，即使認為自己是個移動開發老手，使用NDK 依然很容易碰到困難和麻煩。 
請注意可能要自行排查故障才能讓一切正常運轉於你的開發系統中。
本教程提供完整的樣例項目的開源代碼。 （我麼有找到下載的東東）

何時使用NDK 的說明
好，正在閱讀這篇教程的你，也許已經在考慮在你的Android 項目中使用NDK 了。
不過，作者想要花點時間討論一下NDK 為什麼那麼重要、何時該使用它，以及——同等重要的，何時不該使用它。
總的來說，只有當應用程式真的是個處理器殺手的時候，你才需要使用NDK。 也就是說，你設計的算法要利用DalvikVM 中所有的處理器資源，而且原生運行較為有利。
還有，別忘了在Android 2.2 中，JIT 編譯器會提高類似代碼的效率。
另一個使用NDK 的原因是方便移植。 如果在現有的應用程式中有大量的C 語言代碼，那麼使用NDK 不僅可以加速你項目的開發進程，也能在你的Android 和非Android 項目中
保持修改的同步。 這一點對於那些為其他平台而寫的OpenGL ES 應用程式來說尤為如此。
別以為只要用了原生代碼就能提高應用程式的效率。 Java 與原生C 語言之間的轉換會增加一些資源開銷，因此只有你有一些集中消耗處理器資源的任務時才真正有必要這麼做。

第0 步：下載工具
       好了，現在就開始吧！ 你需要下載NDK。 先來開始下載，因為在下載的過程中你可以檢查一下，確保所需要用到的其餘工具的版本都正確。
       從Android 網站下載適合你的作業系統的NDK。
       現在，對照下列檢查你的工具版本：
             1、如果在Windows 下，Cygwin 1.7 或更高版本
             2、將awk 升級到最新版本（我們使用的是20070501）
             3、GNU Make 3.81 或更高版本（我們使用的是3.81）
         如果其中任何一個的版本太舊，請在繼續之前先升級。
第1 步：安裝NDK
        既然NDK已經下載完成（沒錯吧？），你就需要解壓縮它。 解壓後將它放入合適的目錄中。 要把它放在和Android SDK相同的目錄下。記住你把它放在哪裡了 。
        現在，你也許想要在路徑設置中添加NDK 工具。 如果你在Mac 或Linux 下，你可以用你的原生路徑設置來完成。 
        如果你在Windows 下的Cygwin，你就需要設置Cygwin 的路徑設置。
第2 步：創建項目
         創建一個常規的Android 項目。 為了避免日後的問題，你項目的路徑必須不包含空格。 
         作者的項目有個叫做「com.mamlambo.sample.ndk1」的包，帶有一個叫做「AndroidNDK1SampleActivity」的默認Activity——你之後還會看到它們。
         在這個項目的頂層創建一個叫做「jni」的目錄——這是你放置原生代碼的地方。 如果你很熟悉JNI，那你就會知道Android NDK 很大程度上基於JNI 的概念
         ——它本質上是個只有有限的C 語言編譯頭文件的JNI。
第3 步：添加一些C 語言代碼
     現在，在jni 文件夾中，創建一個叫做native.c 的文件。 一開始將以下C 語言代碼寫入該文件，我們以後再添加另一個函數：
     #include
     #include
     #include
     #define DEBUG_TAG "NDK_AndroidNDK1SampleActivity"
     void Java_com_mamlambo_sample_ndk1_AndroidNDK1SampleActivity_helloLog(JNIEnv * env, jobject this, jstring logThis)
     {
         jboolean isCopy;
         const char * szLogThis = (*env)->GetStringUTFChars(env, logThis, &isCopy);
         __android_log_print(ANDROID_LOG_DEBUG, DEBUG_TAG, "NDK:LC: [%s]", szLogThis);
         (*env)->ReleaseStringUTFChars(env, logThis, szLogThis);
     }
    這個函數實際上非常淺顯。 
      它獲取一個Java 對象的字串參數，將它轉換為C-string，然後將它寫入到LogCat 中。
    不過該函數的名字很重要。 
      它遵循了以「Java」的特定字樣開頭，後面跟著包名稱，然後類名稱，然後方法名稱，和Java 中定義的一樣。 每一部分都由一根下劃線隔開，而不是點。
    該函數的頭兩個參數也很重要。 
      第一個參數是JNI 環境，它與helper 函數會被頻繁調用。 第二個參數是該函數所屬的Java 對象。
第4 步：從Java 中調用原生代碼
    既然你已經寫好了原生代碼，讓我們回頭看看Java 這邊。 在默認的Activity 中，按照你的喜好創建一個按鈕，並添加一個按鈕處理器。
    從按鈕處理器中，對helloLog 作調用：
    helloLog("This will log to LogCat via the native call.");
複製代碼
    然後你必須在Java 這邊添加函數聲明。 在你的Activity 類中添加如下聲明：
    private native void helloLog(String logThis);
複製代碼
    它告訴編譯和鏈接系統該方法將在原生代碼中實現。
    最後，你需要加載原生代碼最終編譯到的庫。 在Activity 類中添加如下的靜態初始化程式來根據名稱加載庫（庫的名字隨你決定，在下一步還會用到）：
    static {
        System.loadLibrary("ndk1");
    }
第5 步：添加原生代碼的Make 文件
    在jni 文件夾中，現在你需要添加在編譯中要用到的makefile。 該文件必須以「Android.mk」命名，如果你之前命名的文件為native.c，庫為ndk1，那麼Android.mk 的內容就應該是這樣：
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_LDLIBS := -llog
    LOCAL_MODULE := ndk1
    LOCAL_SRC_FILES := native.c
    include $(BUILD_SHARED_LIBRARY)
第6 步：編譯原生代碼
    既然你的原生代碼已完成，make 文件也已就緒，是時候編譯原生代碼了。 在命令行下（Windows 用戶在Cygwin 下），你需要在你的項目的根目錄下運行ndk-build 命令。 
    ndk-build 工具就在NDK 工具目錄中。 將它添加到我們的路徑中是最方便的辦法。
    在之後的編譯中，如果你使用「ndk-build clean」命令，那麼你可以確保所有的東西都被重新編譯了。
第7 步：運行代碼
    現在你已準備妥當可以運行代碼了。 在你最喜歡的模擬器或者手持設備中載入該項目，查看LogCat，然後點擊按鈕。
    可能有兩件事情會發生。 首先，它可能正常工作了。 這樣的話，恭喜你！ 不過你可能還是想要繼續閱讀下去。
    你也可能在LogCat 中得到類似「Could not execute method of activity」這樣的錯誤。 這很正常。 這只是說明你漏掉了某個步驟罷了。 用Eclipse 很容易發生這種情況。通常，Eclipse 被設置為自動重編譯。
    如果它不知道有東西被修改了，它就不會自動重編譯和重鏈接。 在本例中，Eclipse 不知道你編譯了原生代碼。 所以，「清除（cleaning）」該項目（在Eclipse 工具欄中點擊項目（Project）->清除（Clean）），強制Eclipse 重編譯。
第8 步：添加另一個原生函數
    接下來的函數將不僅演示返回值的能力，還會演示返回例如字串這樣的對象的能力。 在native.c 中添加如下函數：
    jstring Java_com_mamlambo_sample_ndk1_AndroidNDK1SampleActivity_getString(JNIEnv * env, jobject this, jint value1, jint value2)
    {
        char *szFormat = "The sum of the two numbers is: %i";
        char *szResult;
        // add the two values
        jlong?? sum = value1+value2;
        // malloc room for the resulting string
        szResult = malloc(sizeof(szFormat) + 20);
        // standard sprintf
        sprintf(szResult, szFormat, sum);
        // get an object string
        jstring result = (*env)->NewStringUTF(env, szResult);
        // cleanup
        free(szResult);
        return result;
    }
   為了正常編譯，你會需要添加一個include stdio.h 的聲明。 而且，為了響應這個新的原生函數，請在你的Activity Java 類中添加如下聲明：
   private native String getString(int value1, int value2);
   你現在可以隨意設定其功能。 我們使用如下兩個調用和輸出：
   String result = getString(5,2);
   Log.v(DEBUG_TAG, "Result: "+result);
   result = getString(105, 1232);
   Log.v(DEBUG_TAG, "Result2: "+result);
   回到C 語言函數中，你會注意到我們做了許多事情。 首先，我們在使用malloc() 函數中的sprintf() 調用時需要創建一個緩衝器（buffer）。 如果你不會忘記通過使用free() 函數清理結果，那麼這就很合理了。
   然後，為了傳回結果，你可以使用一個叫作NewStringUTF() 的JNI helper 函數。該函數基本上就是獲取一個C 語言字串，以之創建一個新的Java 對象。 這個新的字串對象就可以在之後作為結果返回，你就可以在Java 類中將它作為一個常規Java 字串對像使用了。

指令集、相容性
    Android NDK 需要Android SDK 1.5 或更高版本。 在新版本的NDK 中，有些新的頭文件可用於擴大對某些API 的訪問——特別是OpenGL ES 庫。
    不過，那些都不是我們要談論的相容性。 這是原生代碼，在使用時由處理器構架編譯。 因此，你要問自己的一個問題會是它支援何種處理器構架？ 在目前的NDK 中（在本文撰寫時）它只支援ARMv5TE 和ARMv7-A 指令集。 默認設置下，目標架構被設置為ARMv5TE，它可以在使用ARM 晶片的Andr??oid 設備上運行。
    它預計未來將支援其他指令集（其中提到了x86）。 這其中有很有意思的潛在狀況：NDK 解決方案無法適用於所有的設備。 例如，市面上有使用x86 指令集的英特爾（Intel）Atom 處理器的Andr??oid 平板設備。
    那麼NDK 在模擬器上如何呢？ 模擬器運行的是真正的虛擬機，包括完整的處理器虛擬。 沒錯，這意味著在虛擬機中運行Java 就等於是在虛擬機中運行了一個虛擬機。
總結
    成果如何？ 你裝上了Android NDK，最終完成了部分使用原生C 語言代碼的功能完善、正常運行的應用程式了嗎？ 我們希望如此。 在這一過程中有許多潛在的「出問題啦！」的可能，不過從某些方面來看，這些都是值得的。

/******************************************************************************/
在 Android 使用 Timer
/******************************************************************************/
有時必須用到簡單的計時排程功能，
以下兩個小範例示範實作 1000 毫秒的 Timer，
使用的方法不同，各有好處，啥好處啥壞處？還不知道 :P


後記：
謝謝幾位留言網友的提醒…一直寫 C++ 寫得習慣了…所以沒想到 Timer 不是在 UI Thread
在 Win32 中 Timer 是在訊息迴圈中一併處理…修改 UI 沒有什麼問題…
但在 Android 上若要修改 UI 就必須透過 Handler 的方式或其他方法嘍…


比較直觀的 Timer

import java.util.*;

public class MainActivity extends Activity
{
  Timer timer = new Timer(true);

  @Override
  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    timer.schedule(new timerTask(), 1000, 1000);
  }

  public class timerTask extends TimerTask
  {
    public void run()
    {
    }
  };
}


此外需注意的是當我們要停止這個 Timer 時，我們可以使用以下兩行指令任一種

timer.cancel();
timer.purge();


這是有差別的，cancel 一用下去等於這個 Timer 整個廢掉，
cancel 後再做 schedule 等動作也不會有任何反應，必須重新 new 一個 Timer
而 purge 是取消此 Timer 中所有的 task 動作，後續還可以重新啟動。

利用 Handler 做同樣的事


import android.os.Handler;

public class MainActivity extends Activity
{
  public class MainActivity extends Activity
  private ing m_nTime = 0;
  private Handler mHandlerTime = new Handler();

  @Override
  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    mHandlerTime.postDelayed(timerRun, 1000);
  }

  @Override
  public void onDestroy()
  {
    mHandlerTime.removeCallbacks(timerRun);
    super.onDestroy();
  }

  private final Runnable timerRun = new Runnable()
  {
    public void run()
    {
      ++m_nTime; // 經過的秒數 + 1
      mHandlerTime.postDelayed(this, 1000);
      // 若要取消可以寫一個判斷在這決定是否啟動下一次即可
    }
  };
}


/******************************************************************************/
How can I get a working vertical SeekBar in Android?
/******************************************************************************/
ref : http://stackoverflow.com/questions/4892179/how-can-i-get-a-working-vertical-seekbar-in-android

Here is a working VerticalSeekBar implementation:

package android.widget;

import android.content.Context;
import android.graphics.Canvas;
import android.util.AttributeSet;
import android.view.MotionEvent;

public class VerticalSeekBar extends SeekBar {

    public VerticalSeekBar(Context context) {
        super(context);
    }

    public VerticalSeekBar(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public VerticalSeekBar(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(h, w, oldh, oldw);
    }

    @Override
    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(heightMeasureSpec, widthMeasureSpec);
        setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());
    }

    protected void onDraw(Canvas c) {
        c.rotate(-90);
        c.translate(-getHeight(), 0);

        super.onDraw(c);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (!isEnabled()) {
            return false;
        }

        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_MOVE:
            case MotionEvent.ACTION_UP:
                setProgress(getMax() - (int) (getMax() * event.getY() / getHeight()));
                onSizeChanged(getWidth(), getHeight(), 0, 0);
                break;

            case MotionEvent.ACTION_CANCEL:
                break;
        }
        return true;
    }
}
To implement it, create a new class in your project, choosing the right package:



There, paste the code and save it. Now use it in your XML layout:

<android.widget.VerticalSeekBar
  android:id="@+id/seekBar1"
  android:layout_width="wrap_content"
  android:layout_height="200dp"
  />


/******************************************************************************/
在ActionBar中進行Fragment之間的切換
/******************************************************************************/
　　在ActionBar中添加標籤(Tabs)，每個標籤對應的是一個Fragment，點擊不同的Tab時，就會切換到對應的Fragment。
　　這裡有五個關鍵步驟：
　　１. 要實現 ActionBar.TabListener介面，當點擊Tab的時候觸發這個介面裡面的事件，
        有onTabSelected(), onTabUnselected(), 和 onTabReselected().　
        實現ActionBar.TabListener介面時，應當在類內有個Fragment的引用，這樣點擊這個Tab時就可以調用對應的Fragment.
　　2.　通過getActionBar() 方法得到Activity中的ActionBar。
　　3.　設置AcitonBar的操作模式： setNavigationMode(NAVIGATION_MODE_TABS)。
　　4.　在ActionBar中添加Tabs：
        一.調用AciontBar的newTab()生成一個ActionBar.Tab. 
        二.為Tab增加text或者icon .調用setText() ， setIcon()　
        三.為每個 ActionBar.Tab 添加ActionBar.TabListener.
　　5.　調用addTab()將生成的Tab加入ActionBar中

　　以下是例子代碼，就是為了測試，沒有實際的用途.
　　有兩個Fragment:EditFragment和ComputerFragment，對應的Tab是"編輯"和計算。他們的XML和Activity如下：

EditFragment:
public class EditFragment extends Fragment
{
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        System.out.println("EidtFragment--->onCreate");
        super.onCreate(savedInstanceState);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
    {
        System.out.println("EidtFragment--->onCreateView");
        return inflater.inflate(R.layout.editfragment, container, false);
    }

    @Override
    public void onStop()
    {
        System.out.println("EidtFragment--->onStop");
        super.onStop();
    }
}

editfragment.xml:

複製代碼
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:text="請輸入你的資訊:"
        android:textSize="20dp" />

    <EditText
        android:layout_width="fill_parent"
        android:layout_height="40pt"
        android:layout_margin="5dp"
        android:background="@android:color/darker_gray"
        android:textSize="18dp" />

</LinearLayout>

ComputerFragment:
public class ComputerFragment extends Fragment
{
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        System.out.println("ComputerFragment--->onCreate");
        super.onCreate(savedInstanceState);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
    {
        System.out.println("ConputerFragment--->onCreateView");
        return inflater.inflate(R.layout.computerfragment, container, false);
    }

    @Override
    public void onStop()
    {
        System.out.println("ConputerFragment--->onStop");
        super.onStop();
    }
}

computerfragment.xml:
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:text="簡單加法計算"
        android:textSize="20dp" />

    <EditText
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@android:color/darker_gray" />

    <EditText
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@android:color/darker_gray" />

    <Button
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="開始計算" />

</LinearLayout>

 主要的程式：MainActivity:
public class MainActivity extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        System.out.println("MainActivity--->onCreate");
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // 得到Activity的ActionBar
        ActionBar actionBar = getActionBar();
        // 設置AcitonBar的操作模型
        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
        // 將Activity的頭部去掉
        actionBar.setDisplayShowTitleEnabled(false);
        // 生成Tab
        Tab edit = actionBar.newTab().setText("編輯");
        Tab computer = actionBar.newTab().setText("計算");
        // 為每個Tab添加Listener
        MyTabListener editListener = new MyTabListener(new EditFragment());
        edit.setTabListener(editListener);
        MyTabListener computerListener = new MyTabListener(new ComputerFragment());
        computer.setTabListener(computerListener);
        // 將Tab加入ActionBar中
        actionBar.addTab(edit);
        actionBar.addTab(computer);
    }

    @Override
    protected void onStop()
    {
        System.out.println("MainActivity--->onStop");
        super.onStop();
    }

    /**
     * 實現ActionBar.TabListener介面
     */
    class MyTabListener implements TabListener
    {
        // 接收每個Tab對應的Fragment，操作
        private Fragment fragment;

        public MyTabListener(Fragment fragment)
        {
            this.fragment = fragment;
        }

        public void onTabReselected(Tab tab, FragmentTransaction ft)
        {

        }

        // 當Tab被選中的時候添加對應的Fragment
        public void onTabSelected(Tab tab, FragmentTransaction ft)
        {
            ft.add(R.id.context, fragment, null);
        }

        // 當Tab沒被選中的時候刪除對應的此Tab對應的Fragment
        public void onTabUnselected(Tab tab, FragmentTransaction ft)
        {
            ft.remove(fragment);
        }
    }
}

/******************************************************************************/
Android系統onKeyDown監控/攔截/監聽/屏蔽返回鍵、功能表鍵和Home鍵
/******************************************************************************/
我們可以在很多應用中都能看到按兩次返回鍵退出，其實這個功能實現很容易，
下面就是實現的代碼 ， 把它放到你的程式中你的程式就能按兩次返回鍵退出啦 ，這個功能是為了避免誤點而把程式退出了，給你的程式也加上這個簡單實用的功能把 ：

import android.app.Activity;
import android.app.AlertDialog;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.WindowManager;
import android.widget.Toast;

public class MainActivity extends Activity {
    private long mExitTime;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD);
        setContentView(R.layout.activity_main);
    }

    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            if ((System.currentTimeMillis() - mExitTime) > 2000) {// System.currentTimeMillis()無論何時調用，肯定大於2000
                Toast.makeText(this, "再按一次退出程式", Toast.LENGTH_SHORT).show();
                mExitTime = System.currentTimeMillis();
            }
            return true;
        } else if (keyCode == KeyEvent.KEYCODE_MENU) {
            System.out.println("您按了功能表鍵");
            CreatAlertDialog("您按了功能表鍵");
            Toast.makeText(this, "您按了功能表鍵", Toast.LENGTH_SHORT).show();
            return true;
        } else if (keyCode == KeyEvent.KEYCODE_HOME) {
            // 由於Home鍵為系統鍵，此處不能捕獲，需要重寫onAttachedToWindow()
            System.out.println("您按了HOME鍵");
            CreatAlertDialog("您按了HOME鍵");
            Toast.makeText(this, "您按了HOME鍵", Toast.LENGTH_SHORT).show();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }
    
    private void CreatAlertDialog(String str){
        new AlertDialog.Builder(this).setIcon(R.drawable.ic_launcher)
        .setMessage(str)
        .show();
    }
}

攔截/屏蔽系統Home鍵
//屏蔽HOME鍵
    public void onAttachedToWindow() {  
         this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD);     
         super.onAttachedToWindow();    
    }
 

/******************************************************************************/
Android筆記：Fragment與Activity之間的交互
/******************************************************************************/
在Activity中有一個FragmentRight.
step1.首先，為了在Activity中能夠使用FragmentRight，寫了一條：
fragmentRight = (FragmentRight) getFragmentManager().findFragmentById(R.id.fragmentright);

當然，fragmentright.xml就是FragmentRight的佈局文件了。
寫了這條以後，就可以在Activity中使用FragmentRight實例的方法了

step2.然後，在FragmentRight中我有個按鈕，當按它的時候，要觸發一些代碼。這時，要在FragmentRight中定義一個介面，和一個方法:
// Container Activity must implement this interface
public interface OnMyButtonClickListener {
    public void onMyButtonClick();//介面中定義一個方法
}

當然，之後要在需要的地方調用這個方法。我是在按FragmentRight上那個按鈕時調用它。我的按鈕就叫testButton.
慢著，介面的方法要被調用前，當然要先聲明介面類型的成員變數：
private OnMyButtonClickListener mListener;
testButton.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        mListener.onMyButtonClick();
    }
});

step3.在FragmentRight的onAttach（）方法中給mListener這個成員變數賦個值，不然會出討厭的nullpointerexception哦。
@Override
public void onAttach(Activity activity)
{
    super.onAttach(activity);
    try {
        mListener = (OnbtnSendClickListener) activity;//這句就是賦初值了。
    }
    catch (ClassCastException e) {
        throw new ClassCastException(activity.toString() + "must implement OnbtnSendClickListener");//這條表示，你不在Activity裡實現這個介面的話，我就要拋出異常咯。知道下一步該幹嘛了吧？
    }
}

step4.在Activity中實現這個介面:
...... extends Activity implements OnMyButtonClickListener{......
並且，重寫該介面中定義的方法吧：
@Override
public void onMyButtonClick()
{
    ......//在這裡該幹嘛幹嘛唄。
}



/******************************************************************************/
Update TextView on timer tick in fragment
/******************************************************************************/
public class FragmentA extends Fragment {

    //timer
        private TimerTask mTimerTask;
        private Timer timer = new Timer();  

        private final Handler timerHandler = new Handler();

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        View myFragmentView = inflater.inflate(R.layout.fragment_a, container, false);


        //TextView for Device name
        TextView textView3 = (TextView)myFragmentView.findViewById(R.id.TextView3);
        //TextView for Serial number
        TextView textView5 = (TextView)myFragmentView.findViewById(R.id.TextView5);
        //TextView for Software version
        TextView textView7 = (TextView)myFragmentView.findViewById(R.id.TextView7);

        onTimerTick();
        timer.schedule(mTimerTask, 10, 1000); 

        return myFragmentView;
    }

        //timer tick on every 1 s 
        public void onTimerTick() {
            mTimerTask = new TimerTask() {
                //this method is called every 1ms
                public void run() {                 
                     timerHandler.post(new Runnable() {
                         public void run() {  
                            //update textView
                            //ERROR:textView2 cannot be resolved
                                textView2.setText(m_info.deviceName);
                            Log.d("tag", "Hello from timer fragment");
                         }
                     });                    
                }};      
        }             
}


/******************************************************************************/
Fragment對menu功能表的操作
/******************************************************************************/
android4.0之後引入了fragment的概念，它的生命週期函數和activity幾乎一樣。對功能表的操作也是通過onCreateOptionMenu（）實現的。
fragment可以通過實現 onCreateOptionMenu() 提供功能表項給activity的選項功能表。
為了使這個方法接收調用,無論如何, 你必須在 onCreate() 期間調用 setHasOptionsMenu() 來指出fragment願意添加item到選項功能表
(否則, fragment將接收不到對 onCreateOptionsMenu()的調用)

隨後從fragment添加到Option功能表的任何項,都會被追加到現有功能表項的後面.
當一個功能表項被選擇, fragment也會接收到對 onOptionsItemSelected() 的回調.
也可以在你的fragment layout中通過調用 registerForContextMenu() 註冊一個view來提供一個環境功能表.
當用戶打開環境功能表, fragment接收到一個對 onCreateContextMenu() 的調用.當用戶選擇一個項目, fragment接收到一個對onContextItemSelected() 的調用.

注意: 儘管你的fragment會接收到它所添加的每一個功能表項被選擇後的回調, 但實際上當用戶選擇一個功能表項時, activity會首先接收到對應的回調.
如果activity的on-item-selected回調函數實現並沒有處理被選中的項目, 然後事件才會被傳遞到fragment的回調.


例子：
onCreate() 期間調用 setHasOptionsMenu() 來指出fragment願意添加item到選項功能表
public static class DetailsFragment extends Fragment {
  
        @Override
        public void onCreate(Bundle savedInstanceState) {
            // TODO Auto-generated method stub
            super.onCreate(savedInstanceState);
            setHasOptionsMenu(true);
        }
}

操作功能表
       @Override
        public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
            // TODO Auto-generated method stub
            super.onCreateOptionsMenu(menu, inflater);
             menu.add("Menu 1a").setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
             menu.add("Menu 1b").setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
        }
          
        @Override
        public boolean onOptionsItemSelected(MenuItem item) {
            // TODO Auto-generated method stub
            Toast.makeText(getActivity(), "index is"+getShownIndex()+" && menu text is "+item.getTitle(), 1000).show();
            return super.onOptionsItemSelected(item);
        }



/******************************************************************************/
ndroid ActionBar使用方法
/******************************************************************************/
在Android 3.0中除了我們重點講解的Fragment外，Action Bar也是一個重要的內容，Action Bar主要是用於代替傳統的標題欄，對於Android平板設備來說螢幕更大它的標題
使用Action Bar來設計可以展示更多豐富的內容，方便操控。
這裡只是簡單的介紹，我建議你看完這篇文章之後詳細閱讀這篇文章 http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1114/554.html

Action Bar主要功能包含:
　　1. 顯示選項功能表
　　2. 提供標籤頁的切換方式的導航功能，可以切換多個fragment.
　　3. 提供下拉的導航條目.
　　4. 提供交互式活動視圖代替選項條目
　　5. 使用程式的圖示作為返回Home主屏或向上的導航操作。

提示在你的程式中應用ActionBar需要注意幾點，SDK和最終運行的固件必須是Android 3.0即honeycomb，
在androidmanifest.xml文件中的uses-sdk元素中加入android:minSdkVersion 或android:targetSdkVersion，類似
< manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="eoe.android.cwj"
    android:versionCode="1"
    android:versionName="1.0">
    < uses-sdk android:minSdkVersion="honeycomb" />
    < application ... >

    < /application>
< /manifest>
如果需要隱藏Action Bar可以在你的Activity的屬性中設置主題風格為NoTitleBar在你的manifest文件中，下面的代碼在3.0以前是隱藏標題，
而在3.0以後就是隱藏ActionBar了，代碼為
< activity android:theme="@android:style/Theme.NoTitleBar">

一、添加活動條目 Action Items
　　對於活動條目大家可以在下圖看到Android 3.0的標題右部分可以變成工具欄，下面的Save和Delete就是兩個Action Items活動條目。
　　下面是一個menu的layout佈局文件代碼
< ?xml version="1.0" encoding="utf-8"?> 
< menu xmlns:android="http://schemas.android.com/apk/res/android"> 
    < item android:id="@+id/menu_add"
    android:icon="@drawable/ic_menu_save"
    android:title="@string/menu_save"
    android:showAsAction="ifRoom|withText" />
< /menu>

    而其他代碼類似Activity中的Menu，比如
@Override 
public boolean onOptionsItemSelected(MenuItem item) { 
       
    switch (item.getItemId()) {
        case android.R.id.home:
        // 當Action Bar的圖示被單擊時執行下面的Intent
        Intent intent = new Intent(this, Android123.class);
        startActivity(intent);
        break;
    }

    return super.onOptionsItemSelected(item);
       
}
    對於ActionBar的創建，可以在你的Activity中重寫onStart方法
@Override 
       
protected void onStart() { 
    super.onStart(); 
    ActionBar actionBar = this.getActionBar(); 
    actionBar.setDisplayOptions(ActionBar.DISPLAY_HOME_AS_UP, ActionBar.DISPLAY_HOME_AS_UP); 
       
}
調用getActionBar方式在你的Activity的onCreate中時需要注意必須在調用了setContentView之後。

二、添加活動視圖 Action View
對於ActionView，我們可以在menu的佈局文件使用中來自定義searchview佈局，如代碼
< item android:id="@+id/menu_search"
     android:title="Search"
     android:icon="@drawable/ic_menu_search"
     android:showAsAction="ifRoom"
     android:actionLayout="@layout/searchview" />
也可以直接指定Android系統中的SearchView控件，那麼這時menu"_search的代碼要這樣寫
< item android:id="@+id/menu_search"
     android:title="Search"
     android:icon="@drawable/ic_menu_search"
     android:showAsAction="ifRoom"
     android:actionViewClass="android.widget.SearchView" />
大家注意上面的兩種方法中一個屬性是actionLayout制定一個layout xml佈局文件，一個是actionViewClass指定一個類，最終調用可以在Activity中響應onCreateOptionsMenu方法映射這個menu佈局即可。
@Override 
public boolean onCreateOptionsMenu(Menu menu) { 
    getMenuInflater().inflate(R.menu.options, menu);
    SearchView searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
    return super.onCreateOptionsMenu(menu);
}
有關Android活動欄-ActionBar的功能除了添加活動條目 Action Items和添加活動視圖 Action View外現在和大家一起來看下支援多Fragment切換的ActionBar標籤頁和下拉導航。
系列之Android ActionBar使用方法（二）的帖子鏈接http://www.eoeandroid.com/thread-71414-1-1.html

原文http://www.eoeandroid.com/thread-71410-1-1.html


/******************************************************************************/
Fragment與FragmentActivity的關係
/******************************************************************************/
前陣用viewpaper+fragment做滑動引導，查閱了下網上的資料，發現在有兩種做法，一個是自建類直接繼承Activity另一種是繼承FragmentActivity，很是迷惑，在查了些google的官方文檔和StackOverflow之後有了些理解，在此坐下記錄。下面的英文說明取自Stackoverflow，個人感覺解釋的很清楚。

A Fragment is a section of an Activity, which has:
. its own lifecycle
. receives its own input events
. can be added or removed while the Activity is running.

A Fragment must always be embedded in an Activity.
Fragments are not part of the API prior to HoneyComb (3.0). If you want to use Fragments in an app targeting a platform version prior to HoneyComb, 
you need to add the Support Package to your project and use the FragmentActivity to hold your Fragments. The FragmentActivity class has an API for 
dealing with Fragments, whereas the Activity class, prior to HoneyComb, doesn't.

If your project is targeting HoneyComb or newer only, you should use Activity and notFragmentActivity to hold your Fragments.

Some details:
Use android.app.Fragment with Activity. Use android.support.v4.app.Fragment withFragmentActivity. Don't add the support package Fragment to an Activity 
as it will cause an Exception to be thrown.
A thing to be careful with: FragmentManager and LoaderManager have separate support versions for FragmentActivity:
If you are using a Fragment in an Activity (HoneyComb and up), call

getFragmentManager() to get android.app.FragmentManager
getLoaderManager() to get android.app.LoaderManager
if you are using a Fragment in a FragmentActivity (pre-HoneyComb), call:

getSupportFragmentManager() to get android.support.v4.app.FragmentManager.
getSupportLoaderManager() to get android.support.v4.app.LoaderManager
so, dont do

myFragmentActivity.getLoaderManager()//don't do this, do myFragmentActivity.getSupportLoaderManager()
or

android.app.FragmentManager fm = myFragmentActivity.getSupportFragmentManager()//don't do this, 
do android.support.v4.app.FragmentManager fm = myFragmentActivity.getSupportFragmentManager()
Also useful to know is that while a fragment has to be embedded in an Activity it doesn't have to be part of the Activity layout. 
It can be used as an invisible worker for the activity, with no UI of its own.

總結來說就是標紅記錄的說明：
1、fragmentactivity 繼承自activity，用來解決android3.0 之前沒有fragment的api，所以在使用的時候需要導入support包，同時繼承fragmentActivity，
這樣在activity中就能嵌入fragment來實現你想要的佈局效果。
2、當然3.0之後你就可以直接繼承自Activity，並且在其中嵌入使用fragment了。
3、獲得Manager的方式也不同
3.0以下：getSupportFragmentManager()
3.0以上：getFragmentManager()


/******************************************************************************/
Android基礎——Fragment控制切換多個頁面
/******************************************************************************/
1、管理Fragment
要在activity中管理fragment,需要使用FragmentManager. 通過調用activity的getFragmentManager()取得它的實例.
可以通過FragmentManager做一些事情, 包括: 
使用findFragmentById()(用於在activity layout中提供一個UI的fragment) 或
findFragmentByTag()(適用於有或沒有UI的fragment)獲取activity中存在的fragment。
將fragment從後台堆棧中彈出, 使用 popBackStack() (模擬用戶按下BACK 命令)。
使用addOnBackStackChangeListener()註冊一個監聽後台堆棧變化的listener。
 
2、處理Fragment事務
關於在activity中使用fragment的很強的一個特性是：根據用戶的交互情況,對fragment進行添加、移除、替換以及執行其他動作。
提交給activity的每一套變化被稱為一個事務，可以使用在FragmentTransaction中的 API 處理。
我們也可以保存每一個事務到一個activity管理的backstack，允許用戶經由fragment的變化往回導航(類似於通過 activity往後導航)。

從 FragmentManager 獲得一個FragmentTransaction實例：
FragmentManager fragmentManager =getFragmentManager();
FragmentTransaction fragmentTransaction =fragmentManager.beginTransaction();
　　每一個事務都是同時要執行的一套變化。可以在一個給定的事務中設置你想執行的所有變化,使用諸如 add()、remove()和 replace()。
    然後, 要給activity應用事務，必須調用 commit()。
　　在調用commit()之前，你可能想調用 addToBackStack()，將事務添加到一個fragment事務的backstack。
    這個back stack由activity管理， 並允許用戶通過按下 BACK按鍵返回到前一個fragment狀態。

//創建修改實例
Fragment newFragment = newExampleFragment();
FragmentTransaction transaction =getFragmentManager().beginTransaction();
// Replace whatever is in thefragment_container view with this fragment,
// and add the transaction to the backstack
transaction.replace(R.id.fragment_container,newFragment);
transaction.addToBackStack(null);
//提交修改
transaction.commit();

上面是如何將一個fragment替換為另一個，並在後台堆棧中保留之前的狀態。
在這個例子中，newFragment替換了當前layout容器中的由R.id.fragment_container標識的fragment。
通過調用 addToBackStack()， replace事務被保存到back stack，因此用戶可以回退事務，並通過按下BACK按鍵帶回前一個fragment。

如果添加多個變化到事務(例如add()或remove())並調用addToBackStack()，然後在你調用commit()之前的所有應用的變化會被作為一個單個事務添加到後台堆棧，
BACK按鍵會將它們一起回退。添加變化到 FragmentTransaction的順序不重要, 除以下例外: 

必須最後調用 commit()
如果添加多個fragment到同一個容器, 那麼添加的順序決定了它們在view hierarchy中顯示的順序

當執行一個移除fragment的事務時， 如果沒有調用 addToBackStack()， 那麼當事務提交後，那個fragment會被銷毀，並且用戶不能導航回到它。
有鑒於此，當移除一個fragment時，如果調用了addToBackStack()， 那麼fragment會被停止，如果用戶導航回來，它將會被恢復。
另外，對於每一個fragment事務，你可以應用一個事務動畫，通過在提交事務之前調用setTransition()實現。

調用 commit() 並不立即執行事務。恰恰相反，它將事務安排排期， 一旦準備好，就在activity的UI線程上運行(主線程)。
如果有必要， 無論如何，你可以從你的UI線程調用executePendingTransactions()來立即執行由commit()提交的事務。
但這麼做通常不必要，除非事務是其他線程中的任務的一個從屬。

 警告:你只能在activity保存它的狀態(當用戶離開activity)之前使用commit()提交事務.
 
 
3、與Activity通信
   儘管Fragment被實現為一個獨立於Activity的對象，並且可以在多個activity中使用,但一個給定的fragment實例是直接綁定到包含它的activity的。 
   特別的fragment可以使用 getActivity() 訪問Activity實例， 並且容易地執行比如在activity layout中查找一個view的任務。如下面的代碼：
   View listView =getActivity().findViewById(R.id.list);
　 同樣地,activity可以通過從FragmentManager獲得一個到Fragment的引用來調用fragment中的方法，使用findFragmentById() 或 findFragmentByTag()。
   ExampleFragment fragment =(ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);

4、總結
   最後需要說一下Fragment的例子，Android官方已經提供了Fragment的各種使用的Demo例子，在我們SDK下面的API Demo裡面就包含了Fragment的各種使用例子，需要看
   Demo的朋友，直接看API Demo那個程式就可以了，不用到處去找。裡面分開不同功能，實現了不同的類。可以根據需要查看具體代碼。


/******************************************************************************/
ANDROIDMANIFEST.XML 詳解        ref : http://homeserver.com.tw/2013/09/25/androidmanifest-xml-%E8%A9%B3%E8%A7%A3/
/******************************************************************************/
底下為丫忠參考到一篇對於AndroidManifest.xml說明的很詳細的文章，貼上來給參考用。
文章來源：https://code.google.com/p/androidbmi/wiki/AndroidManifest

Android 系統中的每一個應用程式，在安裝的過程裡，都得事先在 Android 框架中註冊、登記這個應用程式所建立的 Activity，並事先註明會使用到的服務。
譬如當我們在 Android 上安裝我們撰寫的 BMI 應用程式時，BMI 應用程式就會向 Android 框架登記相關資訊：BMI 應用程式將會用到 「Bmi」這個 Activity。
這份訊息存在於每個 Android 應用程式專案根目錄下的「AndroidManifest.xml」檔案中。如果我們在程式裡，要用到其他應用程式或服務所提供的功能，也需一併在此列出。

在安裝應用程式的時候，Android 框架會根據應用程式提供的這份清單，將資訊註冊於 Android 框架的註冊表中。
備註:
這麼說其實是不太精確的。Android 應用程式的運作流程，存在於四種載體中：
Activity (活動)
Broadcast Intent Receiver
Service
Content Provider
各種載體的相關內容會在後續章節提到時作解說。

預設的 Activity 清單
我們使用 eclipse Android 開發工具打開「BMI/AndroidManifest.xml」檔案。
切換到「AndroidManifest.xml」分頁標籤，查看預設的 「BMI/AndroidManifest.xml」檔案原始碼：
1  <?xml version="1.0" encoding="utf-8"?>
2  <manifest xmlns:android="http://schemas.android.com/apk/res/android"
3      package="com.demo.android.bmi"
4      android:versionCode="1"
5      android:versionName="1.0">
6      <application android:icon="@drawable/icon">
7          <activity android:name=".Bmi" android:label="@string/app_name">
8              <intent-filter>
9                  <action android:name="android.intent.action.MAIN" />
10                 <category android:name="android.intent.category.LAUNCHER" />
11            </intent-filter>
12          </activity>
13     </application>
14     <uses-sdk android:minSdkVersion="X" />
15 </manifest>
我們分行講解如下：

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    ....>
    ....
</manifest>
「AndroidManifest.xml」這個檔案也是以 XML 格式描述，每個 Android 應用程式都需要一個「AndroidManifest.xml」檔案，每份「AndroidManifest.xml」檔案的開頭都會
出現這段敘述。而整個「AndroidManifest.xml」檔案的敘述，都包含在「manifest」(清單)這個主要標籤中。

package="com.demo.android.bmi"
「package」 是「manifest」(清單)標籤的一個特別屬性，範例中的內容可用來標明，這個應用程式的進入點存在於「com.demo.android.bmi」這個名稱空間/路徑中。

android:versionCode="1"
android:versionName="1.0"
「android:versionCode」和「android:versionName」是應用程式版本號。 這兩個屬性是可選的(非必要)。 
「android:versionName」是給使用者看的版本號，如「1.0」、「2.0」。
「android:versionCode」則是開發者用的內部版本號，一般使用流水號。

<application android:icon="@drawable/icon" android:label="@string/app_name">
...
</application>
「manifest」標籤中主要包含一個「application」標籤(備註1)。
「application」標籤裡面，定義了所有這個應用程式用到的 Activity、服務等資訊。
「application」標籤中的「android:icon」屬性，定義了這個應用程式將顯示在 Android 主畫面中的應用程式圖示。
「android:icon="@drawable/icon"」表示應用程式圖示的資源檔存在於 「res/drawable/icon」 中。圖示的大小必須超過 64×64 像素（Pixel）。
「application」標籤中的「android:label」屬性可用來指定應用程式將顯示在 Home 主畫面上的名稱。也就是預設剛開好機時，可以從桌面下方拉出的應用程式列表。
<activity android:name=".Bmi" android:label="@string/app_name">
...
</activity>

「application」標籤中所有用到的 Activity ，都要包含在一個個「activity」標籤中(備註2)。
 Activity 是 Android 應用程式與使用者互動的主要元素，當使用者開啟一個應用程式，第一個看到的畫面就是一個 Activity。
 若是一個應用程式中包含多個畫面時，會定義多個不同的 Activity，我們也必須在「application」標籤中，使用多個「activity」標籤，為不同的 Activity 添加描述。
 如果我們已經在程式碼中定義好了 Activity ，卻忘了在「AndroidManifest.xml」檔案中加入對應的「activity」標籤，那麼在執行中呼叫到這個 Activity 的時候，將無
 法開啟這個 Activity。
「activity」標籤的「android:name」屬性，指出了這個 Activity 所對應的類別(class)。
「activity」標籤中的「android:label」屬性可用來指定應用程式將顯示在 Activity 畫面上方的名稱。也可以在程式碼中透過「setTitle(「名稱」)」來動態修改。
因為在上一層「Manifest」標籤屬性中已經定義了「package="com.demo.android.bmi"」，因此在「activity」標籤的 「android:name」屬性中，
「.Bmi」代表著「com.demo.android.bmi.Bmi」的簡寫。也可以寫成「Bmi」，一樣是代表「com.demo.android.bmi.Bmi」這個類別。

<intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
「intent-filter」標籤定義了這個「activity」的性質。 「intent-filter」中主要包含了兩個標籤：「action」跟「category」標籤。

「action」標籤中的「android:name」屬性，其內容「android.intent.action.MAIN」表示：這個 Activity 是此應用程式的進入點（就像程式中常見的 main 主程式），開啟這個應用程式時，應先執行這個 Activity。常見的還有「android.intent.action.EDIT」等標籤，會在之後章節用上的時候講解。

「category」標籤中的「android:name」屬性，其內容「android.intent.category.LAUNCHER」表示：這個 Activity 將顯示在 Launcher 的應用程式列表中。

我們把整個檔案合到一起看，可以總結出這個檔案所傳達的訊息：在「com.demo.android.bmi」路徑下的「Bmi.java」這個檔案中，已定義了一個主要的 Activity; 當我們打開 Android 的時候，顯示的是位於「res/drawable/icon」的圖示。一旦我們按下圖示來啟動這個應用程式，Android 應用程式框架會去尋找到定義了「android.intent.action.MAIN」內容的 「.Bmi」activity，並呼叫執行。

<uses-sdk android:minSdkVersion="X" />
Android SDK 1.1 版之後引入了這條敘述，「X」代表了目標版本代號。透過指定這個參數，系統可以依此辨別應用程式是否使用相容的 SDK 版本，好決定能否在這台機器上安裝執行。這也是一個可選填的選項。但如果我們的應用程式要發佈出去，一些強勢的通路如 Google Android Market 已規定所有新發佈的應用程式必須指定「android:minSdkVersion」這個參數。

各目標版本與代號對應表如下:

目標版本        代號
3.0     11
2.3.3   10
2.3     9
2.2     8
2.1     7
2.0.1   6
2.0     5
1.6     4
1.5     3
1.1     2
1.0     1
目前各版本佔有率可以參考官方的版本佔有率圖表： http://developer.android.com/resources/dashboard/platform-versions.html

這個圖表是根據最近 2 周間連上 Android Market 設備的比率來繪製。

備註1

除了「application」標籤外，還有「uses-permission」(例如允不允許存取SMS、能否存取聯絡簿、相機功能)、「permission」、「instrumentation」等主要標籤。相關的內容在後續章節用到時再一併解說。
備註2

除了「activity」標籤外，對應於 Android 應用程式的運作流程，還有「service」、「receiver」、「provider」等主要元件。相關內容會在後續章節提到時作解說。

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
